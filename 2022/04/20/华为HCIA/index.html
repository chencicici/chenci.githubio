<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"syst1m.top","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="大数据概述&amp;解决办法大数据的特征（5v+1c） 大量：数据量巨大，MB,GB,TB,PB 多样：数据类型多样，数据来源多样 数据来源：服务器日志、网站浏览信息、社交结构化数据：表格数据 平台、摄像头信息半结构化数据：网页html、xml非结构化数据：视频、音频、图片、文字 高速：数据产生速度快、数据处理速度快 价值：价值密度低 准确：数据真实性 复杂：数据产生速度快、数据的类型多样等特征，">
<meta property="og:type" content="article">
<meta property="og:title" content="华为HCIA">
<meta property="og:url" content="https://syst1m.top/2022/04/20/%E5%8D%8E%E4%B8%BAHCIA/index.html">
<meta property="og:site_name" content="Syst1m">
<meta property="og:description" content="大数据概述&amp;解决办法大数据的特征（5v+1c） 大量：数据量巨大，MB,GB,TB,PB 多样：数据类型多样，数据来源多样 数据来源：服务器日志、网站浏览信息、社交结构化数据：表格数据 平台、摄像头信息半结构化数据：网页html、xml非结构化数据：视频、音频、图片、文字 高速：数据产生速度快、数据处理速度快 价值：价值密度低 准确：数据真实性 复杂：数据产生速度快、数据的类型多样等特征，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151412876.png?token=ARYCSARTUOKY4IGIGBRS7KTCQCM62">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151412014.png?token=ARYCSAW7AVKCAPDCYNNV5YLCQCM74">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151412309.png?token=ARYCSAUWS6RZPANWYMQDOCLCQCNAU">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151412204.png?token=ARYCSAVN7VZ2UZ6V7RVJRITCQCNBS">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151413392.png?token=ARYCSAQS3MNXYXLIKXZRAT3CQCNFE">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151413093.png?token=ARYCSASXKVI2WMTKAJWTIR3CQCNF2">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151414245.png?token=ARYCSAUWFL3VQLC74QPFOFTCQCNHA">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151414157.png?token=ARYCSAXYXQNR64JHII24XQDCQCNII">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151414971.png?token=ARYCSATLAWLW5KMTUFKFGMLCQCNJA">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151414178.png?token=ARYCSAQANK6MV3W4IXLU2I3CQCNJY">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151415672.png?token=ARYCSAXFO4SAXDL2SDP6U2DCQCNMS">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151415737.png?token=ARYCSARBIQVH4N564AKKJMLCQCNNI">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151416739.png?token=ARYCSARS5WJ7BORNAHKFOJLCQCNN4">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151416345.png?token=ARYCSAT3PEMWREPF6Y6UIPLCQCNO4">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151416733.png?token=ARYCSAXZAIA7GUOAB6GHIRDCQCNPY">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151416644.png?token=ARYCSASVT7UT7XUFLMIYFLLCQCNRC">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151417167.png?token=ARYCSARKZXKFELTQTTNKS2LCQCNSG">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151417006.png?token=ARYCSAWFZISPZYGSH4D2ZW3CQCNTA">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151417994.png?token=ARYCSASMGZRH33VA4OG27TLCQCNTW">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151417757.png?token=ARYCSAX53FFMS4HLAGAULR3CQCNU4">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151418011.png?token=ARYCSAWRARIHVOCZT6NHLH3CQCNVU">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151418466.png?token=ARYCSAQGUHHKT3TZXELJC7LCQCNWU">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151418540.png?token=ARYCSAXAP6TJ6NCOI5DFBPDCQCNXE">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151418753.png?token=ARYCSAWRFRIHBUCJJK33MJLCQCNXY">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151418648.png?token=ARYCSAX4VBWVPDPE5COHNI3CQCNY4">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151419908.png?token=ARYCSARE4QYFZKKQ3RJCOTLCQCN2A">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151420112.png?token=ARYCSARQSJHF2WMKPMIWLCTCQCN6E">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151420684.png?token=ARYCSAQ53KMGFJWE4NRDOKDCQCN6Y">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151420961.png?token=ARYCSAULGDFE5WKWJBQV4WTCQCN7I">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151420077.png?token=ARYCSAXS56IVNM2IIBLZWVDCQCOAC">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151421543.png?token=ARYCSATG3JJOAWTBCBKGDG3CQCOAY">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151421126.png?token=ARYCSAWNQND46BLECQTNASDCQCOBU">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151422239.png?token=ARYCSATAJWDNKTIBO7OTGSLCQCOFA">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151422226.png?token=ARYCSASRM7AGQUEACQZWSCDCQCOFS">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151422335.png?token=ARYCSAWMSBMNJRP2FG4WMY3CQCOGE">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151422218.png?token=ARYCSAXBVFDRGL4Q2FLNJC3CQCOG2">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151422011.png?token=ARYCSAS7ZWGY6RPEGOYEUMTCQCOHI">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151422876.png?token=ARYCSASCAA6THGM7VECBPZDCQCOH2">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151423023.png?token=ARYCSAUFEFGFKRZGMEMZQSTCQCOI6">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151423308.png?token=ARYCSASCGAE5V24SDVWYL7DCQCOJ6">
<meta property="og:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151423534.png?token=ARYCSATO5HTD633FH2FZWO3CQCOKS">
<meta property="article:published_time" content="2022-04-20T06:28:15.000Z">
<meta property="article:modified_time" content="2022-05-15T06:37:20.204Z">
<meta property="article:author" content="Syst1m">
<meta property="article:tag" content="HCIA">
<meta property="article:tag" content="大数据">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/chencicici/images/main/202205151412876.png?token=ARYCSARTUOKY4IGIGBRS7KTCQCM62">


<link rel="canonical" href="https://syst1m.top/2022/04/20/%E5%8D%8E%E4%B8%BAHCIA/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://syst1m.top/2022/04/20/%E5%8D%8E%E4%B8%BAHCIA/","path":"2022/04/20/华为HCIA/","title":"华为HCIA"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>华为HCIA | Syst1m</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Syst1m" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Syst1m</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0-amp-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">大数据概述&amp;解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%885v-1c%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">大数据的特征（5v+1c）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">大数据处理流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">大数据任务类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">大数据的计算类型（数据处理类型）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.4.</span> <span class="nav-text">大数据解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">HDFS分布式文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS-Hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.1.</span> <span class="nav-text">HDFS (Hadoop分布式文件系统)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS%E7%89%B9%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">HDFS特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.3.</span> <span class="nav-text">HDFS适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS%E4%B8%8D%E9%80%82%E5%90%88%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-number">2.4.</span> <span class="nav-text">HDFS不适合做什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%80%82%E5%90%88%E5%A4%A7%E9%87%8F%E5%B0%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8"><span class="nav-number">2.5.</span> <span class="nav-text">HDFS为什么不适合大量小文件存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">2.6.</span> <span class="nav-text">HDFS系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS%E5%8D%95NameNode%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.7.</span> <span class="nav-text">HDFS单NameNode的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS-HA%E7%89%B9%E6%80%A7-%E4%B8%BB%E5%A4%87%E9%85%8D%E7%BD%AE"><span class="nav-number">2.8.</span> <span class="nav-text">HDFS HA特性(主备配置)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS%E7%9A%84%E8%81%94%E9%82%A6%E6%9C%BA%E5%88%B6"><span class="nav-number">2.9.</span> <span class="nav-text">HDFS的联邦机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS%E5%85%83%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-%E4%B8%BB%E5%A4%87%E5%90%8C%E6%AD%A5"><span class="nav-number">2.10.</span> <span class="nav-text">HDFS元数据持久化(主备同步)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6-3%E4%BB%BD"><span class="nav-number">2.11.</span> <span class="nav-text">HDFS副本机制 (3份)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="nav-number">2.12.</span> <span class="nav-text">HDFS读取流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HDFS%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="nav-number">2.13.</span> <span class="nav-text">HDFS写入流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ZooKeeper"><span class="nav-number">3.</span> <span class="nav-text">ZooKeeper</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">3.1.</span> <span class="nav-text">ZooKeeper的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper%E9%9B%86%E7%BE%A4%E4%B8%BB%E4%BB%8E%E9%80%89%E4%B8%BE-x2F-%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2"><span class="nav-number">3.2.</span> <span class="nav-text">ZooKeeper集群主从选举&#x2F;主备切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper%E7%9A%84%E5%AE%B9%E7%81%BE%E8%83%BD%E5%8A%9B"><span class="nav-number">3.3.</span> <span class="nav-text">ZooKeeper的容灾能力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper%E7%9A%84%E8%AF%BB%E7%89%B9%E6%80%A7"><span class="nav-number">3.4.</span> <span class="nav-text">ZooKeeper的读特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper%E7%9A%84%E5%86%99%E7%89%B9%E6%80%A7"><span class="nav-number">3.5.</span> <span class="nav-text">ZooKeeper的写特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MapReduce"><span class="nav-number">4.</span> <span class="nav-text">MapReduce</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MapReduce%E7%9A%84%E7%89%B9%E6%80%A7-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="nav-number">4.1.</span> <span class="nav-text">MapReduce的特性:分布式计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MapReduce%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.2.</span> <span class="nav-text">MapReduce任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E9%98%B6%E6%AE%B5%E8%AF%A6%E6%83%85"><span class="nav-number">4.3.</span> <span class="nav-text">Map阶段详情</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E9%98%B6%E6%AE%B5%E8%AF%A6%E6%83%85-1"><span class="nav-number">4.4.</span> <span class="nav-text">Map阶段详情</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E6%A1%88%E4%BE%8B-%E5%8D%95%E8%AF%8D%E8%AE%A1%E6%95%B0WordCount"><span class="nav-number">4.5.</span> <span class="nav-text">词频统计案例(单词计数WordCount)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MapReduce%E7%BC%BA%E7%82%B9"><span class="nav-number">4.6.</span> <span class="nav-text">MapReduce缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MapReduce-V1%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.7.</span> <span class="nav-text">MapReduce V1资源调度出现的问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Yarn"><span class="nav-number">5.</span> <span class="nav-text">Yarn</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Yarn%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">Yarn的系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MapReduce-On-Yarn%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">MapReduce On Yarn任务处理流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HBase"><span class="nav-number">6.</span> <span class="nav-text">HBase</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HBase%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">6.1.</span> <span class="nav-text">HBase的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%88%97%E3%80%81%E9%9D%A2%E5%90%91%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">6.2.</span> <span class="nav-text">面向列、面向行数据库的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HBase%E5%92%8CRDB-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%AF%94%E8%BE%83"><span class="nav-number">6.3.</span> <span class="nav-text">HBase和RDB (关系型数据库)的区别比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HBase%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.4.</span> <span class="nav-text">HBase数据模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HBase%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">6.5.</span> <span class="nav-text">HBase的表结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HBase%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">6.6.</span> <span class="nav-text">HBase系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Region%E6%8B%86%E5%88%86"><span class="nav-number">6.7.</span> <span class="nav-text">Region拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Region%E5%AE%9A%E4%BD%8D"><span class="nav-number">6.8.</span> <span class="nav-text">Region定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HRegionServerBR"><span class="nav-number">6.9.</span> <span class="nav-text">HRegionServerBR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HLog%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">6.10.</span> <span class="nav-text">HLog的工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%88%B7%E5%86%99-%E6%8A%8AMemStore%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%88%B0StoreFile%E4%B8%AD"><span class="nav-number">6.11.</span> <span class="nav-text">缓存刷写(把MemStore数据写入到StoreFile中)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StoreFile%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number">6.12.</span> <span class="nav-text">StoreFile的合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HBase%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="nav-number">6.13.</span> <span class="nav-text">HBase读取流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HBase%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="nav-number">6.14.</span> <span class="nav-text">HBase写入流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BloomFilter-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">6.15.</span> <span class="nav-text">BloomFilter (布隆过滤器)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HBase-Shell%E5%91%BD%E4%BB%A4"><span class="nav-number">6.16.</span> <span class="nav-text">HBase Shell命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hive"><span class="nav-number">7.</span> <span class="nav-text">Hive</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Hadoop%E7%94%9F%E6%80%81%E5%9C%88"><span class="nav-number">7.1.</span> <span class="nav-text">Hadoop生态圈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hive%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.2.</span> <span class="nav-text">Hive数据模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hive%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%88%86%E5%B1%82-%E9%80%BB%E8%BE%91%E5%88%86%E5%B1%82"><span class="nav-number">7.3.</span> <span class="nav-text">Hive数据仓库分层(逻辑分层)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hive%E7%9A%84%E5%88%86%E5%B1%82%E5%A4%84%E7%90%86%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">7.4.</span> <span class="nav-text">Hive的分层处理的优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hive-SQL%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.5.</span> <span class="nav-text">Hive SQL的使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spark"><span class="nav-number">8.</span> <span class="nav-text">Spark</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spark%E7%89%B9%E7%82%B9"><span class="nav-number">8.1.</span> <span class="nav-text">Spark特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDD-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%9B%86%E3%80%81%E5%8F%AF%E5%88%86%E5%8C%BA%E7%9A%84"><span class="nav-number">8.2.</span> <span class="nav-text">RDD:分布式数据集、可分区的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.3.</span> <span class="nav-text">依赖类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stage%E5%88%92%E5%88%86"><span class="nav-number">8.4.</span> <span class="nav-text">Stage划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDD%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.5.</span> <span class="nav-text">RDD操作类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDD%E3%80%81DataFrame%E3%80%81-DataSet%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E8%81%94%E7%B3%BB"><span class="nav-number">8.6.</span> <span class="nav-text">RDD、DataFrame、 DataSet数据集的联系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spark%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="nav-number">8.7.</span> <span class="nav-text">Spark体系架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Streaming"><span class="nav-number">9.</span> <span class="nav-text">Streaming</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7-%E5%AE%9E%E6%97%B6%E5%93%8D%E5%BA%94%EF%BC%8C%E5%BB%B6%E8%BF%9F%E6%80%A7%E4%BD%8E"><span class="nav-number">9.1.</span> <span class="nav-text">关键特性:实时响应，延迟性低</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Streaming%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">9.2.</span> <span class="nav-text">Streaming系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Streaming%E4%BB%BB%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="nav-number">9.3.</span> <span class="nav-text">Streaming任务架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Streaming%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="nav-number">9.4.</span> <span class="nav-text">Streaming执行任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E4%BB%BB%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%89%A7%E8%A1%8C"><span class="nav-number">9.5.</span> <span class="nav-text">根据任务架构执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E8%AF%AD%E4%B9%89"><span class="nav-number">9.6.</span> <span class="nav-text">消息传递语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ack%E6%9C%BA%E5%88%B6-%E6%B6%88%E6%81%AF%E4%BC%A0%E8%BE%93%E6%9C%80%E5%B0%91%E4%B8%80%E6%AC%A1"><span class="nav-number">9.7.</span> <span class="nav-text">Ack机制(消息传输最少一次)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Flink"><span class="nav-number">10.</span> <span class="nav-text">Flink</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink-VS-Spark-Streaming"><span class="nav-number">10.1.</span> <span class="nav-text">Flink VS Spark Streaming</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="nav-number">10.2.</span> <span class="nav-text">Flink的关键特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">10.3.</span> <span class="nav-text">Flink系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E7%95%8C%E6%B5%81%E5%92%8C%E6%97%A0%E7%95%8C%E6%B5%81"><span class="nav-number">10.4.</span> <span class="nav-text">有界流和无界流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataStream-%E7%94%A8%E4%BA%8E%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%8C%E5%8F%AA%E8%83%BD%E6%89%A7%E8%A1%8C%E6%B5%81%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C"><span class="nav-number">10.5.</span> <span class="nav-text">DataStream:用于存储数据的数据集，只能执行流处理操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataSet-%E7%94%A8%E6%9D%A5%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%8C%E5%8F%AA%E8%83%BD%E6%89%A7%E8%A1%8C%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C"><span class="nav-number">10.6.</span> <span class="nav-text">DataSet:用来接收数据的数据集，只能执行批处理操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">10.7.</span> <span class="nav-text">Flink运行流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">10.8.</span> <span class="nav-text">Flink程序运行流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="nav-number">10.9.</span> <span class="nav-text">Flink运行程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink%E7%8A%B6%E6%80%81"><span class="nav-number">10.10.</span> <span class="nav-text">Flink状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fink%E7%AA%97%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.11.</span> <span class="nav-text">Fink窗口类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fink%E7%9A%84%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.12.</span> <span class="nav-text">Fink的时间类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Watermark-%E6%B0%B4%E4%BD%8D%E7%BA%BF-x2F-%E6%B0%B4%E5%8D%B0-%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%B9%B1%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="nav-number">10.13.</span> <span class="nav-text">Watermark(水位线&#x2F;水印): 解决数据乱序问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E5%BB%B6%E8%BF%9F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">10.14.</span> <span class="nav-text">对于延迟数据的处理方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink%E5%AE%B9%E9%94%99%E6%80%A7-CheckPoint%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.15.</span> <span class="nav-text">Flink容错性 (CheckPoint实现)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98"><span class="nav-number">10.16.</span> <span class="nav-text">状态保存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Flume"><span class="nav-number">11.</span> <span class="nav-text">Flume</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Flume%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="nav-number">11.1.</span> <span class="nav-text">Flume基础架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flume%E5%A4%9Aagent%E6%9E%B6%E6%9E%84"><span class="nav-number">11.2.</span> <span class="nav-text">Flume多agent架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flume%E5%A4%9AAgent%E5%90%88%E5%B9%B6"><span class="nav-number">11.3.</span> <span class="nav-text">Flume多Agent合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flume%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D"><span class="nav-number">11.4.</span> <span class="nav-text">Flume数据传输基本单位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flume-Agent%E5%8E%9F%E7%90%86"><span class="nav-number">11.5.</span> <span class="nav-text">Flume Agent原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flume-Source"><span class="nav-number">11.6.</span> <span class="nav-text">Flume Source</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flume-Channel"><span class="nav-number">11.7.</span> <span class="nav-text">Flume Channel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flume-Sink"><span class="nav-number">11.8.</span> <span class="nav-text">Flume Sink</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flume%E7%9A%84Source%E3%80%81Channel%E3%80%81-Sink%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">11.9.</span> <span class="nav-text">Flume的Source、Channel、 Sink之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flume%E7%BA%A7%E8%81%94%E8%8A%82%E7%82%B9"><span class="nav-number">11.10.</span> <span class="nav-text">Flume级联节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flume%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B"><span class="nav-number">11.11.</span> <span class="nav-text">Flume运行实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flume%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-number">11.12.</span> <span class="nav-text">Flume运行命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kafka"><span class="nav-number">12.</span> <span class="nav-text">Kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E8%BE%93%E5%BD%A2%E5%BC%8F"><span class="nav-number">12.1.</span> <span class="nav-text">消息传输形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">12.2.</span> <span class="nav-text">Kafka的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"><span class="nav-number">12.3.</span> <span class="nav-text">Kafka拓扑结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E9%9B%86%E7%BE%A4%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">12.4.</span> <span class="nav-text">Kafka集群系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E7%BB%84-consumer-group"><span class="nav-number">12.5.</span> <span class="nav-text">消费组:consumer group</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E7%9A%84%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="nav-number">12.6.</span> <span class="nav-text">Kafka的其他重要概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E5%88%86%E5%8C%BA%E5%89%AF%E6%9C%AC"><span class="nav-number">12.7.</span> <span class="nav-text">Kafka分区副本</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Loader"><span class="nav-number">13.</span> <span class="nav-text">Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Loader-1"><span class="nav-number">13.1.</span> <span class="nav-text">Loader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loader%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84"><span class="nav-number">13.2.</span> <span class="nav-text">Loader模型架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loader%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="nav-number">13.3.</span> <span class="nav-text">Loader任务执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loader%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AE"><span class="nav-number">13.4.</span> <span class="nav-text">Loader任务配置</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ElasticSearch"><span class="nav-number">14.</span> <span class="nav-text">ElasticSearch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch%E7%89%B9%E7%82%B9"><span class="nav-number">14.1.</span> <span class="nav-text">ElasticSearch特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">14.2.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">14.3.</span> <span class="nav-text">ElasticSearch系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">14.4.</span> <span class="nav-text">ElasticSearch中的核心概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8"><span class="nav-number">14.5.</span> <span class="nav-text">ElasticSearch命令使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-number">15.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">15.1.</span> <span class="nav-text">Redis应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">15.2.</span> <span class="nav-text">Redis系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B"><span class="nav-number">15.3.</span> <span class="nav-text">Redis读写流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="nav-number">15.4.</span> <span class="nav-text">Redis关键特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="nav-number">15.5.</span> <span class="nav-text">Redis数据类型及使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">15.6.</span> <span class="nav-text">Redis性能优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">15.7.</span> <span class="nav-text">Redis的优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81-amp-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86Kerberos-amp-Ldap"><span class="nav-number">16.</span> <span class="nav-text">安全认证&amp;权限管理Kerberos &amp; Ldap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">16.1.</span> <span class="nav-text">统一身份认证管理系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ldap%E7%9B%AE%E5%BD%95%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F"><span class="nav-number">16.2.</span> <span class="nav-text">Ldap目录服务系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LdapServer%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%A0%91%E7%8A%B6%E7%BB%93%E6%9E%84"><span class="nav-number">16.3.</span> <span class="nav-text">LdapServer系统结构(树状结构)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ldap%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="nav-number">16.4.</span> <span class="nav-text">Ldap功能模块设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ldap%E9%9B%86%E6%88%90%E8%AE%BE%E8%AE%A1"><span class="nav-number">16.5.</span> <span class="nav-text">Ldap集成设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kerberos%E8%AE%A4%E8%AF%81%E5%A4%84%E7%90%86"><span class="nav-number">16.6.</span> <span class="nav-text">Kerberos认证处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kerberos%E5%BA%94%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">16.7.</span> <span class="nav-text">Kerberos应用流程</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Syst1m"
      src="/images/IMG_0010.JPG">
  <!--
  <p class="site-author-name" itemprop="name">Syst1m</p>
  -->
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chencicici" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chencicici" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.uodrad.top/" title="https:&#x2F;&#x2F;www.uodrad.top&#x2F;" rel="noopener" target="_blank">uodrad</a>
        </li>
    </ul>
  </div>


       <!--网易云插件-->
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1933503036&auto=0&height=66">
      </iframe>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/chencicici" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syst1m.top/2022/04/20/%E5%8D%8E%E4%B8%BAHCIA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/IMG_0010.JPG">
      <meta itemprop="name" content="Syst1m">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Syst1m">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="华为HCIA | Syst1m">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          华为HCIA
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-20 14:28:15" itemprop="dateCreated datePublished" datetime="2022-04-20T14:28:15+08:00">2022-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-15 14:37:20" itemprop="dateModified" datetime="2022-05-15T14:37:20+08:00">2022-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="大数据概述-amp-解决办法"><a href="#大数据概述-amp-解决办法" class="headerlink" title="大数据概述&amp;解决办法"></a>大数据概述&amp;解决办法</h1><h2 id="大数据的特征（5v-1c）"><a href="#大数据的特征（5v-1c）" class="headerlink" title="大数据的特征（5v+1c）"></a>大数据的特征（5v+1c）</h2><ul>
<li>大量：数据量巨大，MB,GB,TB,PB</li>
<li>多样：数据类型多样，数据来源多样 数据来源：服务器日志、网站浏览信息、社交<br>结构化数据：表格数据 平台、摄像头信息<br>半结构化数据：网页html、xml<br>非结构化数据：视频、音频、图片、文字</li>
<li>高速：数据产生速度快、数据处理速度快</li>
<li>价值：价值密度低</li>
<li>准确：数据真实性</li>
<li>复杂：数据产生速度快、数据的类型多样等特征，导致做数据处理时处理过程变得很复杂</li>
</ul>
<h2 id="大数据处理流程"><a href="#大数据处理流程" class="headerlink" title="大数据处理流程"></a>大数据处理流程</h2><p>数据采集-&gt;数据预处理-&gt;数据存储-&gt;分析挖掘-&gt;数据可视化</p>
<h3 id="大数据任务类型"><a href="#大数据任务类型" class="headerlink" title="大数据任务类型"></a>大数据任务类型</h3><ul>
<li>IO密集型任务：大量输入输出请求的任务IO资源</li>
<li>计算密集型任务：有大量的计算要求，CPU资源</li>
<li>数据密集型任务：数据处理，并发数据处理</li>
</ul>
<h2 id="大数据的计算类型（数据处理类型）"><a href="#大数据的计算类型（数据处理类型）" class="headerlink" title="大数据的计算类型（数据处理类型）"></a>大数据的计算类型（数据处理类型）</h2><ul>
<li>批处理：一次处理一批量数据，处理的数据量大，但是延迟性高</li>
<li>流处理：一次处理一条数据，处理的数据量小，但是延迟性低</li>
<li>图处理：以图的形式展示数据，进行处理</li>
<li>查询分析计算：检索功能</li>
</ul>
<h2 id="大数据解决方案"><a href="#大数据解决方案" class="headerlink" title="大数据解决方案"></a>大数据解决方案</h2><p>Fusioninsight HD:部署在x86架构上<br>BigData pro:部署在ARM架构上<br>MapReduce Server（MRS）:部署华为云服务上</p>
<ul>
<li>高性能：支持自我研发的存储系统CarbonData</li>
<li>易运维：提供了可视化的管理界面</li>
<li>高安全：使用Kerborse &amp; Ldap实现认证管理和权限管理</li>
<li>低成本：按需购买，自定义配置底层架构性能</li>
</ul>
<h1 id="HDFS分布式文件系统"><a href="#HDFS分布式文件系统" class="headerlink" title="HDFS分布式文件系统"></a>HDFS分布式文件系统</h1><h2 id="HDFS-Hadoop分布式文件系统"><a href="#HDFS-Hadoop分布式文件系统" class="headerlink" title="HDFS (Hadoop分布式文件系统)"></a>HDFS (Hadoop分布式文件系统)</h2><ul>
<li>创建人:道格卡廷</li>
<li>起始原因:开发一个搜索引擎–&gt;存储问题(大量数据的存储)</li>
<li>google论文: GFS - google自身的分布式文件系统 <code>闭源</code></li>
</ul>
<h2 id="HDFS特性"><a href="#HDFS特性" class="headerlink" title="HDFS特性"></a>HDFS特性</h2><p>理论上HDFS存储可以无限扩展</p>
<ul>
<li>分布式:把多节点的存储系统结合为一一个整体对外提供服务(提高存储能力)</li>
<li>容错性:针对每个数据存储备份(默认3份)，备份存储分别存在不同的位置，如果备份或者数据有丢失，会再进行备份，保持一直都是3份</li>
<li>按块存储:块大小默认128M, 一个文件可以存储在多个块,<code>但是一个块只存储一个文件</code> <br><code>好处:数据丢失针对丢失的数据所属的块，只恢复当前块就可以</code></li>
<li>元数据:记录文件存储在哪些块,块存储在哪里等信息 <br>每个块都有一个元数据信息，并且元数据的大小是固定的150K</li>
</ul>
<h2 id="HDFS适用场景"><a href="#HDFS适用场景" class="headerlink" title="HDFS适用场景"></a>HDFS适用场景</h2><ul>
<li>可以做大文件</li>
<li>可以协助离线处理或批处理</li>
<li>流式数据访问机制</li>
</ul>
<h2 id="HDFS不适合做什么"><a href="#HDFS不适合做什么" class="headerlink" title="HDFS不适合做什么"></a>HDFS不适合做什么</h2><ul>
<li>不适合大量小文件存储</li>
<li>不适合做实时场景</li>
<li>不适合随机读写，可以做追加写</li>
</ul>
<h2 id="HDFS为什么不适合大量小文件存储"><a href="#HDFS为什么不适合大量小文件存储" class="headerlink" title="HDFS为什么不适合大量小文件存储"></a><code>HDFS为什么不适合大量小文件存储</code></h2><pre><code>(例: 10个文件，每个文件大小为20M)
</code></pre>
<ol>
<li>10个文件需要使用10个块，并且每个块只是用了20M空间—&gt; 存储空间浪费</li>
<li>有10个元数据，元数据150K</li>
<li>寻址时间增长</li>
</ol>
<p>不适合随机读写，可以做追加写</p>
<h2 id="HDFS系统架构"><a href="#HDFS系统架构" class="headerlink" title="HDFS系统架构"></a>HDFS系统架构</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151412876.png?token=ARYCSARTUOKY4IGIGBRS7KTCQCM62"></p>
<ul>
<li>Client (客户端) :用户接口，用户通过Client连接到组件</li>
<li>NameNode (名称节点，主节点) :管理DataNode,并且接收用户请求,分发任务，存储元数据信息</li>
<li>DataNode (数据节点，从节点) :实际处理用户请求，维护自己的Block和实际存储位置映射关系</li>
<li>Block (块) : 数据存储</li>
</ul>
<h2 id="HDFS单NameNode的问题"><a href="#HDFS单NameNode的问题" class="headerlink" title="HDFS单NameNode的问题"></a>HDFS单NameNode的问题</h2><ul>
<li>单名称节点故障:整个集群都无法使用—&gt;HA(主备配置)</li>
<li>单名称节点性能瓶颈问题:并发处理的任务量有限—-&gt;联邦机制</li>
</ul>
<h2 id="HDFS-HA特性-主备配置"><a href="#HDFS-HA特性-主备配置" class="headerlink" title="HDFS HA特性(主备配置)"></a>HDFS HA特性(主备配置)</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151412014.png?token=ARYCSAW7AVKCAPDCYNNV5YLCQCM74"></p>
<ul>
<li>active节点:对外提供服务</li>
<li>standby节点:不断备份active节点的数据，<code>当active宕机,standby会成为新的active</code></li>
<li>zookeeper监测主节点的状态，一旦发现故障，zookeeper就通知备用节点成为新的主节点</li>
</ul>
<h2 id="HDFS的联邦机制"><a href="#HDFS的联邦机制" class="headerlink" title="HDFS的联邦机制"></a>HDFS的联邦机制</h2><pre><code>各个NN之间是相互隔离的，维护自己的命名空间
</code></pre>
<p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151412309.png?token=ARYCSAUWS6RZPANWYMQDOCLCQCNAU"></p>
<h2 id="HDFS元数据持久化-主备同步"><a href="#HDFS元数据持久化-主备同步" class="headerlink" title="HDFS元数据持久化(主备同步)"></a>HDFS元数据持久化(主备同步)</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151412204.png?token=ARYCSAVN7VZ2UZ6V7RVJRITCQCNBS"></p>
<ol>
<li>备节点会通知主节点新建一个Editlog.new文件， 从这之后的操作都记录在.new文件中</li>
<li>备节点从主节点拷贝Editlog、Fsimage文件(只有第一 次需要 下载Fsimage,后续同步使用本地的)</li>
<li>将两个文件进行合并，生成Fsimage.ckpt文件</li>
<li>备节点将Fsimage.ckpt上传到主节点上</li>
<li>主节点接收到Fsimage.ckpt恢复成Fsimage</li>
<li>把Editlog.new重命名Editlog</li>
</ol>
<h2 id="HDFS副本机制-3份"><a href="#HDFS副本机制-3份" class="headerlink" title="HDFS副本机制 (3份)"></a>HDFS副本机制 (3份)</h2><ul>
<li>存储副本规则:</li>
</ul>
<ol>
<li>第一份副本存放在同一节点中(传输最快,但是如果节点故障，副本也会丢失)</li>
<li>第二份副本存放在同一机架的不同节点上(如果整个机架故障，副本也会丢失)</li>
<li>第三分副本存放在不同机架的其他节点上</li>
</ol>
<ul>
<li>副本距离公式:<code>优先选择的是距离小的</code></li>
</ul>
<ol>
<li>同节点的距离为0</li>
<li>同一机架不同节点的距离为2</li>
<li>不同机架的节点距离为4</li>
</ol>
<h2 id="HDFS读取流程"><a href="#HDFS读取流程" class="headerlink" title="HDFS读取流程"></a>HDFS读取流程</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151413392.png?token=ARYCSAQS3MNXYXLIKXZRAT3CQCNFE"></p>
<ol>
<li>Client向NameNode发起读取请求</li>
<li>NameNode接收到请求，反馈对应的元数据信息给Client</li>
<li>Client接收到反馈请求对应的DataNode <code>(如果Client本地有数据，优先从本地读取)</code></li>
<li>DataNode接收到请求，反馈数据内容给Client</li>
<li>关闭读取流</li>
</ol>
<h2 id="HDFS写入流程"><a href="#HDFS写入流程" class="headerlink" title="HDFS写入流程"></a>HDFS写入流程</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151413093.png?token=ARYCSASXKVI2WMTKAJWTIR3CQCNF2"></p>
<ol>
<li>Client向NameNode发出写入请求</li>
<li>NameNode接收到请求后生成该文件的元数据信息，反馈DataNode信息给Client</li>
<li>Client接收到DataNode信息之后，请求相对应的DataNode</li>
<li>Client提交文件写入到对应的DataNode</li>
<li>DataNode接收到写入请求，执行写入</li>
<li>Client写入第一-个节点后，由第一个节点写入第二个节点，第二个节点写入第三个节点</li>
<li>写入完成后反馈元数据信息给Client</li>
<li>关闭读取流，NameNode更新元数据信息</li>
</ol>
<h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><pre><code>分布式服务应用，可以帮助其他分布式组件协调管理集群
</code></pre>
<h2 id="ZooKeeper的特性"><a href="#ZooKeeper的特性" class="headerlink" title="ZooKeeper的特性"></a>ZooKeeper的特性</h2><ul>
<li>分布式服务, ZooKeeper集群中有一半以上的节点存活集群才能正常运行</li>
<li>最终一致性:所有的节点对外提供的是同一个视图</li>
<li>实时性:实时获取、实时反馈应用状态</li>
<li>可靠性: 一条数据被-个节点接收到，就会被其他节点也接收</li>
<li>等待无关性:慢的或者失效的client请求，不会影响到其他客户端请求</li>
<li>原子性:最终状态只有成功或者失败</li>
</ul>
<h2 id="ZooKeeper集群主从选举-x2F-主备切换"><a href="#ZooKeeper集群主从选举-x2F-主备切换" class="headerlink" title="ZooKeeper集群主从选举&#x2F;主备切换"></a>ZooKeeper集群主从选举&#x2F;主备切换</h2><ul>
<li>选举: zookeeper内部投票选举,当节点得到一半以上的票数,它就会称为Leader,其他的节点都是Follower</li>
<li>主备切换:当leader出现故障,从其他的follower中重新选举新的leader</li>
</ul>
<h2 id="ZooKeeper的容灾能力"><a href="#ZooKeeper的容灾能力" class="headerlink" title="ZooKeeper的容灾能力"></a>ZooKeeper的容灾能力</h2><pre><code>(可容灾集群最低要求是3个节点)
</code></pre>
<ul>
<li>在集群运行过程中允许发生故障的节点数(最大:节点数-半-1)</li>
<li>如:集群只要1个节点，容灾能力为0<br>  集群只要2个节点，容灾能力为0<br>  集群只要3个节点，容灾能力为1<br>  集群只要4个节点，容灾能力为1</li>
<li>搭建集群时，尽量选择奇数台节点进行搭建</li>
</ul>
<h2 id="ZooKeeper的读特性"><a href="#ZooKeeper的读特性" class="headerlink" title="ZooKeeper的读特性"></a>ZooKeeper的读特性</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151414245.png?token=ARYCSAUWFL3VQLC74QPFOFTCQCNHA"></p>
<ol>
<li>Client发起读取请求</li>
<li>获取到数据(不管接收请求的是Leader节点还是Follower节点)</li>
</ol>
<h2 id="ZooKeeper的写特性"><a href="#ZooKeeper的写特性" class="headerlink" title="ZooKeeper的写特性"></a>ZooKeeper的写特性</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151414157.png?token=ARYCSAXYXQNR64JHII24XQDCQCNII"></p>
<ol>
<li>Client发起写入请求 如果请求到的节点不是leader节点，follower会把请求转发给leader</li>
<li>leader接收到请求后会向所有节点发出询问是否可以接收写入</li>
<li>节点接收到询问请求,根据自身情况反馈是否可写入的信息给leader</li>
<li>leader接收到一半以上的节点可以写入，再执行写入</li>
<li>写入完成后反馈给client,如果Client请求的不是leader, leader把写 入状态反馈给follower,由follower反馈给client</li>
</ol>
<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><pre><code>数据处理(数据计算)
创建者:道格卡廷
出发点:搜索引擎--&gt;处理问题google: mapreduce论文MapReduce的特性:分布式计算
</code></pre>
<h2 id="MapReduce的特性-分布式计算"><a href="#MapReduce的特性-分布式计算" class="headerlink" title="MapReduce的特性:分布式计算"></a>MapReduce的特性:分布式计算</h2><ul>
<li>高度抽象的编程思想:编程人员只需要描述做什么，具体怎么做交由处理框架执行的</li>
<li>可扩展性:分布式、搭建在集群上的一-个处理组件</li>
<li>高容错性:处理任务时节点故障，迁移到其他节点执行任务MapReduce任务主要分为两大部分: map任务、 reduce任务</li>
</ul>
<h2 id="MapReduce任务"><a href="#MapReduce任务" class="headerlink" title="MapReduce任务"></a>MapReduce任务</h2><ul>
<li>reduce任务的处理数据来源是map任务的输出</li>
<li>map阶段:针对每个数据执行一个操作, 提取数据特征</li>
<li>reduce阶段:获取到多个map的输出，统一计 算处理,针对key统计汇总这个key对应的value</li>
</ul>
<h2 id="Map阶段详情"><a href="#Map阶段详情" class="headerlink" title="Map阶段详情"></a>Map阶段详情</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151414971.png?token=ARYCSATLAWLW5KMTUFKFGMLCQCNJA"></p>
<ol>
<li>数据从数据源获取后进行分片切分、执行map操作</li>
<li>分片会被存储在环形内存缓冲区( 当缓冲区达到80%会发生溢写)</li>
<li>把分片溢写到磁盘中，生成MOF文件</li>
<li>溢写过程中对数据执行</li>
</ol>
<h2 id="Map阶段详情-1"><a href="#Map阶段详情-1" class="headerlink" title="Map阶段详情"></a>Map阶段详情</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151414178.png?token=ARYCSAQANK6MV3W4IXLU2I3CQCNJY"></p>
<ol>
<li>把数据(MOF)从磁盘中加载到内存中</li>
<li>当数据量过大会执行归并，如果不多，直接跳过归并执行归约操作</li>
<li>执行完reduce操作之后，最终结果写入到HDFS</li>
</ol>
<h2 id="词频统计案例-单词计数WordCount"><a href="#词频统计案例-单词计数WordCount" class="headerlink" title="词频统计案例(单词计数WordCount)"></a>词频统计案例(单词计数WordCount)</h2><ol>
<li>数据源(很多英文句子或短语的一个文件)</li>
<li>提取出每个单词,统计单词出现的次数<br><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151415672.png?token=ARYCSAXFO4SAXDL2SDP6U2DCQCNMS"></li>
</ol>
<h2 id="MapReduce缺点"><a href="#MapReduce缺点" class="headerlink" title="MapReduce缺点"></a>MapReduce缺点</h2><ul>
<li>处理延迟性高</li>
<li>使用java语言编程map处理reduce处理</li>
<li>MapReduce处理任务需要使用资源</li>
</ul>
<h2 id="MapReduce-V1资源调度出现的问题"><a href="#MapReduce-V1资源调度出现的问题" class="headerlink" title="MapReduce V1资源调度出现的问题"></a>MapReduce V1资源调度出现的问题</h2><ul>
<li>如果发生问题，通知用户介入解决</li>
<li>没有区分任务调度和资源调度，都是MR的主节点在处理，主节点的整体工作压力非常大</li>
<li>因为资源没有单独隔离,容易出现资源抢占的问题</li>
</ul>
<h1 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h1><pre><code>资源调度管理服务---&gt; 可以协助其他组件应用协调管理资源，以及任务调度
</code></pre>
<h2 id="Yarn的系统架构"><a href="#Yarn的系统架构" class="headerlink" title="Yarn的系统架构"></a>Yarn的系统架构</h2><pre><code>在集群层面来说只有一个ResourceManager, 多个NodeManager
以程序执行层面来说，一个应用只有一-个AppMaster,多个Container
</code></pre>
<p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151415737.png?token=ARYCSARBIQVH4N564AKKJMLCQCNNI"></p>
<ul>
<li>Client:客户端</li>
<li>ResourceManager (主节点) :负责资源管理,任务调度</li>
<li>NodeManager (从节点) :负责提供资源，实际任务执行</li>
<li>ApplicationMaster:特殊的Container, 管理同一应用的其他Container,以及实时关注任务执行状态,反馈给RM</li>
<li>Container:<code>资源的抽象</code>，被封装起来的资源，一个Container执行一个任务, 其他任务不能使用这个Container的资源</li>
</ul>
<h2 id="MapReduce-On-Yarn任务处理流程"><a href="#MapReduce-On-Yarn任务处理流程" class="headerlink" title="MapReduce On Yarn任务处理流程"></a><code>MapReduce On Yarn任务处理流程</code></h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151416739.png?token=ARYCSARS5WJ7BORNAHKFOJLCQCNN4"></p>
<ol>
<li>Client向RM发起请求</li>
<li>RM(ApplicationManager)接收到请求后在NM中启动一-个AppMaster</li>
<li>AppMaster接收任务，根据任务向RM (ResourceScheduler) 申请资源</li>
<li>在NM中封装资源Container提供给AppMaster执行应用</li>
<li>执行过程中Container会实时反馈执行状态给AppMaster</li>
<li>AppMaster会反馈任务执行状态和自身状态给RM (ApplicationManager)</li>
<li>AppMaster将运行结果反馈给RM,然后向RM (ResourceScheduler) 申请释放资源</li>
<li>RM将任务情况反馈给Client</li>
</ol>
<p>Yarn搭建时支持主备配置，实现主备ResourceManager<br>AppMaster的容错(当-个AppMaster出现故障,任务管理会被迁移到新的AppMaster)</p>
<p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151416345.png?token=ARYCSAT3PEMWREPF6Y6UIPLCQCNO4"></p>
<h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><pre><code>HBase分布式列式NoSQL数据库，底层存储使用的是HDFS ,`没有数据类型，所有数据存储都是字节数组的形式byte[]`
创建者:道格卡廷
出发点:搜索引擎--&gt;提高数据读写速度--&gt; BigTable
</code></pre>
<h2 id="HBase的特性"><a href="#HBase的特性" class="headerlink" title="HBase的特性"></a>HBase的特性</h2><ul>
<li>可扩展性:可以通过添加节点的方式增加数据存储空间</li>
<li>高可靠性:底层使用HDFS,能够保证数据的可靠性，预写式日志保证内存中的数据不丢失</li>
<li>高性能:处理PB级别的数据</li>
<li>面向列: HBase数据存储是面向列的</li>
<li>可伸缩性:动态添加列(在添加数据的时候)-</li>
</ul>
<h2 id="面向列、面向行数据库的优缺点"><a href="#面向列、面向行数据库的优缺点" class="headerlink" title="面向列、面向行数据库的优缺点"></a>面向列、面向行数据库的优缺点</h2><ul>
<li>面向行:<br>  优点:能方便快捷的获取一一行记录<br>  缺点:在想要单独获取指定列数据的时候，会检索到其他无关列</li>
<li>面向列:<br>  优点:在检索单列数据时，不会出现无关列<br>  缺点:想要查询一条记录时，需要多次IO请求才能拼出一条记录</li>
</ul>
<h2 id="HBase和RDB-关系型数据库-的区别比较"><a href="#HBase和RDB-关系型数据库-的区别比较" class="headerlink" title="HBase和RDB (关系型数据库)的区别比较"></a>HBase和RDB (关系型数据库)的区别比较</h2><ul>
<li>数据索引: <br>HBase只有一 种索引(rowkey)，RDB中可以配置多个索引</li>
<li>数据维护: <br>HBase允许数据增删查,<code>不支持修改</code>，RDB中允许数据增删查改<br>HBase可以使用覆盖的方式写入数据以此实现数据修改的功能<br>可伸缩性: HBase可以在添加数据时动态添加列，RDB只能通过修改表的方式添加列<br>RDB (MySQL) 数据模型:数据库、表、行、列(字段)，单元格</li>
</ul>
<h2 id="HBase数据模型"><a href="#HBase数据模型" class="headerlink" title="HBase数据模型"></a>HBase数据模型</h2><pre><code>命名空间、表、行、列(组成列族)、单元格(可以存储多条记录)
</code></pre>
<ul>
<li>命名空间: hbase、 default. 自定义(在使用自定义的命名空间时都需要指定命名空间名称)</li>
<li>表:由行和列组成</li>
<li>行:有一个唯一表示行键(rowkey)</li>
<li>列:归属于某一个列族(<code>动态添加</code>)</li>
<li>列族:由一个或多个列组成(创建表时创建的，不能动态更改)</li>
<li>单元格:由行和列能确定-一个单元格，<code>一个单元格中可能存在多条记录(多版本记录，使用时间戳进行区分)</code></li>
</ul>
<h2 id="HBase的表结构"><a href="#HBase的表结构" class="headerlink" title="HBase的表结构"></a>HBase的表结构</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151416733.png?token=ARYCSAXZAIA7GUOAB6GHIRDCQCNPY"></p>
<pre><code>要找到行列对应的单元格值时，表行键,列族:列
默认情况下，只返回单元格中的最新记录，如果要返回多版本需要指定参数VERSIONS=&gt;3
</code></pre>
<h2 id="HBase系统架构"><a href="#HBase系统架构" class="headerlink" title="HBase系统架构"></a>HBase系统架构</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151416644.png?token=ARYCSASVT7UT7XUFLMIYFLLCQCNRC"></p>
<ul>
<li>Client:用户可以通过Client连接到HBase,基本不与HMaster交互</li>
<li>ZooKeeper:监测HMaster的主备运行状态及主备切换，监测HRegionServer的状态，反馈给HMaster,<code>存储HBase元数据信息hbase:meta</code></li>
<li>Hmaster() ：管理维护HRegionServer列表，管理分配Region, Region负载均衡</li>
<li>HRegionServer：管理分配给它的Region，处理用户的读写请求</li>
<li>DFS Client: HBase连接到HDFS的接口</li>
</ul>
<p>一个HRegionserver中包含一个HLog， 多个HRegion</p>
<ul>
<li><p>HLog:预写式日志WAL,记录数据操作(数据写入之前必须先写入HLog)</p>
</li>
<li><p>Region:<code>分布式存储的最基本单位，刚开始一个Region存储一个表的内容随着数据增多</code>，Region会不断分裂<br>Store:一个Region中包含多个Store,<code>一个Store存储一个列族数据</code><br>MemStore (写缓存):一个Store包含一个MemStore <br>StoreFile (磁盘文件):一个Store中包含多个StoreFile<br>HFile (HDFS文件): 一个StoreFile添加头部信息转换成HFile,最终存储在HDFS中</p>
</li>
<li><p>数据写入关键流程:先写入HLog,然后才能写入MemStore,当MemStore达到溢出要求(128M) ,将数据刷写StoreFile中</p>
</li>
<li><p>数据读取关键流程:先读取MemStore,如果没有,再读取BlockCache (读缓存)，如果还是没有最终才读取StoreFile<br>BlockCache存储之前的用户查询过的数据，当MemStore和BlockCache中都没有数据， 需要从StoreFile<br>中读取数据时，读取完的数据会被加载到BlockCache中</p>
</li>
</ul>
<h2 id="Region拆分"><a href="#Region拆分" class="headerlink" title="Region拆分"></a>Region拆分</h2><ul>
<li>拆分原因:数据不断增加，region不断增大， region过大会影响数据读写速度</li>
<li>拆分条件:根据行键拆分，尽可能将同一个行键或相似的行键放在一个Region中</li>
</ul>
<p>-region拆分过程很快，接近瞬间,在拆分时实际还是请求的原文件,拆分结束之后会将原文件内容异步写入新文件,然后之后的请求被转移到新文件</p>
<h2 id="Region定位"><a href="#Region定位" class="headerlink" title="Region定位"></a>Region定位</h2><p>  元数据信息存储在hbase:meta中,这个表信息被存储在zookeeper内存中通过元数据信息获取Region实际存储位置</p>
<h2 id="HRegionServerBR"><a href="#HRegionServerBR" class="headerlink" title="HRegionServerBR"></a>HRegionServerBR</h2><p>H RegionServer出现故障时</p>
<ol>
<li>zookeeper发现RegionServer故障，同时HMaster</li>
<li>HMaster获取故障的RegionServer上的HLog信息，根据与Region的对应关系对HLog进行拆分</li>
<li>把HLog存放在Region目录下，把Region重新迁移至其他的RegionServer上</li>
<li>其他的RegionServer接收到Region执行重新执行HLog内容</li>
</ol>
<h2 id="HLog的工作原理"><a href="#HLog的工作原理" class="headerlink" title="HLog的工作原理"></a>HLog的工作原理</h2><ul>
<li>HLog: WAL预写式日志，数据更新的操作都要先写入HLog中，才能写入MemStore<br><code>当MemStore被刷写到磁盘后，会向HLog中写入一条标记记录 (标记记录之前的所有数据都已经刷写到磁盘)</code></li>
<li>系统启动时，系统任务先扫描HLog, 检测是否有数据没有写入到磁盘中,如果有先执行写入MemStore,然后再刷写到磁盘，清空缓存,最后再为用户提供服务 <br>如果数据丢失，可以根据HLog重新执行恢复</li>
<li>一个RegionServer只有一-个HLog (共用一个HLog)<br>  优点:写入日志时不需要查找对应的Log,直接全部写入一个HLog<br>  缺点:如果RegionServer出现故障， 需要对HLog进行拆分</li>
</ul>
<h2 id="缓存刷写-把MemStore数据写入到StoreFile中"><a href="#缓存刷写-把MemStore数据写入到StoreFile中" class="headerlink" title="缓存刷写(把MemStore数据写入到StoreFile中)"></a>缓存刷写(把MemStore数据写入到StoreFile中)</h2><ul>
<li>当MemStore达到刷写条件，就会将内容刷写到StoreFile文件中</li>
<li>缓存的刷写是针对整个Region的，当一个MemStore达到刷写要求， 当前的Region下面的所有MemStore都会触发刷写</li>
<li>每次刷写都会生成一个新的StoreFile文件(每次的刷写内容都分别在一个新文件中)</li>
<li>刷写完成之后会在HLog中写入标记记录,并且清空缓存</li>
</ul>
<h2 id="StoreFile的合并"><a href="#StoreFile的合并" class="headerlink" title="StoreFile的合并"></a>StoreFile的合并</h2><pre><code>(刷写操作会出现大量的StoreFile,且部分StoreFile文件大小过小) 合并比较消耗资源,达到一定阈值才会执行
将多个的StoreFile小文件合并成一个大文件,如果StoreFile文件过大，再进行拆分(根据HDFS块进行拆分)
</code></pre>
<p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151417167.png?token=ARYCSARKZXKFELTQTTNKS2LCQCNSG"></p>
<p>合并文件会进行筛选:如果本身的StoreFile就已经达到1 00M左右,这个StoreFile是不参与合并的</p>
<h2 id="HBase读取流程"><a href="#HBase读取流程" class="headerlink" title="HBase读取流程"></a>HBase读取流程</h2><ol>
<li>Client请求zookeeper获取hbase:meta表元数据信息，获取RegionServer信息</li>
<li>Client请求相对应的RegionServer</li>
<li>RegionServer接收到请求反馈数据给Client</li>
<li>关闭读取流</li>
</ol>
<h2 id="HBase写入流程"><a href="#HBase写入流程" class="headerlink" title="HBase写入流程"></a>HBase写入流程</h2><ol>
<li>Client请求的zookeeper,获取hbase:meta表信息,根据写入的行键获取对应的RegionServer信息</li>
<li>Client请求RegionServer发起写入请求</li>
<li>RegionServer接收到请求后将数据写入到行键对应的Region中.</li>
<li>RegionServer反馈写入状态给Client</li>
<li>关闭写入流</li>
</ol>
<h2 id="BloomFilter-布隆过滤器"><a href="#BloomFilter-布隆过滤器" class="headerlink" title="BloomFilter (布隆过滤器)"></a>BloomFilter (布隆过滤器)</h2><pre><code>判断数据是否存在，如果反馈结果为不存在，是可信的，如果反馈结果为存在，可能有误差
</code></pre>
<p>缩小数据违取范围<br><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151417006.png?token=ARYCSAWFZISPZYGSH4D2ZW3CQCNTA"></p>
<p>在HBase中行键是以字典序进行排序<br><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151417994.png?token=ARYCSASMGZRH33VA4OG27TLCQCNTW"></p>
<h2 id="HBase-Shell命令"><a href="#HBase-Shell命令" class="headerlink" title="HBase Shell命令"></a>HBase Shell命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">namespace:</span><br><span class="line">    create_namespace <span class="string">&#x27;名称&#x27;</span></span><br><span class="line">    list_namespace</span><br><span class="line">    list_namespace_ tables <span class="string">&#x27;ns1&#x27;</span></span><br><span class="line">    alter_namespace <span class="string">&#x27;ns1 ,&#123;属性名称=&gt; &#x27;</span>属性值&#125;</span><br><span class="line">    drop_ namespace <span class="string">&#x27;ns1&#x27;</span> <span class="comment">---命名空间需要是空的</span></span><br><span class="line"></span><br><span class="line">ddl:数据定义语言<span class="comment">---&gt; 表层面的操作</span></span><br><span class="line">    <span class="keyword">create</span> <span class="string">&#x27;表名&#x27;</span>,列族名<span class="number">1</span><span class="string">&#x27;;列族2&#x27;</span></span><br><span class="line">    <span class="keyword">create</span> <span class="string">&#x27;表名,&#123;NAME= &gt; &#x27;</span>列族<span class="string">&#x27; VERSIONS= &gt; 5&#125;,&#123;NAME= &gt;列族&#x27;</span> ,VERSIONS<span class="operator">=</span> <span class="operator">&gt;</span><span class="number">5</span>&#125;</span><br><span class="line">    修改列族属性信息、添加列族: <span class="keyword">alter</span> <span class="string">&#x27;表名&#x27;</span>,&#123;NAME<span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;列族&#x27;</span> ,VERSIONS<span class="operator">=</span><span class="operator">&gt;</span><span class="number">5</span>&#125;<span class="comment">--&gt;如果列族存在做修改，不存在做添加</span></span><br><span class="line">    使用list可以查看所有的表:包含<span class="keyword">default</span>命名空间和自定义命名空间中的表</span><br><span class="line">    查看表信息: <span class="keyword">describe</span> <span class="string">&#x27;表名&#x27;</span></span><br><span class="line">    删除表: <span class="keyword">drop</span> <span class="string">&#x27;表名’--&gt; 禁用状态的表才 能进行删除</span></span><br><span class="line"><span class="string">    禁用表: disable 表名&#x27;</span> <span class="operator">/</span>启用表: enable <span class="string">&#x27;表名&#x27;</span></span><br><span class="line">    </span><br><span class="line">dml:数据管理语言<span class="comment">--&gt; 针对数据层面的操作</span></span><br><span class="line">    添加数据: put <span class="string">&#x27;表名，’行键&quot;,列族:列&quot;,值’--&gt; 默认使用的是系统时间戳</span></span><br><span class="line"><span class="string">    删除数据: delete &#x27;</span>表名&quot;;行键’</span><br><span class="line">    delete表名&#x27;,行键&quot;，列族:列<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    delete表名&#x27;</span>;行键&quot;,列族列,&#123;TIMESTEMP= &gt;&#x27;235652&#x27;&#125;</span><br><span class="line">    清空表: truncate &#x27;表名&#x27;</span><br><span class="line">    数据获取: get &#x27;表名&#x27;;行键’</span><br><span class="line">    get &#x27;表名&#x27;行键&quot;;列族列</span><br><span class="line">    <span class="keyword">get</span> <span class="string">&#x27;表名&#x27;</span>，<span class="string">&#x27;行键&quot;;列族列,&#123;VERSIONS=&gt;3&#125;</span></span><br><span class="line"><span class="string">    数据扫描: scan &#x27;</span>表名<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    scan &#x27;</span>表名&quot;&#x27;;行键&#x27;;列族列,VERSIONS= &gt;3&#125;</span><br><span class="line"></span><br><span class="line">snapshot:快照操作--&gt; 针对表创建快照，记录当前指定表的数据信息</span><br><span class="line">    创建快照: snapshot &#x27;表名&quot;，<span class="string">&#x27;快照名称&#x27;</span></span><br><span class="line">    还原快照: resotre_ snapshot <span class="string">&#x27;快照名&#x27;</span></span><br><span class="line">    克隆快照: clone_ snapshot ‘快照名;新表名<span class="string">&#x27; ---&gt;把快照中的表内容还原到一-张新表上</span></span><br><span class="line"><span class="string">    删除快照: delete snapshot &#x27;</span>快照名<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>


<h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><pre><code>数据仓库，查询分析
</code></pre>
<h2 id="Hadoop生态圈"><a href="#Hadoop生态圈" class="headerlink" title="Hadoop生态圈"></a>Hadoop生态圈</h2><ul>
<li>HDFS存储、 HBase存储提供实时读写功能</li>
<li>MapReduce并行计算、Yarn资源管理和任务调度</li>
<li>ZooKeeper协助分布式应用管理服务</li>
<li>Hive底层使用的是MapReduce做计算，MapReduce的使用对编程人员要求比较高</li>
<li>可以执行SQL类的查询分析计算</li>
</ul>
<h2 id="Hive数据模型"><a href="#Hive数据模型" class="headerlink" title="Hive数据模型"></a>Hive数据模型</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151417757.png?token=ARYCSAX53FFMS4HLAGAULR3CQCNU4"></p>
<ul>
<li><p>分区:根据字段值进行划分(指定分区字段,分区字段值相同的记录就存放在一一个分区中)<br>分区在物理上是一个文件夹<br>分区下还可以再有分区和桶<br>在创建表的时候可以指定分区字段<br>分区数量是不固定的</p>
</li>
<li><p>桶:根据值的哈希值进行求余放到对应的桶中<br>桶在物理.上是一-个文件<br>在创建表的时候可以指定有几个桶</p>
</li>
<li><p>表类型:托管表(内部表)、外部表、临时表<br>托管表(internal) :元数据和数据信息都是Hive在管理<br><code>删除时，元数据和数据都会被删除\</code><br>外部表(external) :元数据由Hive管理,但是数据可以提供给其他组件共享<br><code>删除时，只删除元数据，数据信息依旧保留\</code><br>临时表(temporary) :只在当前会话中生效，当会话结束表就会被自动删除</p>
</li>
</ul>
<h2 id="Hive数据仓库分层-逻辑分层"><a href="#Hive数据仓库分层-逻辑分层" class="headerlink" title="Hive数据仓库分层(逻辑分层)"></a>Hive数据仓库分层<code>(逻辑分层)</code></h2><ul>
<li>ODS (原数据层，操作数据层) :从数据源获取到的数据</li>
<li>DWD (数据明细层) :根据ODS做数据清洗得到的结果</li>
<li>DWS (数据服务层) :根据DWD进行汇总分析计算</li>
<li>ADS (应用服务层) :根据上层应用的业务需求将DWS数据再一次处理分析得到业务 需要的数据</li>
</ul>
<h2 id="Hive的分层处理的优势"><a href="#Hive的分层处理的优势" class="headerlink" title="Hive的分层处理的优势"></a>Hive的分层处理的优势</h2><ul>
<li>复杂问题简单化:将复杂问题分成多个流程，每个层面执行一-一个流程内容</li>
<li>减少重复开发:不要每次提供给上次应用数据时都要对数据进行清洗汇总操作</li>
<li>隔离原始数据:减少到原数据的依赖，避免因为原数据的原因，导致后续操作无法执行</li>
</ul>
<h2 id="Hive-SQL的使用"><a href="#Hive-SQL的使用" class="headerlink" title="Hive SQL的使用"></a>Hive SQL的使用</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">DDL:数据定义语言</span><br><span class="line">    创建表: <span class="keyword">create</span> <span class="keyword">table</span> <span class="string">&#x27;表名(字段类型,字段2类类型... .);</span></span><br><span class="line"><span class="string">    create external table表名&#x27;</span>(字段类型,字段<span class="number">2</span>类型....</span><br><span class="line">    <span class="keyword">create</span> temporary <span class="keyword">table</span> <span class="string">&#x27;表名&#x27;</span>(字段类型,字段<span class="number">2</span>类型... .</span><br><span class="line">    修改表: <span class="keyword">alter</span> <span class="keyword">table</span>表名<span class="string">&#x27; rename to &#x27;</span>新表名;</span><br><span class="line">    <span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">&#x27;表名&#x27;</span> addcolumns (字段类型);</span><br><span class="line">    删除表: <span class="keyword">drop</span> <span class="keyword">table</span> <span class="string">&#x27;表名&#x27;</span>;</span><br><span class="line">    查询数据库中的所有表: <span class="keyword">show</span> tables;</span><br><span class="line">    查看表信息: <span class="keyword">describe</span> <span class="keyword">table</span> <span class="string">&#x27;表名&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">DML:数据管理语言</span><br><span class="line">    添加数据:从文件中添加到表中</span><br><span class="line">    load data inpath HDFS路径<span class="keyword">into</span> <span class="keyword">table</span>表名</span><br><span class="line">    load data <span class="keyword">local</span> inpath Linux路径<span class="keyword">into</span> <span class="keyword">table</span>表名</span><br><span class="line">    load data <span class="keyword">local</span> inpath Linux路径overwrite <span class="keyword">into</span> <span class="keyword">table</span>表</span><br><span class="line">    </span><br><span class="line">    从一个表添加到另<span class="operator">-</span>一个表中</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> 表名 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 原表 <span class="keyword">where</span>条件;</span><br><span class="line">    <span class="keyword">from</span> 原表 <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> 表名 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">where</span> 条件</span><br><span class="line">    <span class="keyword">from</span> 原表 <span class="keyword">insert</span> overwrite <span class="keyword">table</span> 表名 <span class="keyword">select</span> 字段 <span class="keyword">where</span> 条件</span><br><span class="line">    从表中导出到文件中</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> directory HDFS路径 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>表</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">local</span> directory Linux 路径<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表</span><br><span class="line">    export <span class="keyword">table</span> 表 <span class="keyword">to</span> HDFS路径</span><br><span class="line">    </span><br><span class="line">DQL:数据查询语言</span><br><span class="line">    标准查询: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>表名</span><br><span class="line">    分组: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span>字段</span><br><span class="line">    排序: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span>字段<span class="keyword">desc</span></span><br><span class="line">    多表联合查询: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 a <span class="keyword">join</span> 表b  <span class="keyword">on</span> a.id<span class="operator">=</span> b.id)</span><br><span class="line">    </span><br><span class="line">创建表时的特殊操作</span><br><span class="line">    分区: partitioned (字段类型)</span><br><span class="line">    指定列分隔符: <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;分隔符&#x27;</span></span><br><span class="line">    指定外部表的存储路径: location 路径</span><br><span class="line">    指定外部表的存储类型: stored <span class="keyword">as</span> textfile</span><br><span class="line">    指定字段加密: <span class="type">ROW</span> FORMAT SERDE</span><br><span class="line">    <span class="string">&#x27;org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe&#x27;</span> <span class="keyword">WITH</span> SERDEPROPERTIES(</span><br><span class="line">    <span class="string">&#x27;column.encode.columns&#x27;</span><span class="operator">=</span><span class="string">&#x27;字段1,字段</span></span><br><span class="line"><span class="string">    2&#x27;</span>column.encode.classname<span class="string">&#x27; =&#x27;</span>org apache.hadoop.hive.serde2.AESRewriter);</span><br></pre></td></tr></table></figure>

<h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><h2 id="Spark特点"><a href="#Spark特点" class="headerlink" title="Spark特点"></a>Spark特点</h2><pre><code>轻快灵巧Spark的处理能力是MapReduce的30倍，处理能力不容易受到任务量增加的影响
</code></pre>
<p>轻:底层代码只有3万行，使用的函数式编程语言scala<br>快:处理速度快<br>灵:提供很多不同层面的处理功能<br>巧:巧妙的应用Hadoop平台</p>
<h2 id="RDD-分布式数据集、可分区的"><a href="#RDD-分布式数据集、可分区的" class="headerlink" title="RDD:分布式数据集、可分区的"></a>RDD:分布式数据集、可分区的</h2><ul>
<li>具有血统机制(RDD由父RDD执行操作之后产生)</li>
<li>如果子RDD丢失，RDD故障，重新执行父RDD就可以重新得到的子RDD</li>
<li>RDD默认存储在内存中，如果内存不足的时候，发生溢写</li>
<li>Spark节点会分配60%的内存用于做缓存，40%执行内存</li>
</ul>
<h2 id="依赖类型"><a href="#依赖类型" class="headerlink" title="依赖类型"></a>依赖类型</h2><pre><code>宽依赖、窄依赖
</code></pre>
<ul>
<li>窄依赖:父RDD的每个分区都只会被<code>一个</code>子RDD的分区所依赖</li>
<li>宽依赖:父RDD的每个分区可能会被<code>多个子RDD的分区所依赖</code></li>
</ul>
<h2 id="Stage划分"><a href="#Stage划分" class="headerlink" title="Stage划分"></a>Stage划分</h2><pre><code>遇到窄依赖就加入，宽依赖就断开，剩余的所有RDD被放在一个Stage中
</code></pre>
<h2 id="RDD操作类型"><a href="#RDD操作类型" class="headerlink" title="RDD操作类型"></a>RDD操作类型</h2><ul>
<li><p>创建操作:创建RDD用于接收数据结果</p>
</li>
<li><p>原始RDD:读取数据源获得的RDD (readFile(path))</p>
</li>
<li><p>转换得来:通过父RDD执行操作后得到的子RDD</p>
</li>
<li><p>控制操作:持久化RDD,可以持久化到内存或磁盘中,默认存在内存</p>
</li>
<li><p>转换操作:可对RDD执行的处理操作，转换操作是懒惰的，转换操作并不是立马执行，遇到行动操作才执行</p>
</li>
<li><p>行动操作:实际调用Spark执行(存储文件,数据输出等)</p>
</li>
<li><p>transformation算子在整个程序中 -&gt;声明转换操作,实际并没有执行</p>
</li>
<li><p>action算子时， 会从第一-个操作开始执行</p>
</li>
<li><p>DataFrame:属于一个DataSet实例， 不可变的弹性分布式数据集，存储数据时不止存储数据内容,存储数据对应结构信息及类型</p>
</li>
<li><p>DataSet:以对象的形式存储数据集，DataFrame&#x3D; DataSet[Row]</p>
</li>
</ul>
<h2 id="RDD、DataFrame、-DataSet数据集的联系"><a href="#RDD、DataFrame、-DataSet数据集的联系" class="headerlink" title="RDD、DataFrame、 DataSet数据集的联系"></a>RDD、DataFrame、 DataSet数据集的联系</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151418011.png?token=ARYCSAWRARIHVOCZT6NHLH3CQCNVU"></p>
<h2 id="Spark体系架构"><a href="#Spark体系架构" class="headerlink" title="Spark体系架构"></a>Spark体系架构</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151418466.png?token=ARYCSAQGUHHKT3TZXELJC7LCQCNWU"></p>
<ul>
<li>集群部署形式: <br>Standalone: spark自 己管理资源调度<br>Spark On Yarn:使用yarn做资源管理调度 <br>Mesos: AMR实验室开发的资源管理器，最适用于Spark的资源管理器</li>
<li>Spark Core:处理核心</li>
<li>Spark SQL:处理结构化数据，使用Hive元数据</li>
<li>Spark Streaming:实时流处理(实际微批处理) , 能够低延迟的计算反馈结果</li>
<li>MLLib:机器学习,根据历史数据进行建模，根据模型和提供的数据进行数据预测</li>
<li>GraphX:图计算,主要用于关系统计,关系查询</li>
<li>SparkR: R语言库,提供R语言接口，可以使用R语言操作Spark</li>
<li>Structured Streaming:流处理，将数据存入-个无边界表(新数据不断添加，旧数据不断移除)使用增量的方式获取表数据内容进行执行</li>
</ul>
<h1 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h1><pre><code>分布式流处理组件
</code></pre>
<h2 id="关键特性-实时响应，延迟性低"><a href="#关键特性-实时响应，延迟性低" class="headerlink" title="关键特性:实时响应，延迟性低"></a>关键特性:实时响应，延迟性低</h2><ul>
<li>数据不存储先执行(离线处理先存储数据然后再执行)</li>
<li>连续查询(程序运行后就不终止,除非系统故障导致的终止或者手动停止)</li>
<li>事件驱动:传入的数据信息触动任务处理</li>
</ul>
<h2 id="Streaming系统架构"><a href="#Streaming系统架构" class="headerlink" title="Streaming系统架构"></a>Streaming系统架构</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151418540.png?token=ARYCSAXAP6TJ6NCOI5DFBPDCQCNXE"></p>
<ul>
<li>Client:客户端接口</li>
<li>Nimbus (主节点) :接收客户端的请求，管理Supervisor从节点，管理任务分配，编写任务书</li>
<li>Supervisor (从节点) :实行任务，管理worker</li>
<li>Worker (进程) :程序执行</li>
<li>Executor (线程) :每个Executor中默认执行一 一个Task</li>
<li>Task (任务) : Task分别对应每一 个Spout&#x2F;Bolt组件的执行 </li>
<li>ZooKeeper:监控Nimbus主节点的状态，如果主节点故障切换备用节点<br>监控Supervisor从节点状态，如果从节点故障,通知Nimbus迁移任务，启动自动恢复<br>接收Nimbus任务书，将每个从节点的任务存放在每个Supervisor自己对应的目录中</li>
</ul>
<h2 id="Streaming任务架构"><a href="#Streaming任务架构" class="headerlink" title="Streaming任务架构"></a>Streaming任务架构</h2><ul>
<li>Topology:拓扑结构,封装任务执行流程</li>
<li>Spout:发送数据源的组件,接收第三方数据收集I具提供的数据发送到数据流</li>
<li>每个应用只有一个spout</li>
<li>Bolt:从数据流中获取数据,执行数据处理，如果当前bolt不是最后-个执行程序将结果放回数据流一个应用中可以有多个bolt</li>
<li>Tuple:数据流中的数据格式，组件之间数据传输的格式，元组中包含两个参数(id, stream)</li>
</ul>
<h2 id="Streaming执行任务"><a href="#Streaming执行任务" class="headerlink" title="Streaming执行任务"></a>Streaming执行任务</h2><ol>
<li>用户通过Client提交应用到Nimbus中</li>
<li>Nimbus接收到应用后，根据应用情况及当前集群的从节点情况编写任务书</li>
<li>将任务书.上传到ZooKeeper中</li>
<li>ZooKeeper接收到任务书后根据每个节点将对应的任务存放在节点对应的目录下</li>
<li>Supervisor周期性监测自己在ZooKeeper中的目录有没有新任务</li>
<li>Supervisor发现新任务，根据任务书内容从Nimbus中下载任务所需要的jar包</li>
<li>Supervisor执行任务,反馈执行状态给Nimbus .</li>
<li>Nimbus将任务状态反馈给Client</li>
</ol>
<h2 id="根据任务架构执行"><a href="#根据任务架构执行" class="headerlink" title="根据任务架构执行"></a>根据任务架构执行</h2><ol>
<li>获取拓扑结构</li>
<li>根据拓扑结构分别找到每一流程的处理单元</li>
<li>按照路程执行处理单元</li>
</ol>
<h2 id="消息传递语义"><a href="#消息传递语义" class="headerlink" title="消息传递语义"></a>消息传递语义</h2><ul>
<li>最多一次:数据发送只发送一次, 可靠性最低，吞吐量最大<br>  缺点:可能存在数据丢失的情况<br>  优点:数据一定不会被重复执行</li>
<li>最少一次:数据可能会发送多次，可靠性高，吞吐量较小<br>  优点:数据不会丢失<br>  缺点:数据可能会被重复执行</li>
<li>仅有一次(精准一次) :数据就发送一-次, 并且保证发送成功，可靠性高，吞吐量最低<br>  优点:数据不会丢失，且数据不被重复处理<br>  缺点:消耗的资源和时间较多</li>
</ul>
<h2 id="Ack机制-消息传输最少一次"><a href="#Ack机制-消息传输最少一次" class="headerlink" title="Ack机制(消息传输最少一次)"></a>Ack机制(消息传输最少一次)</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151418753.png?token=ARYCSAWRFRIHBUCJJK33MJLCQCNXY"></p>
<h1 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h1><pre><code>分布式实时计算引擎(流处理引擎)
</code></pre>
<h2 id="Flink-VS-Spark-Streaming"><a href="#Flink-VS-Spark-Streaming" class="headerlink" title="Flink VS Spark Streaming"></a>Flink VS Spark Streaming</h2><ul>
<li>Flink可以做流处理(侧重)也可以做批处理，底层引擎属于流处理引擎</li>
<li>通过流处理引擎模拟批处理形式实现的批处理</li>
<li>Spark可以做流处理也可以做批处理(侧重点)，底层弓|擎属于批处理引擎</li>
<li>通过批处理引擎,模拟流处理实现的流处理功能</li>
</ul>
<h2 id="Flink的关键特性"><a href="#Flink的关键特性" class="headerlink" title="Flink的关键特性"></a>Flink的关键特性</h2><pre><code>状态、时间、窗口、检查点
</code></pre>
<h2 id="Flink系统架构"><a href="#Flink系统架构" class="headerlink" title="Flink系统架构"></a>Flink系统架构</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151418648.png?token=ARYCSAX4VBWVPDPE5COHNI3CQCNY4"></p>
<ul>
<li>部署形式: Local (单机版部署)<br>  Cluster (Standalone: Flink集群自己管理资源调度<br>  Yarn:借助Yarn组件帮助管理协调资源和任务)<br>  Clound (云部署)</li>
<li>Flink核心模块: Runtime (不管是流处理还是批处理都是在Runtime中执行)</li>
<li>接口层: DataStream (流处理)和DataSet (批处理)</li>
<li>Table API &amp; SQL:处理结构化数据<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Table</span> API:将操作应用封装成方法</span><br><span class="line">    <span class="keyword">select</span>(&quot;t_ demo &quot;).<span class="keyword">where</span>(&quot;条件&quot;)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">SQL</span>:基于<span class="keyword">Table</span> API使用，</span><br><span class="line">    sqlQuery(&quot;select * from t_ demo where条件&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="有界流和无界流"><a href="#有界流和无界流" class="headerlink" title="有界流和无界流"></a>有界流和无界流</h2><ul>
<li>有界流:知道开始，知道结束，使用批处理处理有界流数据.</li>
<li>无界流:知道开始，不知道结束，使用流处理接口进行数据处理</li>
</ul>
<h2 id="DataStream-用于存储数据的数据集，只能执行流处理操作"><a href="#DataStream-用于存储数据的数据集，只能执行流处理操作" class="headerlink" title="DataStream:用于存储数据的数据集，只能执行流处理操作"></a>DataStream:用于存储数据的数据集，只能执行流处理操作</h2><ul>
<li>基于流处理运行环境获取到的数据</li>
</ul>
<h2 id="DataSet-用来接收数据的数据集，只能执行批处理操作"><a href="#DataSet-用来接收数据的数据集，只能执行批处理操作" class="headerlink" title="DataSet:用来接收数据的数据集，只能执行批处理操作"></a>DataSet:用来接收数据的数据集，只能执行批处理操作</h2><ul>
<li>基于批处理运行环境获取到的数据</li>
</ul>
<p><code>并不能在一个应用中同时接收流处理和批处理接口，以此实现流处理和批处理的共用</code></p>
<h2 id="Flink运行流程"><a href="#Flink运行流程" class="headerlink" title="Flink运行流程"></a>Flink运行流程</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151419908.png?token=ARYCSARE4QYFZKKQ3RJCOTLCQCN2A"></p>
<ol>
<li>DataSource:接收数据输入，从数据源获取数据</li>
<li>Transformations:数据转换，数据处理过程</li>
<li>DataSink:将最终数据结果输出到指定位置(如HDFS、 HBase、 文件、数据库等)</li>
</ol>
<h2 id="Flink程序运行流程"><a href="#Flink程序运行流程" class="headerlink" title="Flink程序运行流程"></a>Flink程序运行流程</h2><p><code>1. 创建运行环境流处理/批处理</code><br>2. 通过运行环境对象获取数据源数据(DataStream&#x2F;DataSet)<br>3. 针对数据集进行数据转换<br>4. 将最终结果进行输出(批处理的print算子)<br><code>5. 最后执行程序(行动算子) executor()</code></p>
<h2 id="Flink运行程序"><a href="#Flink运行程序" class="headerlink" title="Flink运行程序"></a>Flink运行程序</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151420112.png?token=ARYCSARQSJHF2WMKPMIWLCTCQCN6E"></p>
<ol>
<li>Client向JobManager发起请求</li>
<li>Client对任务进行优化等操作</li>
<li>JobManager分配任务给TaskManager</li>
<li>TaskManager接收到任务后执行任务</li>
<li>TaskManager反馈任务执行状态给JobManager</li>
<li>JobManager统一反馈给用户</li>
</ol>
<ul>
<li>Flink Client:用户通过Client连接到JobManager</li>
<li>JobManager (主节点) :接收用户请求，管理资源任务分配，管理从节点信息</li>
<li>TaskManager (从节点) :接收任务处理任务，反馈给主节点</li>
<li>Standalone部署:创建Task Slot: Flink的抽象资源</li>
</ul>
<h2 id="Flink状态"><a href="#Flink状态" class="headerlink" title="Flink状态"></a>Flink状态</h2><pre><code>区别于其他组件的一-个特性，支持状态管理(中间结果状态)
</code></pre>
<h2 id="Fink窗口类型"><a href="#Fink窗口类型" class="headerlink" title="Fink窗口类型"></a>Fink窗口类型</h2><ul>
<li>滑动窗口: 窗口移动方式是平移,设定参数时需要设定窗口大小,滑动距离.窗口大小固定,可能会出现数据源重复和数据丢失的情况</li>
<li>滚动窗口: 窗口移动方式滚动,滚动距离就是窗口大小,设定窗口时只需要设定窗口大小.窗口大小固定,不会出现数据重复或者数据丢失的情况,会出现空窗口的情况</li>
<li>会话窗口: 由会话启动的窗口,设定过期时间,窗口代销不固定,运行时不会有丢失的数据,不会出现空窗口</li>
<li>时间窗口: 以时间为条件设定的窗口,<code>分别可以再分为滑动或滚动</code></li>
<li>数量窗口: 由会话启动的窗口,设定过期时间,<code>分别可以再分为滑动或滚动</code></li>
</ul>
<h2 id="Fink的时间类型"><a href="#Fink的时间类型" class="headerlink" title="Fink的时间类型"></a>Fink的时间类型</h2><ul>
<li>时间类型: 事件发生的时间 </li>
<li>时间类型: 时间达到处理系统的时间</li>
<li>处理时间(默认): 时间被处理的时间</li>
<li>时间乱序问题: 事件被处理的顺序不是时间产生顺序</li>
<li>时间乱序原因: 数据受到数据传输影响</li>
</ul>
<h2 id="Watermark-水位线-x2F-水印-解决数据乱序问题"><a href="#Watermark-水位线-x2F-水印-解决数据乱序问题" class="headerlink" title="Watermark(水位线&#x2F;水印): 解决数据乱序问题"></a>Watermark(水位线&#x2F;水印): 解决数据乱序问题</h2><ul>
<li>设定水位线时间,当水位线设定的时间时间也达到系统时,就会触发窗口执行</li>
<li>可设置水位线延迟,可允许窗口延迟触发\</li>
</ul>
<h2 id="对于延迟数据的处理方式"><a href="#对于延迟数据的处理方式" class="headerlink" title="对于延迟数据的处理方式"></a>对于延迟数据的处理方式</h2><ul>
<li>丢弃(默认): 当窗口已经被触发过,该窗口的数据达到也会被丢弃,不会被执行</li>
<li>可允许延迟: 设定可允许延迟时间,窗口已经被执行,但是输在可允许延迟时间达到,重新重发窗口的执行<br><code>allowedLateness</code>(可延迟时间)</li>
<li>收集后做统一处理: 把所有的延迟数据收集起来,在程序最后做统一处理<br><code>OutputTag&lt;T&gt; lateOutputTag = new OutputTag //用于存放延迟数据的数据集</code><br><code>.side0utputLateData(late0utputTag)</code></li>
</ul>
<h2 id="Flink容错性-CheckPoint实现"><a href="#Flink容错性-CheckPoint实现" class="headerlink" title="Flink容错性 (CheckPoint实现)"></a>Flink容错性 (CheckPoint实现)</h2><ol>
<li><code>CheckPoint:检查点，自动触发,当任务结束后会自动删除</code><ul>
<li>保存当前任务状态，周期性触发,默认情况下不启动检查点</li>
<li>在启动检查点时就可以设定周期时间，单位ms: .enableCheckPointing(10000)</li>
<li>修改消息传输语义(默认情况仅有一次): .setCheckPointMode(CheckPointMode.AT_LEAST_ONCE)</li>
<li>快照超时时间:防止一个问题快照影响大量快照创建堆积: .setCheckpointingTimeout(60000)</li>
<li>可以设定检查点之间的最小间隔时间</li>
<li>可以设定最大并行执行数量</li>
<li>设定外部检查点:可以把检查点信息存储于在外部系统中，不会因为Flink系统问题受到影响</li>
</ul>
</li>
<li>SavePoint:保存点，底层CheckPoint, 手动触发,任务结束后也依旧保留</li>
</ol>
<h2 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h2><p>内存:默认，state和checkpoint都存储在内存，只是用本地测试<br>文件系统: state在内存， checkpoint在文件系统中<br>数据库: state存储在内置数据库中，checkpoint在文件系统中，针对大量数据任务处理的场景</p>
<h1 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h1><pre><code>Flume属于一个高性能、分布式的海量日志采集工具可以适用于流数据采集、也可以用于静态数据采集
</code></pre>
<h2 id="Flume基础架构"><a href="#Flume基础架构" class="headerlink" title="Flume基础架构"></a>Flume基础架构</h2><pre><code>(主用应用于单节点数据采集)
</code></pre>
<p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151420684.png?token=ARYCSAQ53KMGFJWE4NRDOKDCQCN6Y"></p>
<ul>
<li>Flume中有两个组件对外交互: source、 sink</li>
<li>source:采集数据,接收数据输入</li>
<li>channel:管道、 临时存储</li>
<li>sink:数据输出</li>
</ul>
<h2 id="Flume多agent架构"><a href="#Flume多agent架构" class="headerlink" title="Flume多agent架构"></a>Flume多agent架构</h2><pre><code>(主要用于集群外采集传递到集群内采集)
</code></pre>
<p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151420961.png?token=ARYCSAULGDFE5WKWJBQV4WTCQCN7I"></p>
<ul>
<li>把第一级的Flume数据输出到第二级Flume中</li>
<li>设定第一-级Flume的sink类型为avro协议或者thrift协议可以将数据存储到下一级Flume的Source</li>
</ul>
<h2 id="Flume多Agent合并"><a href="#Flume多Agent合并" class="headerlink" title="Flume多Agent合并"></a>Flume多Agent合并</h2><pre><code>(将多数据源采集到的数据汇总处理)
</code></pre>
<p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151420077.png?token=ARYCSAXS56IVNM2IIBLZWVDCQCOAC"></p>
<h2 id="Flume数据传输基本单位"><a href="#Flume数据传输基本单位" class="headerlink" title="Flume数据传输基本单位"></a>Flume数据传输基本单位</h2><ul>
<li>event: 基本单位,header+ byte[]</li>
<li>当source采集数据时，在source内部将数据封装成event</li>
</ul>
<h2 id="Flume-Agent原理"><a href="#Flume-Agent原理" class="headerlink" title="Flume Agent原理"></a>Flume Agent原理</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151421543.png?token=ARYCSATG3JJOAWTBCBKGDG3CQCOAY"></p>
<ol>
<li>在source内部可以将数据封装成event</li>
<li>source将event传输给channel处理器(拦截器)可以做数据简单处理</li>
<li>清洗完后的数据通过channe|选择器将event输入到指定的channel</li>
<li>SinkRunner在程序运行时就启动</li>
<li>使用sink处理器实例化一个指定类型的sink从指定的channel中抽取数据</li>
<li>将抽取到的数据按照设定的类型和目的路径将数据输出</li>
</ol>
<h2 id="Flume-Source"><a href="#Flume-Source" class="headerlink" title="Flume Source"></a>Flume Source</h2><pre><code>(数据收集、接收数据输入)
</code></pre>
<ul>
<li>驱动型:被动接收数据输入</li>
<li>轮询型:周期性的主动扫描是否有新数据产生</li>
</ul>
<h2 id="Flume-Channel"><a href="#Flume-Channel" class="headerlink" title="Flume Channel"></a>Flume Channel</h2><pre><code>(数据存储)
</code></pre>
<ul>
<li><p>MemoryChannel (内存) : event数据存放在当前节点的内存中<br>  读写速度快，数据未持久化，占用内存空间<br>  capacity:最大内存容量(默认情况下使用到节点内存存满为止)</p>
</li>
<li><p>FileChannel (文件) :使用WAL,管理上比较复杂<br>数据可持久化，数据读写速度慢于内存形式</p>
</li>
<li><p>JDBCChannel (内置数据库) : derby数据库，可以替代File存储的形式<br>数据可持久化，数据读写速度慢于内存形式</p>
</li>
</ul>
<h2 id="Flume-Sink"><a href="#Flume-Sink" class="headerlink" title="Flume Sink"></a>Flume Sink</h2><pre><code>(数据输出)
</code></pre>
<h2 id="Flume的Source、Channel、-Sink之间的关系"><a href="#Flume的Source、Channel、-Sink之间的关系" class="headerlink" title="Flume的Source、Channel、 Sink之间的关系"></a>Flume的Source、Channel、 Sink之间的关系</h2><ul>
<li><code>一个Source至少连接一个Channel</code></li>
<li><code>一个Sink只作用于一个Channel</code></li>
</ul>
<h2 id="Flume级联节点"><a href="#Flume级联节点" class="headerlink" title="Flume级联节点"></a>Flume级联节点</h2><pre><code>级联节点间传输的数据可以进行加密、压缩
</code></pre>
<ul>
<li>加密:提高数据传输安全性</li>
<li>压缩:提高整体传输速度(减少传输时间)</li>
<li><code>Flume内部数据传输(source --&gt; channel --&gt; sink) 不需要加密</code></li>
</ul>
<h2 id="Flume运行实例"><a href="#Flume运行实例" class="headerlink" title="Flume运行实例"></a>Flume运行实例</h2><pre><code>内容需要配置到配置文件中(自定义.properties)
</code></pre>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a.sources= r1</span><br><span class="line">a.channels=c1</span><br><span class="line">a.sinks=k1</span><br><span class="line">a.sourses.r1.type=taildir</span><br><span class="line">a.sourses.r1.postion= 记录pos记录的文件</span><br><span class="line">a.sourses.r1.filegroups=f1 f2</span><br><span class="line">a.sourses.r1.filegroups.f1 = 要监控的文件</span><br><span class="line">a.sourses.r1.filegroups.f2= 要监控的文件</span><br><span class="line">a.channels.c1.type=memory</span><br><span class="line">a.sinks.k1.type=logger</span><br><span class="line">a.sources.r1.channels=c1</span><br><span class="line">a.sinks.k1.channel=c1</span><br></pre></td></tr></table></figure>

<h2 id="Flume运行命令"><a href="#Flume运行命令" class="headerlink" title="Flume运行命令"></a>Flume运行命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flume-ng agent --name a --conf flumecï 71411Z --conf-file 配置文件 - Dflume.root.logger=info, console</span><br><span class="line">flume-ng agent -n a -C flume配置文件路径 -f 配置文件 -Dflume.root.logger=info, console</span><br></pre></td></tr></table></figure>

<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><pre><code>分布式日志系统(发布订阅消息系统)，可分区、多副本、多订阅
</code></pre>
<h2 id="消息传输形式"><a href="#消息传输形式" class="headerlink" title="消息传输形式"></a>消息传输形式</h2><ul>
<li>点对点:数据在被获取到之后就会被从消息系统中删除(只有-一个用户可以获取到这个消息)</li>
<li>发布订阅:消息发布之后，就算被用户获取之后也不会删除，依旧保留在系统中提供给其他用户获取</li>
</ul>
<h2 id="Kafka的特点"><a href="#Kafka的特点" class="headerlink" title="Kafka的特点"></a>Kafka的特点</h2><ul>
<li>可支持TB级别的数据也能在常量时间内的访问性能</li>
<li>高吞吐率:单节点每秒可以传输100K条数据</li>
<li>可分区:数据以分区形式存储</li>
<li>多副本:提高数据容错性</li>
<li>同时支持流处理和批处理</li>
<li>可扩展性:本身属于集群由多节点组成，扩展节点</li>
</ul>
<h2 id="Kafka拓扑结构"><a href="#Kafka拓扑结构" class="headerlink" title="Kafka拓扑结构"></a>Kafka拓扑结构</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151421126.png?token=ARYCSAWNQND46BLECQTNASDCQCOBU"></p>
<ul>
<li>Kafka:由broker集群组成</li>
<li>Producer:数据发布者，发布消息，将数据发布到Kafka中存储</li>
<li>Consumer:数据消费者，订阅消息，从Kafka中获取数据</li>
<li>ZooKeeper: Kafka强依赖，监测集群状态</li>
</ul>
<h2 id="Kafka集群系统架构"><a href="#Kafka集群系统架构" class="headerlink" title="Kafka集群系统架构"></a>Kafka集群系统架构</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151422239.png?token=ARYCSATAJWDNKTIBO7OTGSLCQCOFA"></p>
<p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151422226.png?token=ARYCSASRM7AGQUEACQZWSCDCQCOFS"></p>
<h2 id="消费组-consumer-group"><a href="#消费组-consumer-group" class="headerlink" title="消费组:consumer group"></a>消费组:consumer group</h2><pre><code>每个消费者一定是属于某一个消费组
</code></pre>
<ul>
<li>消费数据规则:消费组内的数据是竞争的,消费组间的数据是共享的 <br>一条消息可以被多个消费组获取,但是每个消费组只能有一个消费者消费信息</li>
<li>Kafka Topic:消息类别名<br>用于区分记录数据、发布者发布数据时需要指定topic,消费者订阅数据时指定topic</li>
<li>Kafka Partition:分区，数据写入:顺序追加的方式<br>数据以分区的形式存储，在创建topic时可以指定当前topic中有几个分区</li>
<li>Kafka Segment:分段<br>每个消息就是一个分段, 分段由两个文件组成.index和.log</li>
<li>Offset:偏移量值<br>每一个消息都有的唯一标识位置</li>
<li>每个消费组都会维护一份offset文件(当前组中的成员读取的数据位置)</li>
<li>读取数据时数据定位: broker –&gt; topic –&gt; offset</li>
</ul>
<h2 id="Kafka的其他重要概念"><a href="#Kafka的其他重要概念" class="headerlink" title="Kafka的其他重要概念"></a>Kafka的其他重要概念</h2><ul>
<li>replica:副本，在创建partition的时候指定该分区有几个副本\</li>
</ul>
<p>–partitons 1 –replaction-factor 2<br>数据文件为2份，partiton本身也属于副本的一部分</p>
<ul>
<li>leader:从副本中选取一个leader对外提供服务，发布者和消息者只跟leader交互</li>
<li>follower:除leader以外的其他副本都是follower, follower同步leader信息</li>
<li>controller: kafka中的一 -个服务器: leader选举、 leader切换</li>
<li>ISR列表:列表中的follower,能正常同步leader信息<br>只有在列表中的follower有资格成为下一-任leader<br>刚开始所有的follower都在ISR列表中，当follower故障不能及 时同步leader时会被移除列表</li>
</ul>
<h2 id="Kafka分区副本"><a href="#Kafka分区副本" class="headerlink" title="Kafka分区副本"></a>Kafka分区副本</h2><pre><code>(节点和节点之间的分区互为主备)
</code></pre>
<p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151422335.png?token=ARYCSAWMSBMNJRP2FG4WMY3CQCOGE"></p>
<p>分区副本同步</p>
<pre><code>(follower从leader同步数据 )
</code></pre>
<p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151422218.png?token=ARYCSAXBVFDRGL4Q2FLNJC3CQCOG2"></p>
<ul>
<li>如果所有分区都出现故障<br>可靠性高、恢复速度慢:等待ISR中的分区恢复，第一个恢复就是leader<br>可靠性低、恢复速度快:等待分区恢复，第一个恢复的不管是不是ISR列表中的分区也成为leader</li>
<li>可靠性传输:幂等性(操作一次和多次的结果是一样)<br>给每条消息一个唯-标识id, 消息传递后使用一个列表记录已传输成功的消息id<br>每条消息传输到达时都会被使用id在列表中查询，查看id是否存在<br>如果存在:说明消息之前已经被传输过<br>如果不存在:正常处理，并且处理完后将id写入列表</li>
<li>acks机制(检测数据是否发送成功)<br>acks&#x3D;0:不管数据是否发送成功<br>acks&#x3D;1:当数据写入leader时就认为成功<br>acks&#x3D;all:当数据写入leader并且follower都接收到才反馈成功</li>
<li>Kafka持久化存储数据(不管数据有没有被消费过)</li>
<li>旧数据的处理方式:删除&#x2F;压缩<br>删除:配置数据过期时间<br>压缩:根据键值对的key值只保留最新的value值，以前的值就删除</li>
<li>Kafka高吞吐的原因<br>顺序读写:数据以追加形式写入分区，速度远快于随机读写<br>零拷贝:数据写入不需要经过数据缓冲区直接到达磁盘<br>分区:数据可以分别存在多个分区中，读取的时候可以并行的从分区中读取到数据<br>压缩:可以对数据进行压缩</li>
</ul>
<p><code>分区副本:只有leader对外提供服务的, follower只做同步操作</code></p>
<h1 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h1><pre><code>基于开源的Sqoop组件开发得到的
</code></pre>
<h2 id="Loader-1"><a href="#Loader-1" class="headerlink" title="Loader"></a>Loader</h2><ul>
<li>Loader数据导入导出(作用在关系型数据库和非关系型数据库之间)<br>关系型数据库:结构化<br>非关系型数据库:非结构化</li>
<li>数据导入:数据从RDB导入到NoSQL</li>
<li>数据导出:数据从NoSQL导出到RDB</li>
<li>Loader相比较Sqoop组件的增强特性<br>图形化:提供WebUI界面可以通过界面配置任务,连接器的配置<code>MRS (Hue)</code><br>高性能:底层使用MapReduce并行处理<br>高可靠:主备双机的搭建<br>  作业失败后允许重试<br>  作业失败后不会有残留的数据<br>安全性:使用kerberos进行安全认证</li>
</ul>
<h2 id="Loader模型架构"><a href="#Loader模型架构" class="headerlink" title="Loader模型架构"></a>Loader模型架构</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151422011.png?token=ARYCSAS7ZWGY6RPEGOYEUMTCQCOHI"></p>
<ol>
<li><p>Loader Client: Tool: 命令行模式连接Loader服务</p>
<ul>
<li>Web UI: MRS图形化的方式连接到Loader</li>
</ul>
</li>
<li><p>Loader Server:</p>
<ul>
<li>Restful API (http+json) 对外提供的连接接口</li>
<li>JobSheduler: Transform 转换模块–&gt;数据处理.<br> Execution执行模块–&gt;执行计划<br> Submission提交模块–&gt;提交到MR<br> JobManager:管理任务执行状态</li>
<li>Metadata Repository:元数据仓库，存储管理元数据</li>
<li>HA Manager:主备管理</li>
</ul>
</li>
</ol>
<h2 id="Loader任务执行"><a href="#Loader任务执行" class="headerlink" title="Loader任务执行"></a>Loader任务执行</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151422876.png?token=ARYCSASCAA6THGM7VECBPZDCQCOH2"></p>
<ol>
<li>Client提交任务</li>
<li>Loader任务计划</li>
<li>将任务提交给Yarn</li>
<li>Yarn调配资源将任务分配为Map或Reduce任务执行</li>
<li>将数据存入设定的存储介质中</li>
</ol>
<h2 id="Loader任务配置"><a href="#Loader任务配置" class="headerlink" title="Loader任务配置"></a>Loader任务配置</h2><ul>
<li>输入:数据来源的配置</li>
<li>转换:字段映射、获取数据、过滤数据、并发执行数量</li>
<li>输出:数据最终输出目的地的配置</li>
</ul>
<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><pre><code>分布式检索服务,适用实时场景
Hive:可以做查询分析，底层MR处理，不适用实时
</code></pre>
<h2 id="ElasticSearch特点"><a href="#ElasticSearch特点" class="headerlink" title="ElasticSearch特点"></a>ElasticSearch特点</h2><ul>
<li>基于Lucena扩展</li>
<li>可以水平扩展</li>
<li>原型环境和生产环境可以无缝切换</li>
<li><code>作为非关系型数据库NoSQL数据库使用</code></li>
<li>支持结构化数据和非结构化数据</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ol>
<li><p>正排索引:在文件中查找关键字 <br> 扫描每个文件内容找到跟关键字相关的文件，返回文件 </p>
</li>
<li><p>倒排索引:根据关键字查找文件(提前给文件设定关键字)<br>根据关键字查哪些文件标记了这个关键字<br>快速查找相关文件，并且文件相关度更高</p>
</li>
</ol>
<h2 id="ElasticSearch系统架构"><a href="#ElasticSearch系统架构" class="headerlink" title="ElasticSearch系统架构"></a>ElasticSearch系统架构</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151423023.png?token=ARYCSAUFEFGFKRZGMEMZQSTCQCOI6"></p>
<ul>
<li>Client:连接到ZooKeeper获取集群信息，连接到集群</li>
<li>EsMaster:主要任务分配，管理EsNode信息， 不参与分片级别的数据检索</li>
<li>EsNode:处理用户管理索引|操作，管理自身分片信息(数据默认存储在内存中)</li>
<li>ZooKeeper: es强依赖，管理集群状态，并且记录集群信息</li>
</ul>
<h2 id="ElasticSearch中的核心概念"><a href="#ElasticSearch中的核心概念" class="headerlink" title="ElasticSearch中的核心概念"></a>ElasticSearch中的核心概念</h2><ul>
<li>索引: index –&gt; 命名空间</li>
<li>文档: document –&gt; 数据存储，ES中的检索基本单元</li>
<li>映射: mapping –&gt; 约束字段类型</li>
</ul>
<h2 id="ElasticSearch命令使用"><a href="#ElasticSearch命令使用" class="headerlink" title="ElasticSearch命令使用"></a>ElasticSearch命令使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据添加/修改: put /索引/_doc/id</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;key&quot;</span>:<span class="string">&quot;value&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">数据查询: get /索引/_doc/id</span><br><span class="line">数据删除: delete /索引/_doc/id</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><pre><code>基于内存的，网络高性能数据库
</code></pre>
<ul>
<li>读取速度快，低延迟</li>
<li>适用于实时场景</li>
<li>可持久化(RDB&#x2F;AOF)</li>
<li>key-value<br>key命名:见名知意<br>value:可以存储多样数据</li>
<li>属于NoSQL数据库(存储多样化:图像、视频、音频、数字、文字等)</li>
</ul>
<h2 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h2><ul>
<li>排序类应用</li>
<li>设置过期时间应用</li>
<li>统计计数</li>
<li>消息队列</li>
<li>临时存储</li>
</ul>
<h2 id="Redis系统架构"><a href="#Redis系统架构" class="headerlink" title="Redis系统架构"></a>Redis系统架构</h2><ul>
<li><code>无中心、自组织的集群</code>: 集群中的所有节点会维护一个集群拓扑</li>
<li>分桶:根据key值计算hash存储进不同的槽中</li>
<li>集群拓扑中维护的就是槽和节点的映射关系</li>
<li><code>Redis节点只帮助用户重定向，不进行转发</code><br>重定向: Client发出多次请求(<code>Client分 别请求节点</code>)<br>转发: Client只需要请求第一个节点，节点帮助Client向正确的节点发出请求(Client只需要请求第一 台节点)</li>
</ul>
<h2 id="Redis读写流程"><a href="#Redis读写流程" class="headerlink" title="Redis读写流程"></a>Redis读写流程</h2><p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151423308.png?token=ARYCSASCGAE5V24SDVWYL7DCQCOJ6"></p>
<ol>
<li>Client向任意一 个节点发出请求，连接到redis</li>
<li>从redis节点中获取redis集群拓扑，得到key存储的server信息</li>
<li>可以获取到key对应的槽所在的server信息</li>
<li>如果做读取，对server发起读请求，如果是写入，就发起写请求</li>
<li><code>如果在Client获取拓扑时，数据发生变动，从一个节点迁移到另-一个节点</code></li>
<li>此时Client获取到的是旧的拓扑，向原定的server发起请求</li>
<li>server接收到请求后发现Client要请求的数据已经被迁移,会告诉Client数据被迁移到哪个节点</li>
<li>Client从原server中接收到正确server的反馈信息</li>
<li>对新server重新发起一-次请求，获取数据响应</li>
</ol>
<h2 id="Redis关键特性"><a href="#Redis关键特性" class="headerlink" title="Redis关键特性"></a>Redis关键特性</h2><ul>
<li>支持多数据库<br>名称不支持自定义，从0开始递增<br>默认情况下支持1 6个数据库,不做更改的情况下使用的是0号数据库<br>如果要切换当前使用的数据库: <code>select 0</code></li>
<li>可以通过正则表达式匹配所有符合规则的key值<br>keys正则表达式<br>要查找所有的a开头后面跟数字的所有的key值: <code>keys a[0-9]*</code></li>
<li>判断key是否存在: <code>exists key</code></li>
<li>删除key值: <code>del key key2</code></li>
<li>获取key对应的类型: <code>type key</code></li>
<li><code>redis中不区分大小写( 单个单词要不就全大写要不就全小写)</code></li>
</ul>
<h2 id="Redis数据类型及使用"><a href="#Redis数据类型及使用" class="headerlink" title="Redis数据类型及使用"></a>Redis数据类型及使用</h2><ul>
<li>String的数字可以作为数值类型使用</li>
<li>Hash添加数据时value是键值对(应用于对象数据存储)</li>
<li>List可重复的有序集合<br>操作数据时可以区分左右(前后)查询整个集合中的数据时<code>lrange key 0 -1</code></li>
<li>Set不重复无序的集合<br>可以针对集合计算交集、并集等</li>
<li>Sorted Set:有序集合,可以根据给key的分数进行排序</li>
</ul>
<h2 id="Redis性能优化"><a href="#Redis性能优化" class="headerlink" title="Redis性能优化"></a>Redis性能优化</h2><ul>
<li>可设置key的生存时间</li>
<li>Redis管道(pipeline) –&gt; 管道数据传输速度快于普通传输(仅在Java API中)</li>
<li>数据排序Sort,如果是对集合进行排序Sorted Set</li>
<li>Redis持久化(RDB&#x2F;AOF)<br>RDB(默认) :使用快照的方式对当前数据进行持久化存储<br>创建快照的条件(在指定时间内有指定数量的key发生变化): <code>save 时间s数量</code><br>手动触发: sava、bgsave<br>save:使用主进程运行，在创建快照过程中会堵塞其他进程运行<br>bgsave:划分一个子进程用于执行快照，不会影响其他得到进程运行<br>AOF:使用的日志文件形式存储信息<br>可以设定数据发生变更时进行记录\</li>
<li>Redis内存占用情况<br>相同数据的情况下，32位操作系统比64位所使用的内存更少<br>100万条简单键值对，占用100M空间，实际占用空间较少，可存储数据量较大</li>
</ul>
<h2 id="Redis的优化"><a href="#Redis的优化" class="headerlink" title="Redis的优化"></a>Redis的优化</h2><ol>
<li>精简键名值数据:尽可能简单，但是能知意–&gt;<code>可以节省存储空间</code></li>
<li>在不需要持久化的应用场景中关闭持久化功能</li>
<li>内部编码优化</li>
<li>SlowLog:记录运行超时命令系统</li>
<li>修改Linux内核内存分配策略: 1:不需要检验内存情况，可以直接运行任务直到内存使用完为止</li>
<li>关闭THP:节省资源开销(redis修改时先复制再对复制内容修改)<br>(THP:如果数据只有200K,使用THP的情况下，这个大页大小约20M<br>不使用THP时，复制后总大小400K,使用了THP复制后总大小40M)</li>
<li>修改linux中的tcp最大连接数</li>
<li>限制Redis使用内存大小</li>
<li>做多条数据操作时，尽量选择批量操作命令不要通过循环执行</li>
</ol>
<h1 id="安全认证-amp-权限管理Kerberos-amp-Ldap"><a href="#安全认证-amp-权限管理Kerberos-amp-Ldap" class="headerlink" title="安全认证&amp;权限管理Kerberos &amp; Ldap"></a>安全认证&amp;权限管理Kerberos &amp; Ldap</h1><pre><code>在大数据平台中，统一身份体现在:只要通过用户名和密码成功登陆，就可以操作授`权过的组件`
统一用户管理系统:用户及相关权限管理、用户登录后的相关管理等
</code></pre>
<h2 id="统一身份认证管理系统"><a href="#统一身份认证管理系统" class="headerlink" title="统一身份认证管理系统"></a>统一身份认证管理系统</h2><ul>
<li>管理模块:管理信息存储,管理认证，用户请求</li>
<li>信息存储模块:存储用户信息、权限信息</li>
<li>认证模块:通过用户请求和当前系统存储的用户信息做比对，确认用户是否正确、核查用户权限</li>
</ul>
<h2 id="Ldap目录服务系统"><a href="#Ldap目录服务系统" class="headerlink" title="Ldap目录服务系统"></a>Ldap目录服务系统</h2><ul>
<li>目录:加快数据检索速度</li>
<li>轻量级目录访问协议、跟踪协议</li>
</ul>
<h2 id="LdapServer系统结构-树状结构"><a href="#LdapServer系统结构-树状结构" class="headerlink" title="LdapServer系统结构(树状结构)"></a>LdapServer系统结构(树状结构)</h2><ul>
<li>树状结构中会包含很多节点，每个节点都有自己的名称dn(当前节点及它的所有父节点)</li>
<li>根节点名称是dc,标记为区域</li>
<li>区域的下一级是组织，组织节点名称: ou</li>
<li>组织节点下一级是对象，对象节点名称: cn,存储对象属性</li>
</ul>
<h2 id="Ldap功能模块设计"><a href="#Ldap功能模块设计" class="headerlink" title="Ldap功能模块设计"></a>Ldap功能模块设计</h2><ul>
<li>查询类操作</li>
<li>更新类操作</li>
<li>认证类操作</li>
<li>其他操作:放弃服务或者扩展服务</li>
</ul>
<h2 id="Ldap集成设计"><a href="#Ldap集成设计" class="headerlink" title="Ldap集成设计"></a>Ldap集成设计</h2><ul>
<li>身份认证架构设计</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chencicici/images/main/202205151423534.png?token=ARYCSATO5HTD633FH2FZWO3CQCOKS"></p>
<ul>
<li><p>身份认证流程设计</p>
<ol>
<li>应用侧提交认证请求</li>
<li>Thrift Server从Ldap获取相关用户信息</li>
<li>Thrift Server执行认证比对</li>
<li>认证成功后将请求导向响应的应用</li>
</ol>
</li>
<li><p>身份认证功能设计<br>  可以通过组Group和角色Role的方式给用户赋予权限<br>  Group:设置组权限，将用户添加到组中<br>  Role:给角色设定权限，给用户匹配角色</p>
</li>
</ul>
<h2 id="Kerberos认证处理"><a href="#Kerberos认证处理" class="headerlink" title="Kerberos认证处理"></a>Kerberos认证处理</h2><ul>
<li>krbServer中的三大核心: Client 、KDC、 KDC Server</li>
<li>Client :接收用户请求</li>
<li>KDC:生成密钥，发放密钥等</li>
<li>KDC Server:提供密钥服务</li>
</ul>
<h2 id="Kerberos应用流程"><a href="#Kerberos应用流程" class="headerlink" title="Kerberos应用流程"></a>Kerberos应用流程</h2><ol>
<li>用户提供用户名和密码给登录认证系统</li>
<li>登录认证系统通过登录认证后，反馈一个当前用户的用户信息卡 (用户、密码、所授权信息)</li>
<li>用户获取到用户信息卡之后就可以进入到MRS中.</li>
<li>在MRS中找到对应的要使用的组件,提交自己的信息卡</li>
<li>组件对比信息卡查看是否具有当前组件的权限</li>
<li>用户前往权限授权中心,提交信息卡,权限授权中心根据信息卡对指定组件进行授权(ST)</li>
<li>用户获取到对应组件的授权信息，可以再次向组件发起请求(信息卡, ST)</li>
<li>组件接收到请求后再次校验,校验结果没问题的话，用户就可以正常使用组件</li>
</ol>

    </div>

    
    
    
      


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Syst1m
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://syst1m.top/2022/04/20/%E5%8D%8E%E4%B8%BAHCIA/" title="华为HCIA">https://syst1m.top/2022/04/20/华为HCIA/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/HCIA/" rel="tag"># HCIA</a>
              <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag"># 大数据</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/18/msf%E5%90%8E%E6%B8%97%E9%80%8F%E4%BD%BF%E7%94%A8/" rel="prev" title="msf后渗透使用">
                  <i class="fa fa-chevron-left"></i> msf后渗透使用
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/04/24/SQL%E6%B3%A8%E5%85%A5%E9%9D%B6%E5%9C%BAsqli-labs/" rel="next" title="SQL注入靶场sqli-labs">
                  SQL注入靶场sqli-labs <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Syst1m</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>


    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
